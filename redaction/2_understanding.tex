\chapter{Understanding source code}

In the previous chapter, we've seen that there is a focus on understanding when it comes to aesthetic standards: whether obfuscating or illuminating, understanding is a key determinant in the value judgment.

The point of this chapter is then to investigate what is it that makes code complicated to understand. This will have us deal with the nature of computation (what do computers and source code do?), with the nature of the world (how does one translate a problem domain into a software domain, through process of modelling and abstraction) and with the nature of the human mind (through the requirement to communicate with other humans.)

We will see what roles metaphors play; and, if linguistics is a key component in the writing of clear source code, we should also look at programming languages.

% develop more on why we even talk about understanding (that there is function in computation, and that most aesthetic and beauty appraisals are subject to this ability to function, because understanding enables/affords action)

The question is now: how does one organise all this?

% first the definition of understanding
\section{Understanding as embodied action}

This section focuses on our definition of understanding, which relies on two main aspects: a formal, abstract understanding, and a more subjective tacit one. We will see how the former had some traction in computer sciences circles, while the second gained traction in programming circles.

\subsection{Between formal and informal}

% wittgenstein (5000)

% then a transition to AI and abstract theories of mind and cognitivism (5000)

% gregory chaitin -> compression, implicit and efficiency

\subsection{Knowing-what and knowing-how}
% then simon penny and tacit knowledge

% and lakoff

% first the computer
\section{Understanding computation}

Why is it so, that two notions of understanding exist? What makes it challenging to understand computation? We'll look at it from a more abstract point of view, investigating the ontological status of software. This will highlight some of the theoretical properties that make it hard to understand, such as its relation to hardware, its relation to a specification, and its relation to time and space

We will also look at the practical investigations of how people understand software by looking into the psychology and cognition of programmers, with various studies and books on the subject.

% the software effect (combination of knowing what (it does) and how (it does it))
% the philosophical enquiries
\subsection{Software ontology}

\subsection{The psychology of programming}
% the studies

% then the human mind
\section{Means of understanding}

As we've seen in the previous sequence, there are specific problems to understanding computation, but there are also ways of achieving a good understanding of a program.

We'll look a bit deeper at some of those techniques, specifically metaphors and tools.

% then the communcation between both
\subsection{Metaphors of computation}

\subsection{Tools as an extension}
% IDEs

% The computer as prosthetic organ, distributed cognition

\pagebreak

Conclusion: we circle back to aesthetics, and we look at the things that are both tools and metaphors: programming languages.