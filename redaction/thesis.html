<!DOCTYPE html> 
<html lang='en-US' xml:lang='en-US'> 
<head><title></title> 
<meta charset='utf-8' /> 
<meta content='TeX4ht (https://tug.org/tex4ht/)' name='generator' /> 
<meta content='width=device-width,initial-scale=1' name='viewport' /> 
<link href='thesis.css' rel='stylesheet' type='text/css' /> 
<meta content='thesis.tex' name='src' /> 
</head><body>
                                                                  

                                                                  
<!-- l. 36 --><p class='indent'>
                                                                  

                                                                  
</p><!-- l. 36 --><p class='indent'>
                                                                  

                                                                  
</p>
<div class='center'>
<!-- l. 36 --><p class='noindent'>
</p><!-- l. 36 --><p class='noindent'><span class='ec-lmr-17'>The role of Aesthetics in the Understandings of
</span><span class='ec-lmr-17'>Source code</span>
</p>
<div class='tabular'> <table class='tabular' id='TBL-1'><colgroup id='TBL-1-1g'><col id='TBL-1-1' /></colgroup><tr id='TBL-1-1-' style='vertical-align:baseline;'><td class='td11' id='TBL-1-1-1' style='white-space:nowrap; text-align:center;'>               <span class='ec-lmr-12'>Pierre Depaz                       </span></td>
</tr><tr id='TBL-1-2-' style='vertical-align:baseline;'><td class='td11' id='TBL-1-2-1' style='white-space:nowrap; text-align:center;'><span class='ec-lmr-12'>under the direction of Alexandre Gefen (Paris-3)</span></td>
</tr><tr id='TBL-1-3-' style='vertical-align:baseline;'><td class='td11' id='TBL-1-3-1' style='white-space:nowrap; text-align:center;'>          <span class='ec-lmr-12'>and Nick Montfort (MIT)               </span></td>
</tr><tr class='vspace' style='font-size:10.0pt'><td> </td></tr><tr id='TBL-1-4-' style='vertical-align:baseline;'><td class='td11' id='TBL-1-4-1' style='white-space:nowrap; text-align:center;'>             <span class='ec-lmr-12'>ED120 - THALIM                    </span></td></tr></table>
</div>
<!-- l. 36 --><p class='noindent'><span class='ec-lmr-12'>last updated - 03.11.2021</span>
</p>
</div>
                                                                  

                                                                  
                                                                  

                                                                  
                                                                  

                                                                  
<!-- l. 1 --><p class='indent'>
                                                                  

                                                                  
</p>
   <h2 class='chapterHead' id='introduction'><span class='titlemark'>Chapter 1</span><br /><a id='x1-10001'></a>Introduction</h2>
<!-- l. 3 --><p class='noindent'>This thesis is an inquiry into the formal manifestations of source code, on how
particular configurations of lines of code allow for aesthetic judgments and on the
purposes that such configurations serve. The implications of this inquiry will
lead us to consider the different ways in which people read and the different
ways in which source code can be represented, depending on what it aims at
accomplishing, and on the contexts in which it operates. This study on source code
involves the different groups of people which read and write it, the purposes for
which they write it, the programming languages they use to write it, and
the natural language they use to speak about it. Most importantly, this
thesis focuses on source code as a material and linguistic manifestation of a
larger digital ecosystem of software and hardware to which it belongs. Since
source code is only one component of code, as we will see below, this thesis
also aims at studying the reality of written code, rather than its conceptual
interpretations.
</p><!-- l. 6 --><p class='indent'>   Starting from pieces of source code, this thesis will aim at assessing what
programmers have to say about it, and attempt to identify how one or more specific
<span class='ec-lmri-10'>aesthetic fields </span>are used to refer to it. This aim depends on two facts: first, source
code is a medium for expression, both to express the programmer’s intent to the
computer<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span> and the programmer’s intent to another programmer<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. Second, source
code is a relatively new medium, compared to, say, paint or mechanics. As
such, the development and solidification of aesthetic practices—that is, of
ways of doing which do not find their immediate justification in a practical
accomplishment—is an ongoing research project in computer science, software
development and the digital humanities. Formal judgments of source code
are therefore existing and well-documented, and are related to a need for
expressiveness, as we will see in chapter 2, but their formalization is still an ongoing
process.
</p><!-- l. 8 --><p class='indent'>   Source code thus can be written in a way makes it subject to aesthetic
judgments by programmers; that is, code <span class='ec-lmri-10'>has </span>aesthetics, but it is unclear
                                                                  

                                                                  
exactly <span class='ec-lmri-10'>which </span>aesthetics. Indeed, these aesthetic judgments as they exist
today rely on different domains to assess source code, as a means to grasp
the cognitive object that is software. These draw from metaphors ranging
from literature, architecture, mathematics and engineering. And yet, source
code, while related to all of these, isn’t exactly any of the them. Like the
story of the seven blind men and the elephant<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, each of these domains
touch on some specific aspect of the nature of code, but none of them are
sufficient to entirely provide a solid basis for the aesthetic judgments of source
code. It is at the crossroads of these domains that this thesis locates its
work.
</p><!-- l. 10 --><p class='indent'>   The examination of source code, and of the discourses around source code will
integrate both the diversity of ways in which source code can exist, and
the invariant aspects which underline all diverse approaches of source code.
Particularly, we will see how each groups of practicionners tend to deploy references
to one particular set of metaphorical references drawing from the domains
above, but also how these references overlap across groups. The point of
overlap, as we will demontrate, is that of <span class='ec-lmri-10'>using a formal linguistic system to
</span><span class='ec-lmri-10'>communicate the understanding of complex cognitive structures</span>. Through
an interdisciplinary approach, we attempt to connect this formal symbol
system to the broader role of aesthetics as a cognitive mechanism to deal with
complexity.
</p><!-- l. 12 --><p class='indent'>   The rest of this introduction will consist in establishing a more complete view of
the context in which this research takes place, from computer science to digital
humanities and science and technology studies. With this context at hand, we will
proceed to highlight the specific problems which will be tackled regarding the current
place of aesthetics in source code. After outlining our methodology and the
theoretical frameworks which will be mobilized throughout this study, we will sketch
out how the different chapters of this thesis will attempt at providing some responses
to our research questions.
                                                                  

                                                                  
</p>
   <h3 class='sectionHead' id='context'><span class='titlemark'>1.1   </span> <a id='x1-20001.1'></a>Context</h3>
<!-- l. 16 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='the-research-territory-code'><span class='titlemark'>1.1.1   </span> <a id='x1-30001.1.1'></a>The research territory: code</h4>
<!-- l. 18 --><p class='noindent'>Most of our modern infrastructure depends, to a more or less dramatic extent, on
software systems<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, from commercial spaces to classrooms, transport systems to
cultural institutions, scientific production and entertainment products. Software
regulates and automates the information stores, exchanges and creation which
compose each of these domains of human activities. The complex processes are
described in what is called source code, a vast and invisible set of texts. The number
of lines of code involved in running these processes is hard to estimate; one can
only rely on disclosures from companies, and publicly available repositories.
To give an order of magnitude, all of Google’s services amounted to over
two billions source lines of code (SLOC)<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, while the 2005 release of the
OSX operating system comprised 86 millions lines of code, and while the
version 1.0 of the Linux kernel (an operating system which powers most
of the internet and specialized computation) totalled over 175,000 SLOC,
version 4.1 jumped to over 19.5 million lines of code in the span of twenty
years<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.
</p><!-- l. 20 --><p class='indent'>   Given such a large quantity of textual mass, one might wonder: who reads this
code? To answer this question, we must start diving a bit deeper into what source
code really is.
</p><!-- l. 22 --><p class='indent'>   Source code consists in a series of instructions, composed in a particular
programming language, which is then processed by a computer in order to
be executed. For instance, using the language called Python, the source
code:
</p>
                                                                  

                                                                  
   <!-- l. 24 -->
<div class='lstlisting' id='listing-1'><span class='label'><a id='x1-3001r1'></a></span><span class='ec-lmtt-8'>    a = 4 </span><br /> 
<span class='label'><a id='x1-3002r2'></a></span><span class='ec-lmtt-8'>    b = 6 </span><br /> 
<span class='label'><a id='x1-3003r3'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-3004r4'></a></span><span class='ec-lmtt-8'>    def compute(first, second): </span><br /> 
<span class='label'><a id='x1-3005r5'></a></span><span class='ec-lmtt-8'>        return (first * 2) + second </span><br /> 
<span class='label'><a id='x1-3006r6'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-3007r7'></a></span><span class='ec-lmtt-8'>    compute(a, b)</span></div>
<!-- l. 34 --><p class='indent'>   consists in telling the computer to store two numbers in what are called <span class='ec-lmri-10'>variables</span>,
then proceeds with describing the <span class='ec-lmri-10'>procedure </span>for adding the double of the first terms
to the second term, and concludes in actually executing the above procedure. Given
this particular piece of source code, the computer will output the number <span class='lstinline'><span class='ec-lmtt-8'>14</span></span> as the
result of the operation <span class='lstinline'><span class='ec-lmtt-8'>(4 * 2)+ 6</span></span>. In this sense, then, source code is the requirement
for software to exist: since computers are procedural machines, acting upon
themselves and upon the world, they need a specification of what to do, and source
code provides such a specification. In this sense, computers are the main "readership"
of source code.
</p><!-- l. 36 --><p class='indent'>   However, it is also a by-product of software, since it isn’t no longer required once
the computer has processed and stored it into a <span class='ec-lmri-10'>binary </span>representation, a series of 0s
and 1s which represent the successive states that the computer has to go through in
order to perform the action that was described in the source code. <span class='ec-lmri-10'>Binary code </span>is
what most of the individuals who interact with computers deal with, in the form of
packaged applications, such as a media player or a web browser. They (almost) never
have to inquire about, or read, such source code. In this sense, then, source code only
matters until it gets processed by a computer, through which it realizes its intended
function.
</p><!-- l. 38 --><p class='indent'>   From another perspective, source code isn’t just about telling computers what to
do, but also a key component of a particular economy: that of software development.
Software developers are the ones who write the source code and this process is first
and foremost a collaborative endeavour. Software developers write code in successive
steps, because they add features over time, or they fix errors that have shown up in
their software, or they decide to rewrite parts of the source code based on new ideas,
skills or preferences. In this case, source code is not used to communicate to the
computer what it does, but it is used to communicated to other software
developers what the <span class='ec-lmri-10'>intent </span>of the software is. Source code is then the locus of
                                                                  

                                                                  
human, collaborative work; it represents iterations of ideas, formalization
of processes and approaches to problem-solving. As Harold Abelson puts
it,
</p><!-- l. 40 --><p class='indent'>
        </p><blockquote class='quotation'>
     <!-- l. 41 --><p class='indent'>     "Programs  must  be  written  for  people  to  read,  and  only
     incidentally for machines to execute."<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.</p></blockquote>
<!-- l. 45 --><p class='indent'>   Official definitions of source code straddle this line between the first role of source
code (as instructions to a computer) and the second role of source code (as
indications to a programmer). For instance, a definition within the context of the
Institute of Electrical and Electronics Engineering (IEEE) considers source
code <span class='ec-lmri-10'>any fully executable description of a software system, which therefore
</span><span class='ec-lmri-10'>includes various representations of this description, from machine code to
</span><span class='ec-lmri-10'>high-level languages and graphical representations using visual programming
</span><span class='ec-lmri-10'>languages</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. This definition focuses on the ability of code to be processed by a
machine, and mentions little about its readability (i.e. processability by other
humans).
</p><!-- l. 47 --><p class='indent'>   On the other hand, the definition of source code provided by the Linux Information
Project<span class='footnote-mark'><a href='#fn1x1' id='fn1x1-bk'><sup class='textsuperscript'>1</sup></a></span><a id='x1-3008f1'></a>
focuses on source code as <span class='ec-lmri-10'>the version of software as it is originally written (i.e. typed
</span><span class='ec-lmri-10'>into a computer), by a human in plain text (i.e. human-readable, alphanumeric
</span><span class='ec-lmri-10'>characters).</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. The emphasis here is on source code as the support of human
activity, as software developers need to understand the pieces of code that they are
creating, or modifying. Source code thus has two kinds of readabilities: a computer
one, which is geared towards the correct execution of the program, and a human one,
which is geared towards the correct understanding of the program. In the lineage of
this human-readability, we can point to the Free Software Foundation’s equation of
the free circulation and publication of source code with the free circulation of
publication of ideas. Particularly, Freedom 1 (<span class='ec-lmri-10'>The freedom to study how the
                                                                  

                                                                  
</span><span class='ec-lmri-10'>program works, and adapt it to your needs</span>) and Freedom 2 (<span class='ec-lmri-10'>The freedom to
</span><span class='ec-lmri-10'>improve the program, and release your improvements to the public, so that the
</span><span class='ec-lmri-10'>whole community benefits.</span>) as stated in the FSF’s definition of Free Software
stipulates that access to source code is required to support these freedoms, a
version of source code that is <span class='ec-lmri-10'>not concealed</span>, i.e. readable by both human and
machine<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.
</p><!-- l. 49 --><p class='indent'>   In addition to this ability to communicate the ideas latent in it, source code, as an
always potentially collaborative object, can be the locus of multiple subjectivities
coming together. As Krysa and Sedek state in their definition, <span class='ec-lmri-10'>source code is where
</span><span class='ec-lmri-10'>change and influence can happen</span>, and where <span class='ec-lmri-10'>intentionality and style are expressed</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.
In their understanding, source code shares some features with natural languages as
an intersubjective process<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, and as such is different from the machine language
representation of a program, an object which they do not consider source code
due to its unilaterality. The intelligibility of source code, they continue,
facilitates its circulation and duplication among programmers. It is this aspect of
a socio-technical object that we consider as important as its procedural
effectiveness.
</p><!-- l. 51 --><p class='indent'>   In this research, we build on these definitions to propose the following:
</p><!-- l. 53 --><p class='indent'>
     </p><blockquote class='quote'>
     <!-- l. 54 --><p class='noindent'>Source code is defined as one or more text files which are written
     by  a  human  or  by  a  machine  in  such  a  way  that  they  elicit  a
     meaningful  response  from  a  digital  compiler  or  interpreter,  and
     describe a software system. These text files are the starting point to
     produce an execution of the system described, whether the very first
     starting point, or an intermediate representation used for subsequent
     compilations. These files are collectively called <span class='ec-lmri-10'>program texts</span>.</p></blockquote>
<!-- l. 57 --><p class='indent'>   This definition takes into account a broad view of source code, including steps
such as intermediate representations (transitory representations from one version of
                                                                  

                                                                  
the source to another one), but also obfuscations (deliberately complicating the code
to prevent human-readability while maintaining machine-readability) and
minifications (reducing the amount of characters used in source code to its
minimum). This will allow us to compare human-authorship of source code,
machine-authorship, and hybrid modes, in which a human writes unreadable code
with the help of tools. One aspect that is being more narrowly defined for the
purpose of this study is the actual manifestation of code: while multiple media for
source code exist, we exclude here all of those that are not written in the UTF-8
character set—i.e. textual representations. Since one of the questions of this study is
to examine the literariness of source code aesthetics, other forms of source
code, such as visual programming languages or biological computation, stand
outside the scope of this study and should be investigated in subsequent
work.
</p><!-- l. 59 --><p class='indent'>   As for the term <span class='ec-lmri-10'>program text</span>, it is chosen in order to highlight the dual nature of
source code: that of a computational artefact to be formally processed and
unambiguously understood<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, and that of a open-ended, multi-layered document, in
the vein of Barthes’ distinction between a text and a work<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.
</p><!-- l. 61 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='beautiful-code'><span class='titlemark'>1.1.2   </span> <a id='x1-40001.1.2'></a>Beautiful code</h4>
<!-- l. 63 --><p class='noindent'>Under this definition of source code textually represented, we now turn to the
existence of the aesthetics of such <span class='ec-lmri-10'>program texts</span>. To contextualize this existence, we
first need to touch upon the history and practice of software development. As an
economic activity, software development came from a bottom-up dynamic, a <span class='ec-lmri-10'>de facto</span>
activity which was not expected in the early days of computing, where most of the
work was divided between mathematics and engineering. Its earliest manifestation
can be found in the physical rewiring process of mainframes in order to perform a
specific computation, something more akin to firmware than to software. These
rewiring tasks were done by mostly female assistants, under the direction of mostly
                                                                  

                                                                  
male mathematicians<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, and consisted in a simple translation task which did not
require any particular attention, or any particular skill. The recognition of
software engineering as its own field came as its unique domain of expertise
was required in larger engineering projects—for instance, the term <span class='ec-lmri-10'>software
</span><span class='ec-lmri-10'>engineering </span>was coined in the late 1960s by Margaret Hamilton and her team as
they were working on the Apollo 11 Lunar Module software<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. In the same
decade, the first volume of <span class='ec-lmri-10'>The Art of Computer Programming</span>, by Donald
Knuth, addresses directly both the existence of programming as an activity
separate from both mathematics and engineering, as well as an activity
with an "artistic" dimension<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. The first volume opens on the following
paragraph:
</p><!-- l. 65 --><p class='indent'>
     </p><blockquote class='quote'>
     <!-- l. 66 --><p class='noindent'>The  process  of  preparing  programs  for  a  digital  computer  is
     especially attractive, not only because it can be economically and
     scientifically  rewarding,  but  also  because  it  can  be  an  aesthetic
     experience much like composing poetry or music. This book is the
     first volume of a multi-volume set of books that has been designed
     to train the reader in the various skills that go into a programmer’s
     craft.<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span></p></blockquote>
<!-- l. 69 --><p class='indent'>   Considered one of the most canonical textbooks in the field, <span class='ec-lmri-10'>The Art of Computer
</span><span class='ec-lmri-10'>Programming </span>highlights two important aspects of programming for our purpose: that
it can be an aesthetic experience and that it is the result of a craft, rather than of a
highly-formalized systematic process, as we will see in chapter 1. Some of the aeshetic
references related to source code are related to its writing and reading being a
craft-like activity<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.
</p><!-- l. 71 --><p class='indent'>   Craftsmanship is an essentially fleeting phenomenon, a practice rather than a
theory, in the vein of Michel De Certeau’s <i>tactics</i>, bottom-up actions informally
designed and implemented by the users of a situation, product or technology as
                                                                  

                                                                  
opposed to <i>strategies</i><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, in which ways of doing are deliberately prescribed in a
top-down fashion. Craft is hard to formalize, and the development of expertise in the
field happens through practice as much as through formal education<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. It
is also one in which function and beauty exist in an intricate, embodied
and implicit relationship, based on subjective qualitative standards rather
than strictly external measurements, with the former rarely being explicitly
stated<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.
</p><!-- l. 73 --><p class='indent'>   Approaching programming (the activity of writing and reading code) as a craft<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>
connects to the multiple testimonies of encountering beautiful code, some of which
have made their ways into edited volumes or monographs<span class='cite'>[<span class='ec-lmbx-10'>?</span>, <span class='ec-lmbx-10'>?</span>, <span class='ec-lmbx-10'>?</span>]</span>. Additionally,
informal exchanges among programmers on forums, mailing lists, blog posts and code
repositories<span class='footnote-mark'><a href='#fn2x1' id='fn2x1-bk'><sup class='textsuperscript'>2</sup></a></span><a id='x1-4001f2'></a>
often mention beautiful code, either as a central discussion point or simply in
passing. These testimonies constitute the first part of our corpus, as sources in which
programmers comment on the aesthetic dimension of their practice. The second part
of the corpus is composed of selected program texts, which we will examine in order
to identify and formalize which aspects of the textual manifestation of software can
elicit an aesthetic experience.
</p><!-- l. 75 --><p class='indent'>   So the existence of something akin to art, something beautiful and pleasurable
emerging from the reading and writing of source code has been acknowledged since
the 1960s, in the early days of programming as a self-contained discipline. However,
the formalization of an aesthetics of source code first requires a working definition of
the concept of <span class='ec-lmri-10'>aesthetics </span>as used in this study.
</p><!-- l. 77 --><p class='indent'>   There is a long history of aesthetic philosphical inquiries
in the Western tradition, from beauty as the imitation of
nature<span class='footnote-mark'><a href='#fn3x1' id='fn3x1-bk'><sup class='textsuperscript'>3</sup></a></span><a id='x1-4002f3'></a>, moral
purification<span class='footnote-mark'><a href='#fn4x1' id='fn4x1-bk'><sup class='textsuperscript'>4</sup></a></span><a id='x1-4003f4'></a>, cognitive
perfection<span class='footnote-mark'><a href='#fn5x1' id='fn5x1-bk'><sup class='textsuperscript'>5</sup></a></span><a id='x1-4004f5'></a>, sensible representations
with emotional repercussions<span class='footnote-mark'><a href='#fn6x1' id='fn6x1-bk'><sup class='textsuperscript'>6</sup></a></span><a id='x1-4005f6'></a>.
The common point of these definitions is that of <span class='ec-lmri-10'>sensual manifestation</span>, that is the set
of visible forms which can enable an <span class='ec-lmri-10'>aesthetic experience</span>, a cognitive state
                                                                  

                                                                  
of pleasure relying on, amongst others, an object, a sense of unity and of
discovery<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.
</p><!-- l. 79 --><p class='indent'>   The definition of aesthetics that we will use in this thesis starts from this
requirement of sense perception, and then builds upon it using two theoretical
frameworks: Nelson Goodman’s theory of symbols<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span> and Gérard Genette’s
distinction between fiction and diction<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. The former provides us with an analysis of
formal systems in aesthetic manifestations and their role in a cognitive process, while
the second offers a broadened perspective on what qualifies as textual arts, or
literature.
</p><!-- l. 81 --><p class='indent'>   Goodman’s view on aesthetics is an essentially communicative one: we use
aesthetics to carry across more or less complex concepts. This communication process
happens through various symbol systems (e.g. pictural systems, linguistic systems,
musical systems, choreographic systems), the nature and organization of which can
elicit an aesthetic experience. His conception of such an aesthetic experience
isn’t one of self-referential composition, or of purely emotional pleasure,
but a cognitive one, one which belongs to the field of epistemology<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. The
symbol systems involved in the aesthetic judgment bear different kinds of
relations to the worlds they refer to—such as denoting, representing, ressembling,
exemplifying— and their purpose is to communicate a truth about these worlds<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.
In Goodman’s view, the arts and the sciences are, in the end, two sides of
the same coin. They aim at providing conceptual clarity through formal,
systematic means, and the arts can and should be approached with the same
rigor as the sciences. In our case, programming, with its self-proclaimed
craft-like status and its mathematical roots, stands equally across the arts and
sciences.
</p><!-- l. 83 --><p class='indent'>   His use of the term <span class='ec-lmri-10'>languages </span>implies a broader set of linguistic systems than that
of strictly verbal ones. This approach will support our initial conception of
programming languages as verbal systems, but will allow us not to remain
constrained by traditional literary aesthetics such as verse, rhyme or alliteration. To
what extent is programming a linguistic activity is going to be one of the main
inquiries of this thesis, and Goodman’s extended, yet rigorous definition leaves us
                                                                  

                                                                  
room to explore the semantic and syntactic dimension of source code as one of those
languages of art. Programming languages as symbol systems will be explored further
in Chapter 5.
</p><!-- l. 85 --><p class='indent'>   With this analytical framework allowing us to analyze the matter at
hand—program texts composed by a symbol system with an epistemic purpose—we
turn to a more literary perspective on aesthetics. Genette’s approach to literature,
<span class='ec-lmri-10'>the art of language</span>, results in the establishment of two dichotomies: fiction/diction,
and constitutivity/conditionality. In his eponymous work<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, he extends previous
conceptions of literature and poetics, from Aristotle to Jakobson, in order to broaden
the scope of what can be considered literature, by questioning the conditions under
which a text is given a literary status. As such, he establishes the existence of
conditional literature alongside constitutive literature: the former gains its status of a
literary text from the individual, subjective aesthetic judgment bestowed upon it,
while the latter relies on pre-exisiting structures, themes and genres. This approach
paves the way for an extending of the domain of literature<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, and a more
subtle understanding of the aesthetic manifestation in an array of textual
works.
</p><!-- l. 87 --><p class='indent'>   Genette also makes the distinction between fiction, with the focus being the
potentiality of a text’s object, its imaginative qualities and themes, and diction, with
an emphasis on the formal characteristics of the text. Since code holds two
existences, one as executed, and one as written, I propose to map Genette’s concept
of fiction on to source code when the latter is considered as a purely functional
text—i.e. what the source code ultimately does in its domain of application. Because
source code always holds software as a potential within its markings, its diction,
waiting to be actualized through execution, one has to imagine what this code
actually does. Written source code, then, could either be judged primarily on its
fiction or on its diction. Since we focus on the written form of source code, and not
on the type of its purpose, an attention to diction will be the entry point of this
thesis.
</p><!-- l. 89 --><p class='indent'>   A first approach to source code could be <span class='ec-lmri-10'>constitutive</span>, in Genette’s terms:
a given program text could be considered aesthetically pleasing because
                                                                  

                                                                  
the software it generates abides by some definitions of being aesthetically
pleasing<span class='footnote-mark'><a href='#fn7x1' id='fn7x1-bk'><sup class='textsuperscript'>7</sup></a></span><a id='x1-4006f7'></a>,
or because the software itself is considered a piece of art, shown in exhibitions and
sold in galleries. However, our empirical approach to source code aesthetics,
by examining various program texts directly, and our inquiry into the
possibility of multiple aesthetic fields co-existing within source code as a
symbol system, asks us to forgo this constitutive definition of an aesthetic
work as normative categories within software development. Our focus on
sense perception within aesthetics starts from a conditional approach, in
which programmers emit an aesthetic judgment on a program text, with an
emphasis first on what the source code <span class='ec-lmri-10'>is</span>, and only secondly on what it
<span class='ec-lmri-10'>does</span><span class='footnote-mark'><a href='#fn8x1' id='fn8x1-bk'><sup class='textsuperscript'>8</sup></a></span><a id='x1-4007f8'></a>.
</p><!-- l. 91 --><p class='indent'>   Diction, then, focuses on the formal characteristics of the text. The point here is
not to assume an autotelic mode of existence for source code, but rather to
acknowledge that there is a certain difference between the content of software and the
form of its source—good software can be written poorly, and poor software can be
written beautifully. This thesis chooses to focus on the formal aspects of code
such as not to restrict ourselves to any specific kind, or genre, of program
texts, leaving open the possibility for these categories to emerge after our
analysis.
</p><!-- l. 93 --><p class='indent'>   So, following Genette’s re-asking of the Goodman’s question of <span class='ec-lmri-10'>When is art?</span>
rather than the historical <span class='ec-lmri-10'>What is art?</span>, we can now proceed with our understanding
of aesthetics as a set of physical manifestations which can be grasped by the senses,
akin to "the movement of a light, the brush a fabric, the splash of a color"<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, which
aim at enabling a cognitive, communicative purpose, and which are not exclusively
constituted by pre-existing categories.
</p><!-- l. 95 --><p class='indent'>   This overview of the theoretical frameworks of this thesis already implicitly
denotes the boundaries of this study. The domain we are investigating here is one
that is delimited by both medium and purpose. First, the medium limitations is that
of text, in its material sense, as mentioned above in our definition of source
code. Second, the purpose limitation is that of computable code, rather than
                                                                  

                                                                  
computed code: we are examining latent programs, with their reality as texts
and their virtuality as actions, rather than the other way around. Executed
software and its set of affordances (e.g. graphical user interfaces<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, real-time
interactivity<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span> and process-intensive developments<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>) differ from the literary and
architectural ones that software, in its written form, is claimed to exhibit. However,
executable and executed software, being to sides of the same coin, might suggest
causal relationships—e.g. the aesthetics of source code affecting the aesthetics
of software—and such an inquiry would be best reserved for a subsequent
study.
</p><!-- l. 97 --><p class='indent'>   Now that we’ve explicited our object of study—the formal manifestations of
software under its textual form—we can turn to a review of the research that has
alredy been done on the subject, before highlighting some of the limitations. These
relations between source code and aesthetics have been addressed by academic
studies through different, separate dynamics.
</p><!-- l. 99 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='literature-review'><span class='titlemark'>1.1.3   </span> <a id='x1-50001.1.3'></a>Literature review</h4>
<!-- l. 102 --><p class='noindent'>A literature review on this topic must address the dualistic nature of studies on
source code, as research can be distinguished between the fields of computer science
and engineering on one side, and that of the humanities on the other. This overview
will provide us with a better sense of which aspects of code and aesthetics
have been explored until now, and will invite us to address the remaining
gaps.
</p><!-- l. 104 --><p class='indent'>   We have seen that most technical literature, starting from <span class='ec-lmri-10'>The Art of
</span><span class='ec-lmri-10'>Computer Programming</span>, acknowledges the role that aesthetics have to play
in the writing and reading of program texts. Along with the positions of
Knuth and Djikstra regarding the importance of paying attention to the
aspects of programming practice<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span> which go beyond strictly mathematical
and engineering requirements, Kerninghan and Plauer publish in 1978 their
                                                                  

                                                                  
<span class='ec-lmri-10'>Elements of Programming Style</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. In it, they focus on how code snippets with a
given intent could be rewritten in order to keep the same intent but gain in
quality—that is, in readability and understandability. For instance, the following
program:
</p>
   <!-- l. 106 -->
<p id=''><a id='x1-5001'></a></p>
<div class='lstlisting' id='listing-2'><span class='label'><a id='x1-5002r1'></a></span><span class='ec-lmtt-8'>    if(i == 0) c = ’0’ </span><br /> 
<span class='label'><a id='x1-5003r2'></a></span><span class='ec-lmtt-8'>    if(i == 1) c = ’1’ </span><br /> 
<span class='label'><a id='x1-5004r3'></a></span><span class='ec-lmtt-8'>    if(i == 2) c = ’2’ </span><br /> 
<span class='label'><a id='x1-5005r4'></a></span><span class='ec-lmtt-8'>    if(i == 3) c = ’3’ </span><br /> 
<span class='label'><a id='x1-5006r5'></a></span><span class='ec-lmtt-8'>    if(i == 4) c = ’4’ </span><br /> 
<span class='label'><a id='x1-5007r6'></a></span><span class='ec-lmtt-8'>    if(i == 5) c = ’5’ </span><br /> 
<span class='label'><a id='x1-5008r7'></a></span><span class='ec-lmtt-8'>    if(i == 6) c = ’6’ </span><br /> 
<span class='label'><a id='x1-5009r8'></a></span><span class='ec-lmtt-8'>    if(i == 7) c = ’7’ </span><br /> 
<span class='label'><a id='x1-5010r9'></a></span><span class='ec-lmtt-8'>    if(i == 8) c = ’8’ </span><br /> 
<span class='label'><a id='x1-5011r10'></a></span><span class='ec-lmtt-8'>    if(i == 9) c = ’9’</span></div>
<!-- l. 119 --><p class='indent'>   can be rewritten as:
</p>
   <!-- l. 121 -->
<div class='lstlisting' id='listing-3'><span class='label'><a id='x1-5012r1'></a></span><span class='ec-lmtt-8'>    if(i &gt;= 0 &amp;&amp; i &lt; 10) c = ’0’ + i</span></div>
<!-- l. 125 --><p class='indent'>   which keeps the exact same functionality, but becomes much clearer. Why it
becomes much clearer, though, is thought to be a given for the reader, and not
explicited by the authors in terms of concepts such as cognitive surface, repleteness of
a symbol system or representation of the main idea(s) at play (casting an integer to a
character, rather than individually checking for each integer case). As the authors do
employ terms which will form the basis of an aesthetics of software development, such
as clarity, simplicity, or expressiveness, there are nonetheless no overarching
principles deployed to systematize the manifestation of such principles, only examples
are given.
</p><!-- l. 127 --><p class='indent'>   While Kernighan and Plauer do not directly address the relationship of source
code and aesthetics, this is something that Peter Molzberger undertakes five years
later through an empirical, qualitative study aimed at highlighting the place
aesthetics play in an expert programmer’s practice<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. Molzberger’s study touches
upon ideas of over-arching structure, tension between clarity and personality, and
levels of expertise in aesthetic judgment. This short paper highlights multiple
                                                                  

                                                                  
instances of code deemed beautiful which will be explored further in this thesis,
without providing an answer as to <span class='ec-lmri-10'>why </span>this might be the case. For instance, a
conception of code as literature does not explain instances involving switch in scales
and directions of reading, or a conception of code as mathematics does not
explain the explicitly required need for a personal touch when writing source
code<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.
</p><!-- l. 129 --><p class='indent'>   In the context of formal academic research, such as the IEEE or the
Association for Computing Machinery (ACM), subsequent research focuses on
how to quantitatively assess a given quality of source code either through a
social perspective on the process of writing<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, a semantic perspective on the
lexicon being used<span class='cite'>[<span class='ec-lmbx-10'>?</span>, <span class='ec-lmbx-10'>?</span>]</span>, an empirical study of programming style in the
efficiency of software teams<span class='cite'>[<span class='ec-lmbx-10'>?</span>, <span class='ec-lmbx-10'>?</span>]</span> or on the visual presentation of code in the
comprehension process<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. These focus on the connection of aesthetics with the
performance of software development—beautiful code as being related to a good
end-product. These methodologies are mostly quantitative, and do not take
into account the "artistry" and "craft" component as laid out by Knuth and
Molzberger, but are rather a big-data representation of Kernighan and Plauer’s
approach.
</p><!-- l. 131 --><p class='indent'>   The development of software engineering as a profession has led to the publication
of several books of specialized literature, taking a practical approach to writing good
code, rather than a scientific one. Robert C. Martin’s <span class='ec-lmri-10'>Clean Code</span>’s audience belongs
to the fields of business and professional trade, drawing on references from
architecture, literature and craft in order to lay out the requirements of what
he considers to be clean code. These specific mechanisms are highlighted
in terms of how they will support a productive increase in the quality of
software developed, as opposed as being satisfying in and of themselves. <span class='ec-lmri-10'>Clean
</span><span class='ec-lmri-10'>Code </span>was followed by a number of additional publications on the same topic
and with the same approach<span class='cite'>[<span class='ec-lmbx-10'>?</span>, <span class='ec-lmbx-10'>?</span>, <span class='ec-lmbx-10'>?</span>]</span>. Here, these provide an interesting
counterpoint to academic research on quality code by relying on different traditions,
such as the practical handbook, to explain why the way code is written is
important.
                                                                  

                                                                  
</p><!-- l. 133 --><p class='indent'>   Technical and engineering literature, then, establish the existence of and
need for aesthetics, presented as formal properties which then constitute
<span class='ec-lmri-10'>quality code</span>. The methodology in these studies is either empirical, in the
case of academic articles, looking at large corpora, more rarely interviewing
programmers in order to draw conclusions regarding this relationship between
formal properties and quality, while monographs and business literature
draw on the experiences of their authors as a programmers to provide source
code examples of specific principles, without extending on the rationale and
coherence of these principles, let alone within a source code-specific aesthetic
framework. A particularly salient example is Greg Oram’s edited volume <span class='ec-lmri-10'>Beautiful
</span><span class='ec-lmri-10'>Code</span>, in which expert programmers are invited to pick a piece of code and
explain why they like it, sometimes commenting it line by line<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. This very
concrete, empirical inquiry into what makes source code beautiful does no,
however, include a strong enough conclusion as to what <span class='ec-lmri-10'>actually </span>makes code
beautiful, but rather writing why they like the idea behind the code, or
manifestoes such as Matz’s <span class='ec-lmri-10'>Code as an Essay</span>. As such, this monograph will be
integrated in our corpus, as commentary rather than academic research. Another
limitation to these studies is that they only address one specific group of
programmers, and one specific type of software being written. In effect, those who
write and read source code are far from being a homogeneous whole, and
can be placed along distinct lines—e.g. academics, tinkerers or artists—with
distinct practices and standards<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. In none of these studies is it considered
whether the conclusions established for one group would be valid for the
others.
</p><!-- l. 135 --><p class='indent'>   Before we move on to the perspective of the humanities, one should also note
the specific field of philosophy of computer science, which inquires into the
nature of computation, from ontological, epistemological and ethical points of
view. These are useful both in the meta positioning they take regarding
computer science as they well as how they show that issues of representation,
interpretation and implementation are still unresolved in the field. Particularly,
Rapaport’s <span class='ec-lmri-10'>Philosophy of Computer Science </span>provides an exhaustive literature
                                                                  

                                                                  
review of the different fields which computer science is being compared to,
from mathematics, engineering and art but—interestingly—few references to
computer science as having any kind of relation with literature<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. Another,
more specific perspective is given by Richard P. Gabriel in his <span class='ec-lmri-10'>Patterns of
</span><span class='ec-lmri-10'>Software</span>, in which he looks at software as a similar endeavour as architecture,
drawing on the works of Christopher Alexander. The focus is on its creative
and relationship to patters, a subject we will investigate more in chapter 3.
Finally, Brian Cantwell-Smith’s introduction to his upcoming <span class='ec-lmri-10'>The Age of
</span><span class='ec-lmri-10'>Significance: An Essay on the Origins of Computation and Intentionality</span>
touches upon these similar ideas of intentionality by suggesting both that
computation might be more productively studied from a humanities or artistic point
of view than form a strictly scientifc point of view<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. These philosophical
inquiries into computation mention aesthetics mostly on the periphery, but
nonetheless challenge the notion of computation as strictly functional, and suggest
additional that perspectives on the topic are needed, including that of the
arts.
</p><!-- l. 139 --><p class='indent'>   From a humanities perspective, recent literature taking source code as the
central object of their study covers fields as diverse as literature, science and
technology studies, humanities and media studies and philosophy. Each of these
monographs, edited volumes, catalog articles, book chapters or PhD theses,
engage with code in its multiple intricacies. Software applications, source code
excerpts, programming environments and languages are included in each of these
works as primary sources, are considered as text to be read, examined and
interpreted.
</p><!-- l. 141 --><p class='indent'>   A first look at <span class='ec-lmri-10'>Aesthetic Computing</span>, edited by Paul A. Fishwick allows us to
higlight one of the important points of this thesis: the collection of essays in this
collected volume focus more often on the graphical output of the software’s work
from the end-user’s perspective than on the textual manifestations of their source
(e.g. Nake and Grabowski’s essay on the interface as aesthetic event)<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. As for most
studies of aesthetics within computer science, the main focus is on Human-Computer
                                                                  

                                                                  
Interaction (HCI) as the art and science of presenting visually the output and
affordances of a running program. While a vast and complex field, this is not
the topic of this thesis which, rather than focusing on the aesthetics of the
computable and executable, is limited to the aesthetics of the computed
(texts).
</p><!-- l. 143 --><p class='indent'>   The following works, because of their dealing with source code as text, and due to
the background of their authors in literature and comparative media studies,
incorporate some aspect of literary theory and criticism, and authors such as N.
Katherine Hayles, Maurice J. Black and Alan Sondheim rely on it as their principal
perspective. Black, in his PhD dissertation <span class='ec-lmri-10'>The Art of Code</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span> initiates the idea of a
cross between programming and literature, and hypothesizes that writing
source code is an act that is closer to modernism than postmodernism, as
it relies on concepts of authorship, formal linguistic systems and, to some
extent, self-reference. The aim of the study is to show how code functions
with its own aesthetic, one which is distinct and yet closely related to a
literary aesthetic. After highlighting how the socio-political structures of
computing since the 1950s have affected the constitution of the idea of a
code aesthetic both in professional and amateur programmers, Black moves
towards the examination of code practices as aesthetic practices. Here, Black
limits himself to the presentation of coding practices insofar as they are
identified and referred to as aesthetic practices, but exclusively through a
social, second-hand account, rather than formal, definition of a source code
aesthetic.
</p><!-- l. 145 --><p class='indent'>   Black establishes programming as literature, and vice-versa, he assumes
that it is possible to write about literature through the lens of source code.
However, the actual analysis of source code with the help of formal literary
theories is almost entirely side-stepped, mentioning only Perl poetry as an
overtly literary use of code. In summary, Black provides a first study in
code as a textual object and as a textual practice whose manifestations
programmers care deeply about, but does not address what makes code poetry
different in its writing, reading and meaning-making than natural-language
                                                                  

                                                                  
poetry.
</p><!-- l. 147 --><p class='indent'>   N. Katherine Hayles, in <span class='ec-lmri-10'>My Mother Was A Computer: Digital Subjects and
</span><span class='ec-lmri-10'>Literary Texts</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, and particularly in the <span class='ec-lmri-10'>Speech, Writing, Code: Three Worldviews</span>
essay temporarily removes code from its immediate social and historical situations
and establishes it as a cognitive tool as significant in scale as those of orality and
literacy<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, and attempts to qualify this worldview both in opposition to Saussure’s
<span class='ec-lmri-10'>parole </span>and Derrida’s <span class='ec-lmri-10'>trace</span>, following cybernetics and media studies thinkers such as
Friedrich Kittler and Mark B. Hansen. Specifically, she introduces the idea of a
Regime of Computation, which relies on the conceptual specificities of code-based
expression (among which: depth, dynamism, fragmentation, etc.). Source-code
specific contributions touch upon literary paradigms and cognitive effect in two ways.
First, she highlights the way code recombines some traditional dialectics of
literary theory, namely paradigmatic/syntagmatic, discreete/continuous,
compilation/interpretation, and flat/stacked languages, acting as such as clearly
different mode of expression. Second, she draws on a comparison between two main
programming paradigms, object-oriented programming and procedural programming,
and on the syntax of programming languages, such as C++, in order to highlight a
novel relationship between the structure and the meaning of programming
texts, a structure which depends on its degree of similarity with natural
languages.
</p><!-- l. 149 --><p class='indent'>   While Hayles provides the basis for a much deeper analysis of source code’s
formal literary properties, she also maintains that source code studies should keep in
mind the ever-underlying materiality that this very source code relies on; and
then locates this materiality in the embodiment of users and readers, along
with authors such as Mark Hansen<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, Bernadette Wegenstein<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span> and Pierre
Lévy<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. Beyond the brief acknowledgment that she has of the political and
economical conditions of software development and their impact on electronic
texts, Hayles also stops short of considering programming languages in their
varieties, and the material apparatuses which support them (documentation,
architectures, compilers, tutorials, conferences and communities). Building
on this approach, a conception of programming languages as a material
                                                                  

                                                                  
seems like a possible avenue for looking into the formal possibilities they
afford.
</p><!-- l. 151 --><p class='indent'>   Alan Sondheim’s essay <span class='ec-lmri-10'>Codework</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, as the introduction of the American Book
Review issue dedicated to this specific form, provides another aspect of poetry which
integrates source code as a creole language emerging from the interplay of natural
and machine languages. Yet, this specific aspect of literary work scans the surface of
code rather than with its structure and therefore provides more insight in the
anthropology of how humans represent code through speech, rather than representing
speech through code. This presents a somewhat postmodern view of programming
languages, forcing them upon a relational, mutable conception of language as as
series speech-acts, and leaving aside their structural and post-structural
characteristics. Codework is essentially defined by its content and <span class='ec-lmri-10'>milieu</span>,
one which focuses on human exchanges and bypasses any involvement of
machine-processing.
</p><!-- l. 153 --><p class='indent'>   Another perspective on the relationship between speech and code is explored by
Geoff Cox and Alex Mclean in <span class='ec-lmri-10'>Speaking Code: Coding as Aesthetic and Political
</span><span class='ec-lmri-10'>Expression</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. They establish reading, writing and executing source code as a
speech-act, extending J.L. Austin’s theory to a broader political application by
including Arendt’s approach of human activities and labor<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, from which coding is
seen as the practice of producing laboring speech-acts.
</p><!-- l. 155 --><p class='indent'>   They consider source code as a located, instantiated presence, understood as a
politically semantic object affecting the multiple economic, social and discursive
environments in which it lives. Focusing on speech particularly, this study doesn’t
quite address the syntactic specificities of codes, for example by looking at the use of
loops, arrays, or other syntactical structures briefly touched upon by Hayles.
Side-stepping the particular grammatical features of that speech, the authors
nonetheless often illustrate the points they are working through, or begin
developing those points, with snippets of code written by either McLean
or established software artists, thus engaging with details of source code
and taking a step away from the dangers of fetishizing code, or <span class='ec-lmri-10'>sourcery</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.
They include both deductive code (commenting existing source code) or
                                                                  

                                                                  
inductive code (code written to act as an example to a point developed by
the authors), in a show of the intertextuality of program texts and natural
texts.
</p><!-- l. 157 --><p class='indent'>   Away from the cultural relevance of code as developed by Cox and McLean,
Florian Cramer focuses on the cultural history of writing in computation,
tying our contemporary fascination with source code into an older web of
historical attempts at integrating combinatorial practices from Hebraic texts
to Leibniz’s universal languages<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. It is in this space between magic and
logic that Cramer locates today’s experiments in source code (i.e. source
code poetry, esoteric languages and codeworks), reminiscent of Simondon’s
definition of a technical object’s essence<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. By relocating it between magic and
reality, code is no longer just arbitrary symbols, or machine instructions but
also ideal execution, a set of discreete forms which relate to the totality
of the world. Once formal execution is considered a cosmogonical force, it
becomes synonymous with performative execution, through which it ties back to
cultural practices throughout the ages, within both religious and scientific
contexts.
</p><!-- l. 159 --><p class='indent'>   Cramer extracts five axes along which to apprehend code-based works:
totality/fragmentation, rationalization/occultation, hardware/software,
syntax/semantics, artificial/natural language. While all these axes overlap each other,
it is the <span class='ec-lmri-10'>syntax/semantics </span>axis which aligns most with this research, givent that these
thematical axes are all variations of one another. Towards the end of the book, his
development of the concept of speculative programming is also particularly fruitful as
the attempt to become a figure of thought and reflection in theory and artistic
practice. Cramer states:
</p><!-- l. 161 --><p class='indent'>
     </p><blockquote class='quote'>
     <!-- l. 162 --><p class='noindent'><span class='ec-lmri-10'>formalisms [...] have a cultural semantics of their own, even on
     </span><span class='ec-lmri-10'>the most primitive and basic level. With a cultural semantics, there
                                                                  

                                                                  
     </span><span class='ec-lmri-10'>inevitably is an aesthetics, subjectivity and politics in computing.</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span></p></blockquote>
<!-- l. 165 --><p class='indent'>   This points to the relationship between the formal disposition of source code
within program texts and the cultural communities composed of the writers and
readers of these program texts. As we’ve seen, code does have social components of
varying natures, insofar as it operates as an expressive medium between varying
subjects.
</p><!-- l. 167 --><p class='indent'>   Adrian MacKenzie approaches source code, as part of a broader inquiry on the
nature of software, through this social lens in <span class='ec-lmri-10'>Cutting Code: Software and
</span><span class='ec-lmri-10'>Sociality</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. The author focuses on a relational ontology of software: it is defined in
how it acts upon, and how it is being acted upon by, external structures, from
intellectual property frameworks to design philosophies in software architectures; it
only provides an operational definition—software is what it does. His analysis of
source code poetry focuses on famous Perl poems, Jodi’s artworks and Alex McLean’s
<span class='lstinline'><span class='ec-lmtt-8'>forkbomb.pl</span></span>, concerned with the executability of code as its dominant feature,
dismissing Perl poetry as "<span class='ec-lmri-10'>a relatively innocuous and inconsequential activity</span>"<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.
While software could indeed be a "patterning of social relations"<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, these social
relations also take place through linguistic combinations in program texts.
This tending to the material realities of software embedded within social
and cultural networks and traditions is echoed in David M. Berry’s <span class='ec-lmri-10'>The
</span><span class='ec-lmri-10'>Philosophy of Software: Computation and Mediation in the Digital Age</span>.
His definition of materialities, however, focuses on the technical and social
processes <span class='ec-lmri-10'>around </span>code (e.g. build processes, specifications, test suites), rather
than on the processes <span class='ec-lmri-10'>within </span>code (i.e. texts, languages). While this former
definition results in what he calls a <span class='ec-lmri-10'>semiotic place</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, a location in which those
processes are organized meaningfully, such a semiotic sense of space could also
apply, as we will see in chapter 2, to those intrinsic properties of source
code.
</p><!-- l. 169 --><p class='indent'>   Focusing specifically on the category of code poetry, Camille Paloque-Berges
published, a couple of years later, <span class='ec-lmri-10'>Poétique des codes sur le réseau informatique</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.
This work deploys both linguistic and cultural studies theorists such as Barthes and
                                                                  

                                                                  
De Certeau in order to explain these playful acts of source code poetry, along with
works of esoteric languages and net.art. While the first chapter focuses on digital
literature as the result of executed code in order to develop a heuristic to approach
source code, and the third and last chapter focusing on the means of distribution of
these works, particularly on the development of net.art, 1337 5p43k and codeworks,
the second chapter is the most relevant to our research focus. In it, Paloque-Berges
provides an introduction of creative acts in source code on both a conceptual
level (drawing from Hayles and Montfort) and on a technical, syntactical
level. She looks at specific programming patterns and practices (<span class='lstinline'><span class='ec-lmtt-8'>hello world</span></span>,
quines), technical syntax (e.g. <span class='lstinline'><span class='ec-lmtt-8'>$</span></span>, <span class='lstinline'><span class='ec-lmtt-8'>@</span></span> as Perl tokens for expressing singular or
plurals) and cultural paradigms (De Certeau’s tactics and strategies), as she
attempts to highlight the specificities of source code for aesthetic manifestation
and invites further work to be done in this dual vein of close-reading and
theoretical contextualization, beyond specific, heightened instances such as Perl
poetry.
</p><!-- l. 171 --><p class='indent'>   Honing on a minimal excerpt, <span class='ec-lmri-10'>10 PRNT CHR</span><span class='lstinline'><span class='ec-lmtti-10x-x-80'>$</span></span><span class='ec-lmri-10'>(205.5+RND(1)) : GOTO 10;</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>,
is a collaborative work examining the cultural intertwinings of a single line of
code, through hardware, language, syntax, outputs and themes. The whole
endeavour is one rigorous close-reading of source code, in a deductive fashion,
working from the words on the screen and elaborating the context within
which these words exist, in order to establish the cultural relevance of source
code, as related to the syntax, hardware and cultural context in which these
words exist. While the study itself, being a close-reading of only one work,
and particularly a <span class='ec-lmri-10'>one-liner</span>, itself a specific genre, is restricted in terms of
broad aesthetic statements, it does show how it is possible to talk about
code not as an abstract construct but as a concrete reality. Particularly
interesting is the section dedicated to the history of the BASIC programming
language, and how particular languages afford particular statements and
actions better in a given historical context, a point often glossed over in other
studies.
</p><!-- l. 173 --><p class='indent'>   A current synthesis of these approaches, Mark C. Marino’s <span class='ec-lmri-10'>Critical Code
                                                                  

                                                                  
</span><span class='ec-lmri-10'>Studies</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span> and the eponymous research field it belongs to focuses on close-reading of
source code as a method for interpreting it as discourse. Particularly, it is organized
around cases studies: each with source code, annotations and commentary. This
structure furthers the empirical approach we’ve seen in Cox and McLean’s code,
starting from lines of source code in order in order to deduce cultural and social
environments and intents through interpretation. This particular monograph, as is
stated in the conclusion, offers a set of possible methodologies rather than
conclusions in order to engage with code as its textual manifestations: the
source code, viewed from different angles, can reveal more than its functional
purpose. While Marino, with a background in the humanities, focuses mostly
on the literary properties of code as a textual artifact, this thesis builds
here on some of his methodologies, particularly reading how the form of the
code complements its process and output, and searching the code for clever
re-purposing or insight. However, while Marino mentions the aesthetics of code, he
does not address the systematic composition of these aesthetics—focusing
primarily on <span class='ec-lmri-10'>what </span>the code means and only secondarily on <span class='ec-lmri-10'>how </span>the code means
it.
</p><!-- l. 175 --><p class='indent'>   Taking a step back, Warren Sack’s <span class='ec-lmri-10'>The Software Arts</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span> historicizes software
development as an epistemological practice, rather than as a strictly economic trade.
Connecting some of the main components of software (language, algorithm,
grammar), he demonstrates how these are rooted in a liberal arts conception of
knowledge and practice, particularly visible as a parallel to Diderot and D’Alembert’s
encyclopedic attempt at formalizing craft practices. By examining this other,
humanistic, tradition in parallel with its dominantly acknowledged scientific
counterpart, Sack shows the multiple facets that code and software can support.
Starting from the concept of "translation" as an updated version of Manovich’s
"transcoding", Sack analyzes what is being translated by computing, such as analyses,
rhetoric and logic, byt doesn’t however address the nature of the process in
which these concepts are translated—algorithms as (liberal) ideas, but not as
texts.
</p><!-- l. 177 --><p class='indent'>   This activity of programming as craft, already acknowledged by programmers
                                                                  

                                                                  
themselves, is further explored in Erik Pineiro’s doctoral thesis<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. In it, he examines
the concrete, social and practical justifications for the existence of aesthetics within
the software development community. Departing from specific, hand-picked examples
such as those featured in Marino’s study, his is more of an anthropological
approach, revealing what role aesthetics play in a specific community of
practicioners. Outlining references to ideas such as <span class='ec-lmri-10'>cleanliness</span>, <span class='ec-lmri-10'>simplicity</span>,
<span class='ec-lmri-10'>tightness</span>, <span class='ec-lmri-10'>robustness</span>, amongst others, as aesthetic ideals that programmers
aspire to, he does not however summon any specific aesthetic field (whether
from literature, mathematics, craft or engineering), but rather frames it in
terms of <span class='ec-lmri-10'>intrsumental goodness</span>, with the aesthetics of code being an attempt
to reach excellence in instrumental action. While he carefully lays out his
argument by focusing on what (a certain group of) programmers actually
say, instead of what they might be saying, there remains two limitations: it
is not clear how source code as textual material can afford to reach such
aesthetic ideals, and whether or not these aesthetic ideals apply to other groups
of writers of code, such as the code poets mentioned in some of the works
above.
</p><!-- l. 181 --><p class='indent'>   This literature review allows us to have a better grasp of how the relationship
between source code and aesthetics has been studied, both from a scientific and
engineering perspective, as well as from a humanities perspective.
</p><!-- l. 183 --><p class='indent'>   In the former approach, aesthetics are acknowledged as a component of reading
and writing code, and assessed through practical examples, quantitiative analysis
and, to a lesser extent, qualitative interviews. The research focus is on the
effectiveness of aesthetics in code, rather than on unearthing a systematic approach
to making code beautiful, even though issues of cognitive friction and understanding,
as well as ideals of cleanliness, readability, simplicity and elegance do arise. As
such, they form a good starting ground of varied, empirical investigations.
On a more metaphysical level, works in the field of philosophy of computer
science point at the fact that the nature of computing and software are
themselves evasive, straddling different lines while not aligning clearly with either
                                                                  

                                                                  
science, engineering or arts—pointing out that software is indeed something
different.
</p><!-- l. 186 --><p class='indent'>   As for the humanities, the focus is predominantly on literary heuristics of a
restricted corpus or on socio-cultural dynamics, and the details and examples of the
actual code syntax and semantics are often omitted even though the aesthetic aspects
of a literary or cultural nature are being explored in source code, as a new kind
of writing. There is a potential for beauty and art in source code,as made
obvious by code poetry, but such a potential is not assessed through the
same empirical lense as the former part of our literature review and only
secondarily investigating which of intrinsic features of code can support aesthetic
judgments.
</p><!-- l. 188 --><p class='indent'>   Still, some recent studies, such as those by Paloque-Bergès, Montfort
et. al, Cox and McLean and Marino, do engage directly with source code
examples, and these constitute important landmarks for a code-specific aesthetic
theory and methodology, whether it is as poetic language, speech-act, or
critical commentary. Source code is taken as a unique literary device, but
it remains unclear in exactly which aspects, besides its executability, it is
different from both natural languages and low-level machine languages, and
how this literary aspect relates to the effective, mathematical and craft-like
nature of source code considered in the computer science and engineering
literature.
</p><!-- l. 190 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='the-aesthetic-specificities-of-source-code'><span class='titlemark'>1.2   </span> <a id='x1-60001.2'></a>The aesthetic specificities of source code</h3>
<!-- l. 192 --><p class='noindent'>We can now turn to some of the gaps and questions left by this review, which can be
grouped under three broad areas: dissonant aesthetic fields, lack of correspondance
between empirical investigations and theoretical frameworks, and an absence of
close-reading of program texts as expressive artifacts.
                                                                  

                                                                  
</p><!-- l. 194 --><p class='indent'>   First, we can see that there are different aesthetic fields being summon when
assessing aesthetics in source code. By aesthetic field, I mean the set of
medium-specific symbol systems which operate coherently on a stylistic level, as well
as on a thematic level. The main aesthetic fields addressed in the context of source
code are those of literature, architecture as well as craft and mathematics. Each
of these domains have specific ways to structure the aesthetic experience
of objects within that field. For instance, literature can operate in terms
of plot, consonance or poetic metaphor, while architecture will mobilize
concepts of function, structure or texture. While we will reserve a more
exhaustive description of each of these aesthetic fields in chapter 3, the first gap I
would like to highlight here is how the multiple aesthetic fields are used to
frame the aesthetics of source code, without this plurality being explicitely
addressed. Depending on which study one reads, one can see code as literature, as
architecture, as mathematics or as craft, and there does not seem to be a
consensus as to which of these maps closest to the essence of source code,
with exhaustive studies often mentioning several, if not all of the above,
fields<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.
</p><!-- l. 196 --><p class='indent'>   Second, we can see a disconnect between empirical and theoretical work. The former,
historically more present in computer science literature, but more recently finding its
way into the humanities, aims at observing the realities of source code as a textual
object, one which can be mined for semantic data analysis, or as a crafted object, one
which is produced by programmers under specific conditions and replicated through
examples and principles, rather than systems and theorems. Conversely, the
theoretical approach to code, focusing on computation as a broad phenomenon
encompassing engineering breakthroughs, social consequences and disruption of
traditional understandings of textuality, rarely confronts such theoretical
approaches with the concrete, physical manifestations of computation as source
code<span class='footnote-mark'><a href='#fn9x1' id='fn9x1-bk'><sup class='textsuperscript'>9</sup></a></span><a id='x1-6001f9'></a>,
until recently. In consequence, there are theoretical frameworks that emerge to
explain software (e.g. computation, procedurality, protocol), but no frameworks yet
which tend to the aesthetics of source code. In the light of the history of aesthetic
                                                                  

                                                                  
philosophy, literature studies and visual arts, defining such a precise framework
seems like an elusive goal, but it is rather the constellation of conflicting and
complementing frameworks which allow for a better grasp of their object of study. In
the case of the particular object of this study, the establishment of such framework
taking into account the specifically textual dimension of source code (as
opposed to, say, McLean and Cox’s attention to the speech dimension) is yet to
be done. Following the software development and programming literature,
such a framework could productively focus on the role and purpose that
aesthetics play within source code, rather than on their autotelic nature as
manifestations-for-themselves.
</p><!-- l. 199 --><p class='indent'>   Finally, and related to the point above, we can identify a methodological gap. Due
to reasons such as access and skill, close-reading of source code from a humanities
perspective has been mostly absent, until the recent emergence of fields of
software studies and critical code studies. The result is that many studies
engaging with source code as a literary object did not provide code snippets to
illustrate the points being made. While not necessary <span class='ec-lmri-10'>per se</span>, I argue that
if one establishes an interpretative framework related to the nature and
specificity of software, such a framework should be reflected in an examination of
one of the main components of software—source code. The way that this
gap has been productively addressed in recent years has primarily been
done through an understanding of code as a part of broader socio-technical
artifacts<span class='footnote-mark'><a href='#fn10x1' id='fn10x1-bk'><sup class='textsuperscript'>10</sup></a></span><a id='x1-6002f10'></a>,
inscribing it within the phenomenon of computation. This focus on the context in
which source code exists therefore leaves some room for similar approaches
with respect to its textual qualities. Despite N. Katherine Hayles’s call for
medium-specificity when engaging with code<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, it seems that there hasn’t yet
been close-readings of a variety of program texts in order to assess them as
specific aesthetic objects, in addition to their conceptual and socio-technical
qualities.
</p><!-- l. 201 --><p class='indent'>   Having established an overview of the state of the research on this topic,
and having identified some gaps remaining in this scholarship, we can now
                                                                  

                                                                  
clarify some of the problems resulting from those gaps with the following
questions.
</p><!-- l. 205 --><p class='indent'>   <span class='ec-lmri-10'>What does source code have to say about itself?</span>
</p><!-- l. 207 --><p class='indent'>   The relative absence of empirical examination of its source component when
discussing code does not seem to be consistent with a conception of source code as a
literary object. As methodologies for examining the meanings of source code have
recently flourished, the techniques of <span class='ec-lmri-10'>close-reading</span>, as focusing first and foremost on
"the words on the page"<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span> have been applied for extrinsic means: extract what the
lines of code have to say about the world, rather than what they have to
say about themselves, about their particular organization as source files, as
typographic objects or as symbol systems expressing concepts about the
computational entities they describe. In this sense, it is still unclear how the
possible combinations of control flow statements, function calls, function
definitions, datatypes, variable declaration and variable naming, among other
syntactic devices, enable program texts to be expressive. While close-reading
will be a useful heuristic for investigating these problems, it will also be
necessary to question the unicity of source code, and take into account how it
varies across writers and readers and the social groups they constitute. This
problem therefore has to be modulated with respect to the social environment
in which it exists—it will then be possible to highlight to what extent the
aesthetics of source code vary across these groups, and to what extent they
don’t.
</p><!-- l. 211 --><p class='indent'>   <span class='ec-lmri-10'>How does source code relate to other aesthetic fields?</span>
</p><!-- l. 213 --><p class='indent'>   Multiple aesthetic fields are being mapped onto source code, allowing us
to grasp such a novel object through more familiar lenses. However, the
question remains of what it is about the nature of source code which can act as
common ground for approaches as diverse as literature, mathematics and
architecture, or whether these references only touch on distinct aspects of
source code. When one talks about structure in source code, do they refer to
                                                                  

                                                                  
structure in an architectural sense, or in a literary sense? When one refers to
<span class='ec-lmri-10'>syntactic sugar </span>in a programming language, does this have implications in a
mathematical sense? This question will involve inquiries into the relationship of
syntax and structure, of formality and tacitness, of metaphor and conceptual
mapping, and in understanding of how adjectives such as <span class='ec-lmri-10'>clean</span>, <span class='ec-lmri-10'>clear </span>and
<span class='ec-lmri-10'>simple </span>might have similar meanings across those different fields. Offering
answers to these questions might allow us to move from a multi-faceted
understanding of source towards a more specific one, as the meeting point for all
these fields, source code might reveal deeper connections between each of
those.
</p><!-- l. 217 --><p class='indent'>   <span class='ec-lmri-10'>How do the aesthetics of source code relate to its functionality?</span>
</p><!-- l. 219 --><p class='indent'>   The final, and perhaps most important problem, concerns the status of aesthetics
in source code not as an end, but as a means. A cursory investigation on the topic
immediately reveals how aesthetics in source code can only be assessed only once the
intended functionality of the software described has been verified. This stands in the
way of a rather traditional opposition between beauty and functionality, and
therefore begs further exploration. How do aesthetics support source code’s
functional purpose? And are aesthetics limited to supporting such purpose, or do
they serve other purposes, beyond a strictly functional one? This paradox will relate
to our first problem, regarding the meaning-making affordances of source code,
and touch upon how the expressiveness of formal languages engage with
different conceptions of use and function, therefore relating back to Goodman’s
concept of the languages of art, of which programming languages can be part
of.
</p><!-- l. 221 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='methodology'><span class='titlemark'>1.3   </span> <a id='x1-70001.3'></a>Methodology</h3>
                                                                  

                                                                  
<!-- l. 223 --><p class='noindent'>To address such questions, we propose to proceed by looking at two kinds of texts:
program texts and meta-texts. The core of our corpus will consist of the two
categories, with additional texts and tools involved.
</p><!-- l. 225 --><p class='indent'>   Our primary corpus is source code, taken as <span class='ec-lmri-10'>program texts</span>. Due to the
intricate relationship between source code and digital communication networks,
vast amounts of source code are available online natively or have been
digitized<span class='footnote-mark'><a href='#fn11x1' id='fn11x1-bk'><sup class='textsuperscript'>11</sup></a></span><a id='x1-7001f11'></a>.
They range from a few lines to several thousands, date between 1969 and
2021, with a majority written by authors in Northern America or Western
Europe. On one side, code snippets are short, meaningful extracts usually
accompanied by a natural language comment in order to illustrate a
point. On the other, extensive code bases are large ensembles of source
files, often written in more than one language, and embedded in a build
system<span class='footnote-mark'><a href='#fn12x1' id='fn12x1-bk'><sup class='textsuperscript'>12</sup></a></span><a id='x1-7002f12'></a>.
Both can be written in a variety of programming languages, as long as these
languages are composed in alphanumeric characters.
</p><!-- l. 227 --><p class='indent'>   This lack of limitations on size, date or languages stems from our empirical
approach. Since we intend to assess code conditionally, that is, based primarily on its
own, intrinsic textual qualities, it would not follow that we should restrict to any
specific genre of program text. As we carry on this study, distinctions will nonetheless
arise in our corpus that align with some of the varieties amongst source—for instance,
the aesthetic properties of a program text composed of one line of code might be
different from those exhbited by a program text made up of thousands of lines
code.
</p><!-- l. 229 --><p class='indent'>   We also intend to use source code in both a deductive and an inductive manner.
Through our close-reading of program texts, we will highlight some aesthetic features
related to its textuality, taking existing source code as concrete proof of their
existence. Conversely, we will also write our own source code snippets in order to
illustrate the aesthetic features discussed in natural language. This use of
source code snippets is widely spread among communities of programmers in
order to qualify and strengthen their points in online discussions, and we
                                                                  

                                                                  
intend to follow this weaving in of machine language and natural language in
order to strengthen our argumentation. This approach will therefore oscillate
between theory and practice, the concrete and the abstract, as it both extracts
concepts from readings of source code and illustrates concepts by writing source
code.
</p><!-- l. 231 --><p class='indent'>   The case of programming languages is a particular one: they do not exclusively
constitute program texts (unless they are considered strictly in their implementation
details as lexers, interpreters and compilers, themselves described in program texts),
but are a necessary, if artificial, condition for the existence of source code. They
therefore have to be taken into account when assessing the aesthetic features of
program text, as integral part of the affordances of source code. Rather
than focusing on their context-free grammars or abstract notations, or on
their implementation details, we will focus on the syntax and semantics
that they allow the programmer to use. Still, programming languages are
hybrid artefacts, and their intrinsic qualities are only assessed insofar as
they relate to the aeshetic manifestations of source code written in those
languages.
</p><!-- l. 233 --><p class='indent'>   <span class='ec-lmri-10'>Meta-texts </span>on source code make up our secondary corpus. Meta-texts are written
by programmers, provide additional information, context and explanation for a given
extract of source code, and is a significant part of the software ecosystem. Even
though they are written in natural langauge, this ability to write comments has been
a core feature of any programming language very early on in the history of
computing, linking any program text with a potential commentary, whether directly
among the source code lines (<span class='ec-lmri-10'>inline commentary</span>) or in a separate block (<span class='ec-lmri-10'>external
</span><span class='ec-lmri-10'>commentary</span>)<span class='footnote-mark'><a href='#fn13x1' id='fn13x1-bk'><sup class='textsuperscript'>13</sup></a></span><a id='x1-7003f13'></a>.
Examples of external commentaries include user manuals, textbooks, documentation,
journal articles, forums posts, blog posts or emails. The inclusion in our corpus
of those meta-texts is due to two reasons: the practical reason of the high
epistemological barrier to entry when it comes to assessing source code in linguistic
or hardware environments which one isn’t familiar with, and the theoretical reason of
including the (aesthetic) judgment of programmers as it supports our conditional,
                                                                  

                                                                  
rather than constitutive, approach.
</p><!-- l. 235 --><p class='indent'>   While we intend to look at source through close-reading, favoring the role and
essence of each line as a meaningful, structural element, rather than that of the
whole, our interpretation of meta-texts will take place via discourse analysis. Building
on Dijk and Kintsch’s work on discourse comprehension<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, we intend to
approach these texts at a higher level, in terms of the lexical field they use,
as a marker of the aesthetic field they refer to, as well as at a lower level,
noting which specific syntactic aspects of the code they refer to. This focus
on both the micro-level (e.g. local coherence and proposition analysis) and
on the macro-level (e.g. socio-cultural context, intended aim and lexical
field usage) will allow us to link specific instances of written code with the
broader semantic field that they exist in. This connection between micro- and
macro- relies on the hypothesis that there is something fundamentally similar
between a source code construct, its meaning and use at the micro-level, and
the aesthetic field to which it is attached at a macro-level, a hypothesis
we will address further when investigating the role of metaphor in source
code.
</p><!-- l. 237 --><p class='indent'>   In the end, this process will allow us to construct a framework from empirical
observations. The last part of our methodology, after having completed this
analysis of program-texts and their commentaries, is to cross-reference it
with texts dealing with the manifestation of aesthetics in those peripheral
fields. Literary theory, centered around the works of I.A. Richards, Roland
Barthes and Paul Ricoeur can shed light on the attention to form, on the
interplay of syntax and semantics, of open and closed texts, and suggest
productive avenues through the context of metaphor. Architecture theory
will be involved through the two main approaches mentioned by software
developers: functionalism as illustrated by the credo <span class='ec-lmri-10'>form follows function</span>
and works by Vitruvius, Louis Sullivan and the Bauhaus on one side, and
pattern languages as initiated by the work of Christopher Alexander on
the other. The aesthetic nature of the two remaining fields, mathematics
and craft, have a thinner tradition of formalized aesthetics than literature
                                                                  

                                                                  
and architecture, but we nonetheless include essays and monographs from
practicioners in the field addressing those issues. This additional set of texts will
allow us to operate comparatively when it comes to expliciting source code’s
aesthetics.
</p><!-- l. 239 --><p class='indent'>   This study therefore aims at weaving in empirical observations, discourse analysis
and external framing, in order to propose systematic approaches to source code’s
textuality. However, these will not unfold in a strictly linear sequence; rather, there
will be a constant movement between practice and theory and between code-specific
aesthetic references and broader ones: this interdisciplinary approach intends to
reflect the multifaceted nature of software.
</p><!-- l. 241 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='roadmap'><span class='titlemark'>1.4   </span> <a id='x1-80001.4'></a>Roadmap</h3>
<!-- l. 243 --><p class='noindent'>Our first step in this study is an empirical assessment of how programmers consider
aesthetics with their practice or reading and writing it, first from a conceptual
standpoint. After acknowledging and underlining the diversity of those practices,
from software developers and scientists to artists and hackers, we will identify which
concepts and references are being used the most when referring to beautiful
code—concepts such as clarity, simplicity, cleanliness, and others. These concepts will
then allow us to touch upon the field that are being referred to when considering
the practice of programming: literature, architecture and mathematics as
domains in themselves, and craft as a particular approach to these domains.
Finally, we will how how the overlap of these concepts can be found in the
process of <span class='ec-lmri-10'>understanding</span>—communicating abstract ideas through concrete
manifestations.
</p><!-- l. 245 --><p class='indent'>   After establishing the role of aesthetics as a means for understanding source code,
we will proceed to analyze further such a relationship between understanding, source
code and aesthetics. We will see that one of the main features of source code is the
                                                                  

                                                                  
elusiveness of its meaning, whether effective or intended. Beautiful code is often code
that can be understood clearly, which raises the following question: how can a
completely explicit and formal language allow ambiguity? The answer to this
question will involve an analysis of the two audiences of source code: humans and
machines.
</p><!-- l. 247 --><p class='indent'>   Taking a step back towards textuality, we will then assess how the different fields
that are being referred to when talking about source code have touched upon these
issues of understanding, from rhetoric to literature, through architecture and
mathematics. Thinking in terms of surface-structure and deep-structure, we will
establish a first connection between program texts and literary text through their use
of metaphors. Since metaphors aren’t exclusively literary devices, looking at them
from a cognitive perspective will also raise issues of modes of knowledge, between
explicit, implicit and tacit. The understanding of beauty in architecture, based on the
two traditions mentioned above, will provide an additional perspective by providing
concepts of structure, function and usability. These will echo a final inquiry into
mathematical beauty, drawing a direct link between idea and implementation,
theorem and proof, and providing a deeper understanding of the concept of
<span class='ec-lmri-10'>elegance</span>.
</p><!-- l. 249 --><p class='indent'>   With a firmer grasp on the stakes of source code as an understandable text, we
can now turn to its effective manifestations, by close-reading program texts. Working
through <span class='ec-lmri-10'>structure</span>, <span class='ec-lmri-10'>syntax </span>and <span class='ec-lmri-10'>vocabulary</span>, we will be able to formalize a set of textual
typologies involved in producing an aesthetic experience through source code.
Particularly, we will highlight where those tokens differ across communities of
practice, and where they overlap, keeping in mind the conditionality of those
aesthetic judgments, and attempt to trace connections between specific textual
configurations of source code with the ideals summoned by the programmers. After
this deductive consideration, we will move on to apply these typologies to several
larger program texts—ranging from the LaTeX codebase, the Carnivore software
artwork to several code poems. These will highlight a remaining component in the
concrete manifestation of source code aesthetics: the place of programming
languages.
                                                                  

                                                                  
</p><!-- l. 251 --><p class='indent'>   At this point, we will have established aesthetics in source code as a way to
address the inherent tensions of a program text’s dual audience, computers and
humans. Being understandable by both humans and machines is indeed the feat of
programming languages, the symbol systems on which beautiful texts depend on. As
we’ve elicited the intricacies of aesthetic manifestations in human to machine
communication, we then investigate machine to machine communication.
Deconstructing programming languages as formal grammars will show that there are
very different conceptions of semantics and meanings expected from the computer
than those expected from a human, even though a machine’s perspective on beautiful
code could still be based around concepts of effectiveness, simplicity and
performance. <span class='ec-lmri-10'>Contra </span>those, human use of programming languages reaches into the
extreme of <span class='ec-lmri-10'>esolangs</span>—an investigation into those will reveal that language is effectively
considered as a material, one whose base elements can be recombined into
unexpected puzzling structures.
</p><!-- l. 253 --><p class='indent'>   Recognizing programming languages as the bridge between the two domains of
programming—the human of the machine—will allow us to clarify how the different
aesthetic fields (literature, architecture, mathematics) relate to programming. We
will show how programming languages provide a gradual interface between
different modes of being of source code: source code as text, source code as
structure and source code as theory. The need for aesthetics arises from
the tradeoffs that need to be made when these different modes of being
overlap<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.
</p><!-- l. 255 --><p class='indent'>   We will then turn back to our research questions to suggest some possible
answers. The reorganization of the source aesthetic fields inot a linear succession of
the interpration or compilation process from high-level to low-level hints at a
specifically spatial nature of program texts. Indeed, the specific aesthetics of source
code are those of a constant doubling between the specificities of the human (such as
natural handling of ambiguity, and intuitive understanding of the problem domain)
and of the machine (such as speed of execution, and reliance on explicit formal
grammars, which can also be seen as the tension between surface structure, one
that is textual and readable, and deep structure, one that is made up of
                                                                  

                                                                  
dynamic processes representing complex concepts, and yet devoid of any fluidity
or ambiguity. It is this dynamism, both in terms of <span class='ec-lmri-10'>where </span>and <span class='ec-lmri-10'>when </span>code
could be executed, which suggest the use of aesthetics in order to grasp more
intuitively the topology and chronology, the state and behaviour of a program
text.
</p><!-- l. 257 --><p class='indent'>   Finally, we will relate the approaches of Goodman of art as cognitively effective
symbol systems, and of Simondon’s consideration of aesthetic thought as a link
between technical thought and religious thought. Starting from a practical
perspective on aesthetics taking from the field of craft—the thing well done—,
aesthetics also highlight functionality on a cognitive level—the thing well thought.
Beauty in source code seems to be dominantly what is useful and thoughtful, even
when they are reflected in the distorting mirrors of hacks and esoteric languages,
broadening our possible understandings of what aesthetics can do, and what
functionality can be.
</p><!-- l. 259 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='implications-and-readership'><span class='titlemark'>1.5   </span> <a id='x1-90001.5'></a>Implications and readership</h3>
<!-- l. 261 --><p class='noindent'>This thesis fits within the field of software studies, and aims at clarifying what do we
mean when we refer to code <span class='ec-lmri-10'>code as…</span>. Code as literature, architecture or
mathematics, code as philosophy or as craft, are metaphors which can be examined
productively by looking at the texts themselves, an approach that has only been
deployed in relatively recent work.
</p><!-- l. 263 --><p class='indent'>   This relationship between practice, function and beauty is the broad, underlying
question of this study. In the vein of the cognitive approach to art and aesthetics, this
study is an attempt to show how aestethics play a communicative role, and how
concrete manifestations can, through a metaphorical process, hint at broader ideas.
In this sense, this study is not just about the relation of aesthetics and function,
but also about the function of aesthetics. While this idea of aesthetics as a
                                                                  

                                                                  
way of communicating ideas could be equally applied across artistic and
non-artistic domains, another aim of this thesis is to highlight the relativity a
aesthetic standards: using a similar medium, practices, uses and purposes
determine as much, if not more, of the artistic worth of a given program
text.
</p><!-- l. 265 --><p class='indent'>   By examining the result of the practice of programmers at a close-level, this study
hopes to contribute to a clarification of what exactly is programming, along with
the consequences of the embedding of software in our social, economic and
political practices. In order to address the question of whether algorithms are
political in themselves, or if their use is political, it is important to define
clearly what it is that we are talking about when discussing algorithms. A
clarification of source code on a concrete level attempts to help clarify what
this essential component of algorithms, and opens up potential for further
work in terms of thinking no longer of the aesthetics of source code, but of
its poetics, in the way source code, as a language of art, is also a way of
worldmaking.
</p><!-- l. 267 --><p class='indent'>   To this end, this thesis is aimed at a variety of readers and audience. From the
humanities perspective, digital humanists and literary theorists interested
in the concrete manifestations of source code as specific meaning-making
techniques will be able to find the first steps of such an approach being
laid out, and contrast these specific technique with the broader poetics of
code studied by other scholars, or with the aesthetics of natural language
texts.
</p><!-- l. 269 --><p class='indent'>   Programmers and computer scientists will find an attempt at formalizing
something they might have known implicitly ever since they started practicing
writing and reading code, and the approach of languages as poetics and
structure might help them think through these aspects in order to write
perhaps more aesthetically pleasing, and thus perhaps better, code. Conversely,
anyone engaged seriously in a craft activity could find here a rigorous study of
what goes on into a specific craft, asking how their own practice engages
with tools and modes of knowledge, and with a more explicit conception of
                                                                  

                                                                  
beauty.
</p><!-- l. 271 --><p class='indent'>   Finally, such a specific conception of beauty, then, will also be of interest to
artists and art theorists. By investing aesthetics without a direct relation to the
artwork, but rather within a functional purpose, this study suggests that one can
think through beauty and artworks not as ends, but as ways to accomplish things
that formal systems of explanation might not be able to achieve. An aesthetics of
source code would therefore aim at highlighting the purpose of instrumental beauty
within a textual environment.
</p>
   <div class='centerline'>                                             ______________                                             </div>
                                                                  

                                                                  
                                                                  

                                                                  
                                                                  

                                                                  
                                                                  

                                                                  
   <h2 class='chapterHead' id='aesthetic-ideals-in-programming-practices'><span class='titlemark'>Chapter 2</span><br /><a id='x1-100002'></a>Aesthetic ideals in programming practices</h2>
<!-- l. 3 --><p class='noindent'>The first step in our study of aesthetics in source code aims at identifying the
aesthetic ideals that programmers ascribe to source code; that is, the qualifiers and
semantic fields that they refer to when discussing program texts. To that end, we first
start by clarifying whom we refer to by the term <span class='ec-lmri-10'>programmers</span>, which reveals a
multiplicity of practices and purposes, from <span class='ec-lmri-10'>ad hoc</span>, one-line solutions, to printed code
and massively-distributed codebases.
</p><!-- l. 5 --><p class='indent'>   We then turn to the kinds of beauty that these programmers aspire to. After
expliciting our methodology of discourse analysis, we engage in a review of the
various kinds of publications and writings that programmers write, read and refer to
when it comes to qualifying their practice. From this will result a clust of
adjectives—e.g. <span class='ec-lmri-10'>clean</span>, <span class='ec-lmri-10'>simple</span>, <span class='ec-lmri-10'>smelly</span>—which we argue are used in an aesthetic sense.
These will provide a useful framework to inspect, in subsequent chapters, their formal
manifestations as typed-out tokens.
</p><!-- l. 7 --><p class='indent'>   From these, we can then move to a description of which aesthetic fields
are being referenced by programmers on a broader level, and consider how
multiple kinds of beauties, from literary, to architectural and mathematical
conceptions of beauty can overlap and be referred to by the same concrete
medium.
</p><!-- l. 9 --><p class='indent'>   Finally, we focus our attention on one of the points of overlap in these different
references: the importance of function, craft and knowledge in the disposition and
representation of code. We will show how this particular way of working plays a
central role in an aesthetic approach to source code and results from the specificity of
code as a cognitive material, a specificity we will inquire further in the next
chapter.
</p>
   <h3 class='sectionHead' id='the-practice-of-programmers-p'><span class='titlemark'>2.1   </span> <a id='x1-110002.1'></a>The practice of programmers - 20p</h3>
<!-- l. 13 --><p class='noindent'>The history of software development is that of a specific, reserved practice which was
born in the aftermath of the second world war, which trickled down to broader and
                                                                  

                                                                  
broader audiences at the eve of the twenty-first century. Through this development,
multiple ways of doing, approaches and applications have been involved in producing
software, resulting in different communities and types of programming. Each of these
focus on the description of specific instructions to the computer, but do so with
specific characteristics. To this end, we take a socio-historical stance on the field of
programming, highlighting how diverse practices emerge at different moments in
time, and how they are connected to contemporary technical and economic
organizations.
</p><!-- l. 15 --><p class='indent'>   Even though such types of reading and writing source code often overlap with one
another, this section will highlight a diversity of more or less loose ways in which
code is being written, notably in terms of references—what do they consider
good?—, purposes—what do they write for?—and examples—how does their
code look like?. First, we take a look at the software industry, to identify
professional <span class='ec-lmri-10'>software developers</span>, the large code bases they work on and the specific
organizational practices within which they write it. They are responsible for
the majority of source code written today, and do so in a professional and
productive context, where maintainability, testability and reliability are
the main concerns. Then, we turn to a parallel practice, one that is often
exhibited by software developers, as they also take on the stance of <span class='ec-lmri-10'>hackers</span>.
Disambiguating the term reveals a set of practices where curiosity, cleverness, and
idiosyncracy are central, finding unexpected solutions to complex problems,
sometimes within artificial constraints. Finally, we look at <span class='ec-lmri-10'>scientists </span>and <span class='ec-lmri-10'>poets</span>.
On one end, <span class='ec-lmri-10'>scientists </span>embody a rather academic approach, focusing on
abstract concepts such as simplicity, minimalism and elegance; they are often
focused on theoretical issues, such as implementation of algorithms and
mathematical models, as well as programming language design. On the other end,
<span class='ec-lmri-10'>poets </span>read and write code first and foremost for its textual and semantic
qualities, publishing code poems online and in print, and engaging deeply with
the range of metaphors allowed by a dynamic linguistic medium such as
code.
</p><!-- l. 17 --><p class='indent'>   While this overview encompasses most of the programming practices, we
                                                                  

                                                                  
leave aside some approaches to code, mainly because they do not directly
engage with the representation of source code as a textual matter. More and
more, end-user applications provide the possibility to program in more or less
rudimentary ways, something referred to as the "low-code" approach<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, and
thus contributing to the blurring of boundaries between programmers and
non-programmers<span class='footnote-mark'><a href='#fn1x2' id='fn1x2-bk'><sup class='textsuperscript'>1</sup></a></span><a id='x1-11001f1'></a>.
</p><!-- l. 19 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='software-developers'><span class='titlemark'>2.1.1   </span> <a id='x1-120002.1.1'></a>Software developers</h4>
<!-- l. 21 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead' id='from-local-hardware-to-distributed-software'><a id='x1-130002.1.1'></a>From local hardware to distributed software</h5>
<!-- l. 23 --><p class='noindent'>As Niklaus Wirth puts it, <span class='ec-lmri-10'>the history of software is the history of growth in
</span><span class='ec-lmri-10'>complexity</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, while paradoxically, lowering the barrier to entry. As computers’
technical abilities in memory managment and processing power increased year on
year since the 1950s, the nature of writing instructions shifted accordingly.
</p><!-- l. 25 --><p class='indent'>   In his history of the software industry, Martin Campbell-Kelly traces the
development of a discipline through both an economic and a technological lens, and
he identifies three consecutive waves in the production of software<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. During the first
period, as soon as the 1950s, and continuing throughout the 1960s, software developers
were contractors hired to engage directly with a specific computing machine. These
computing, mainframes, were large, expensive, and rigid machines, requiring
hardware-specific knowledge of the Assembler instruction set specific to each one,
since they didn’t feature an operating system which could facilitate some of the more
basic memory allocation and input/output functions, and thus interoperable
program-writing<span class='footnote-mark'><a href='#fn2x2' id='fn2x2-bk'><sup class='textsuperscript'>2</sup></a></span><a id='x1-13001f2'></a>.
Two distinct groups of people were involved in the operationalization of such
                                                                  

                                                                  
machine: electrical engineers, tasked with designing hardware, and programmers,
tasked with implementing the software. While the former historically received the
most attention<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, the latter was mostly composed of women and, as such, not
considered essential in the process<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. At this point, then, programming is closely tied
to hardware.
</p><!-- l. 27 --><p class='indent'>   The second period in software development starts in the 1960s, as hardware
started to switch from vacuum tubes to transistors and from magnetic core
memory to semiconductor memory, making them faster and more capable to
handle complex operations. On the software side, the development of several
programming languages, such as FORTRAN, LISP and COBOL, started to
address the double issue of portability—having a program run unmodified on
different machines with different instruction sets—and expressivity—allowing
programmers to use high-level, English-like syntax, rather than assembler instruction
codes. By then, programmers are no longer theoretically tied to a specific
machine, and therefore acquire a certain autonomy, a recognition which
culminates in the naming of the field of <span class='ec-lmri-10'>software engineering </span>in 1968 at a NATO
conference<span class='footnote-mark'><a href='#fn3x2' id='fn3x2-bk'><sup class='textsuperscript'>3</sup></a></span><a id='x1-13002f3'></a>.
</p><!-- l. 29 --><p class='indent'>   The third and final phase that Campbell-Kelly identifies is that of mass-market
production: following the advent of the UNIX family of operating systems,
the distribution of the C programming language, the wide availability of C
compilers, and the appearance of personal computers such as the Commodore 64,
Altair and Apple II, software could be effectively entirely decoupled from
hardware<span class='footnote-mark'><a href='#fn4x2' id='fn4x2-bk'><sup class='textsuperscript'>4</sup></a></span><a id='x1-13003f4'></a>.
And yet, software immediately enters a crisis, due to software development projects
running over time and budget, being unreliable in production and unmaintainable in
the long-run. What this highlighted is that the creation of software was no longer a
corollary to the design of hardware, and that it would become the main focus of
computing as a whole<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, and that it should therefore be addressed as such. It is at
this time that discussions around best practices in writing source code started to
emerge, once the activity of the programmer was no longer restricted to <span class='ec-lmri-10'>tricks by
</span><span class='ec-lmri-10'>means of which he contrived to squeeze the impossible into the constraints of his
                                                                  

                                                                  
</span><span class='ec-lmri-10'>equipment</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.
</p><!-- l. 31 --><p class='indent'>   This need for a more formal approach to the actual process of programming found
one of its most important manifestations in Edsger Djikstra’s <span class='ec-lmri-10'>Notes on Structured
</span><span class='ec-lmri-10'>Programming</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. In it, he argues for moving away from programming as a craft, and
towards programming as an organized discipline, with its methodologies
and systematization of program construction. Despite its laconic section
titles<span class='footnote-mark'><a href='#fn5x2' id='fn5x2-bk'><sup class='textsuperscript'>5</sup></a></span><a id='x1-13004f5'></a>,
Djikstra nonetheless contributed to establish a more rigorous typology of the
constructs required for reliable, provable programs—based on fundamentals such as
sequence, selection, iteration and recursion—, and aimed at the formalization of the
practice. Along with other developments (such as Hoare’s contribution on proper
data structuring<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, or the rise of object-oriented programming) programming would
solidify its foundations as a profession:
</p><!-- l. 33 --><p class='indent'>
     </p><blockquote class='quote'>
     <!-- l. 34 --><p class='noindent'>We  knew  how  the  nonprofessional  programmer  could  write  in
     an afternoon a three-page program that was supposed to satisfy
     his  needs,  but  how  would  the  professional  programmer  design  a
     thirty-page  program  in  such  a  way  that  he  could  really  justify
     his  design?  What  intellectual  discipline  would  be  needed?  What
     properties  could  such  a  professional  programmer  demand  with
     justification from his programming language, from the formal tool
     he had to work with? <span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span></p></blockquote>
<!-- l. 37 --><p class='indent'>   As a result of such interrogations comes an industry-wide search for solutions to
the intractable problem of programming: that it is <span class='ec-lmri-10'>a technique to manage
</span><span class='ec-lmri-10'>information which in turn produces information</span>. To address such a conundrum, a
variety of tools, formal methods and management processes enter the market;
they aim at acting as a <span class='ec-lmri-10'>silver bullet</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, addressing the cascade of potential
risks<span class='footnote-mark'><a href='#fn6x2' id='fn6x2-bk'><sup class='textsuperscript'>6</sup></a></span><a id='x1-13005f6'></a>
                                                                  

                                                                  
which emerge from large software applications. However, this growth in complexity is
also accompanied by a diversification of complexity: as computers become more
widely available, and as higher-level programming languages provide more flexibility
in their expressive abilities, software engineering is being applied to a variety of
domains, each of which might need a specific solution, rather than a generic process.
Confronted with this diversity of applications, business literature on software practices
flourishes<span class='footnote-mark'><a href='#fn7x2' id='fn7x2-bk'><sup class='textsuperscript'>7</sup></a></span><a id='x1-13006f7'></a>,
acknowledging that the complexity of software should be tackled at its bottleneck:
the reading and writing of source code.
</p><!-- l. 39 --><p class='indent'>   The most recent step in the history of software developers is the popularization of
the Internet and of the World Wide Web. Even though the former had existed under
as ArpaNet since 1969, the network was only standardized in 1982 and access to it
was provided commercially in 1989. Built on top of the Internet, the latter
popularized global information exchange, including technical resources to read and
write code. Software could now be written by remote individual written on <span class='ec-lmri-10'>cloud
</span><span class='ec-lmri-10'>computing </span>platforms, shared through public repositories and deployed via
containers with a lower barrier to entry than at the time of source code
printed in magazines, of overnight batch processing and of non-time-sharing
systems.
</p><!-- l. 43 --><p class='indent'>   These software developers have written some of the largest codebases
to this date, mainly because this type of activity represents the largest
fraction of programmers. Due to its close ties to commercial distributors,
however, source code written in this context often falls under the umbrella of
proprietary software, thus made unvailable to the public. Some examples that
we include in our corpus are either professional codebases that have been
leaked<span class='footnote-mark'><a href='#fn8x2' id='fn8x2-bk'><sup class='textsuperscript'>8</sup></a></span><a id='x1-13007f8'></a>,
open-source projects that have come out of business environments, such as
Soundcloud’s Prometheus, Google’s TensorFlow or Facebook’s React, or large-scale
open-source projects which nonetheless adhere to structured programming guidelines,
such as Donald Knuth’s TeX typesetting system or the Linux Foundation’s Linux
                                                                  

                                                                  
kernel.
</p><!-- l. 45 --><p class='noindent'>
</p>
   <h5 class='subsubsectionHead' id='features-of-the-field'><a id='x1-140002.1.1'></a>Features of the field</h5>
<!-- l. 47 --><p class='noindent'>The features of these codebases provide the backdrop to, and start to hint at, the
qualities that software developers have come to ascribe to their object of practice.
First, the program texts they write are large, much larger than any other codebase
included in this study, they often feature multiple programming languages and are
highly structured and standardized: each file follows a pre-established convention in
programming style, which favors an authoring by multiple programmers without any
obvious trace to a single individual authorship. These program texts stand the closest
to a programming equivalent of engineering, with its formalisms, standards and
usability. From this perspective, the IEEE’s Software Engineering Body of Knoweldge
(SWEBOK) provides a good starting point to survey the specificities of
software developers as source code writers and readers<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>; the main features of
which include the definition of requirements, design, construction testing and
maintenance.
</p><!-- l. 49 --><p class='indent'>   Software requirements are the acknowledgement of the importance of the <span class='ec-lmri-10'>problem
</span><span class='ec-lmri-10'>domain</span>, the domain to which the software takes its inputs from, and to which it
applies its outputs. For instance, software written for a calculator has arithmetic as
its problem domain; software written for a learning management system has
students, faculty, education and courses as its problem domain; software written
a banking institution has financial transactions, savings accounts, fraud
prevention and credit lines as its problem domain. Requirements in software
development aim at formalizing as best as possible the elements that must be
used by the software in order to perform a successful computation, and an
adequate formalization is a fundamental requirement for a successful software
application.
</p><!-- l. 51 --><p class='indent'>   Following the identification and codification of requirements, software design
                                                                  

                                                                  
relates to the overall organization of the software components, considered not in their
textual implementation, but in their conceptual agency. Usually represented
through diagrams or modelling languages, it is concerned with <span class='ec-lmri-10'>understanding
</span><span class='ec-lmri-10'>how a system should be organized and designing the overall structure of that
</span><span class='ec-lmri-10'>system</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. Of particular interest is the relationship that is established between
software development and architecture. Considered a creative process rather
than a strictly rational one, due to the important role of the contexts in
which the software will exist (including the problem domain)<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, software
architecture is considered essential from a top-down perspective, laying down an
abstract blueprint for the implementation of a system, as well as form a
bottom-up one, representing how the different components of an existing system
interact. This apparent contradiction, and the role of architecture in the
creative aspects of software development, will be further explored in chapter
2.
</p><!-- l. 54 --><p class='indent'>   Software construction relates to the actual writing of software, and how to do so in the
most reliable way possible. The SWEBOK emphasizes first and foremost the need to minimize
complexity<span class='footnote-mark'><a href='#fn9x2' id='fn9x2-bk'><sup class='textsuperscript'>9</sup></a></span><a id='x1-14001f9'></a>,
in anticipation of likely changes and possible reuse by other software systems. Here, the
emphasis on engineering is particularly salient: while most would refer to the creation
of software as <span class='ec-lmri-10'>writing </span>software, the IEEE document refers to it as <span class='ec-lmri-10'>constructing</span>
software<span class='footnote-mark'><a href='#fn10x2' id='fn10x2-bk'><sup class='textsuperscript'>10</sup></a></span><a id='x1-14002f10'></a>.
Coding is only assessed as a practical consideration, one which should not take up
the most attention, if the requirements, design and testing steps are satisfyingly
implemented. Conversely, a whole field of business litterature<span class='cite'>[<span class='ec-lmbx-10'>?</span>, <span class='ec-lmbx-10'>?</span>, <span class='ec-lmbx-10'>?</span>, <span class='ec-lmbx-10'>?</span>]</span> has focused
specifically on the process of writing code, starting from the assumption
that:
</p><!-- l. 56 --><p class='indent'>
     </p><blockquote class='quote'>
     <!-- l. 57 --><p class='noindent'>We will never be rid of code, because code represents the details of
                                                                  

                                                                  
     the requirements. At some level those details cannot be ignored or
     abstracted; they have to be specified. And specifying requirements
     in such details that a machine can execute them is <span class='ec-lmri-10'>programming</span>.<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span></p></blockquote>
<!-- l. 60 --><p class='indent'>   As we see, the tension identified by Djikstra some thirty years before between
craft and discipline is still alive and well at the beginning of the twenty-first century,
even though the focus on code still relates to the need for reliability and
maintainability in a maturing industry.
</p><!-- l. 62 --><p class='indent'>   Software maintenance, finally, relates not to the planning or writing
of software, but to its reading. Software is notoriously filled with
bugs<span class='footnote-mark'><a href='#fn11x2' id='fn11x2-bk'><sup class='textsuperscript'>11</sup></a></span><a id='x1-14003f11'></a>
and can, at the same time, be easily fixed while already being in a production
environment through software update releases. This means that the lifecycle of a
software doesn’t stop when then first version is written, but rather when it does not
run anymore, and this implies that the nature of software allows for it to
be edited across time and space, by other programmers which might not
have access to the original group of implementers: consequently, software
should be first and foremost understandable—SWEBOK lists the first feature
of coding as being <span class='ec-lmri-10'>techniques for creating understandable source code</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.
This requirement ties back to one of the main problems of software, which
is its notorious cognitive complexity, one that remains at any stage of its
development.
</p><!-- l. 66 --><p class='indent'>   What does this look like in practice, then? Ideals of clarity, reusability and
reliability—and their opposites—can be found in some of the available code bases of
professional software. The paradox to be noted here is that, even though software
developers write the most code, it is the least accessible online and, as such, the
following excerpts are covering the range of commercial software (Microsoft
Windows), licensed and publicly available software (Kirby), and an open-source
software (Prometheus).
</p><!-- l. 68 --><p class='indent'>   The first excerpts come from the source code for Microsoft Windows 2000, which
                                                                  

                                                                  
was made public in 2004. The program text contains 28,655 files, the largest of our
corpus, by multiple orders of magnitude, with 13,468,327 combined lines and
including more than 10 different file extensions. Taking a closer look at some of these
files allow us to identify some of the specific features of code written by software
developers, and how they specifically relate to architectural choices, collaborative
writing and verbosity.
</p><!-- l. 70 --><p class='indent'>   First, the most striking visual feature of the code is its sheer size. Representing
such a versatile and low-level system such as an operating system manifest
themselves in files that are often above 2000 lines of code. In order to allow
abstraction techniques at a higher-level for the end-developer, the operating system
needs to do a significant amount of "grunt" work, relating directly to the concrete
reality of the hardware platform which needs to be operated. For instance, the
initialization of strings of text for the namespaces (a technique directly related to the
compartmentalization) is necessary, repetitive work which can be represented using a
rhythmic visual pattern, such as in <span class='lstinline'><span class='ec-lmtt-8'>cmdatini.c</span></span>:
</p>
   <!-- l. 72 -->
<div class='lstlisting' id='listing-4'><span class='label'><a id='x1-14004r1'></a></span><span class='ec-lmtt-8x-x-62'>  { </span><br /> 
<span class='label'><a id='x1-14005r2'></a></span><span class='ec-lmtt-8x-x-62'>     ULONG i; </span><br /> 
<span class='label'><a id='x1-14006r3'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14007r4'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryRootName, </span><br /> 
<span class='label'><a id='x1-14008r5'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryRootString ); </span><br /> 
<span class='label'><a id='x1-14009r6'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14010r7'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineName, </span><br /> 
<span class='label'><a id='x1-14011r8'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineString ); </span><br /> 
<span class='label'><a id='x1-14012r9'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14013r10'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineHardwareName, </span><br /> 
<span class='label'><a id='x1-14014r11'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineHardwareString ); </span><br /> 
<span class='label'><a id='x1-14015r12'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14016r13'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineHardwareDescriptionName, </span><br /> 
<span class='label'><a id='x1-14017r14'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineHardwareDescriptionString ); </span><br /> 
<span class='label'><a id='x1-14018r15'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14019r16'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineHardwareDescriptionSystemName, </span><br /> 
<span class='label'><a id='x1-14020r17'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineHardwareDescriptionSystemString ); </span><br /> 
<span class='label'><a id='x1-14021r18'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14022r19'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineHardwareDeviceMapName, </span><br /> 
<span class='label'><a id='x1-14023r20'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineHardwareDeviceMapString ); </span><br /> 
<span class='label'><a id='x1-14024r21'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14025r22'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineHardwareResourceMapName, </span><br /> 
<span class='label'><a id='x1-14026r23'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineHardwareResourceMapString ); </span><br /> 
<span class='label'><a id='x1-14027r24'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14028r25'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineHardwareOwnerMapName, </span><br /> 
<span class='label'><a id='x1-14029r26'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineHardwareOwnerMapString ); </span><br /> 
<span class='label'><a id='x1-14030r27'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14031r28'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineSystemName, </span><br /> 
<span class='label'><a id='x1-14032r29'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineSystemString ); </span><br /> 
<span class='label'><a id='x1-14033r30'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14034r31'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineSystemCurrentControlSet, </span><br /> 
<span class='label'><a id='x1-14035r32'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineSystemCurrentControlSetString); </span><br /> 
<span class='label'><a id='x1-14036r33'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14037r34'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryUserName, </span><br /> 
<span class='label'><a id='x1-14038r35'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryUserString ); </span><br /> 
<span class='label'><a id='x1-14039r36'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14040r37'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistrySystemCloneName, </span><br /> 
<span class='label'><a id='x1-14041r38'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistrySystemCloneString ); </span><br /> 
<span class='label'><a id='x1-14042r39'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14043r40'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmpSystemFileName, </span><br /> 
<span class='label'><a id='x1-14044r41'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistrySystemFileNameString ); </span><br /> 
<span class='label'><a id='x1-14045r42'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14046r43'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineSystemCurrentControlSetEnumName, </span><br /> 
<span class='label'><a id='x1-14047r44'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineSystemCurrentControlSetEnumString); </span><br /> 
<span class='label'><a id='x1-14048r45'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14049r46'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineSystemCurrentControlSetEnumRootName, </span><br /> 
<span class='label'><a id='x1-14050r47'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineSystemCurrentControlSetEnumRootString); </span><br /> 
<span class='label'><a id='x1-14051r48'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14052r49'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineSystemCurrentControlSetServices, </span><br /> 
<span class='label'><a id='x1-14053r50'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineSystemCurrentControlSetServicesString); </span><br /> 
<span class='label'><a id='x1-14054r51'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14055r52'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineSystemCurrentControlSetHardwareProfilesCurrent, </span><br /> 
<span class='label'><a id='x1-14056r53'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineSystemCurrentControlSetHardwareProfilesCurrentString); </span><br /> 
<span class='label'><a id='x1-14057r54'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14058r55'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineSystemCurrentControlSetControlClass, </span><br /> 
<span class='label'><a id='x1-14059r56'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineSystemCurrentControlSetControlClassString); </span><br /> 
<span class='label'><a id='x1-14060r57'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14061r58'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineSystemCurrentControlSetControlSafeBoot, </span><br /> 
<span class='label'><a id='x1-14062r59'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineSystemCurrentControlSetControlSafeBootString); </span><br /> 
<span class='label'><a id='x1-14063r60'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14064r61'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineSystemCurrentControlSetControlSessionManagerMemoryManagement, </span><br /> 
<span class='label'><a id='x1-14065r62'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineSystemCurrentControlSetControlSessionManagerMemoryManagementString); </span><br /> 
<span class='label'><a id='x1-14066r63'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14067r64'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineSystemCurrentControlSetControlBootLog, </span><br /> 
<span class='label'><a id='x1-14068r65'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineSystemCurrentControlSetControlBootLogString); </span><br /> 
<span class='label'><a id='x1-14069r66'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14070r67'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineSystemCurrentControlSetServicesEventLog, </span><br /> 
<span class='label'><a id='x1-14071r68'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineSystemCurrentControlSetServicesEventLogString); </span><br /> 
<span class='label'><a id='x1-14072r69'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14073r70'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmSymbolicLinkValueName, </span><br /> 
<span class='label'><a id='x1-14074r71'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpSymbolicLinkValueName); </span><br /> 
<span class='label'><a id='x1-14075r72'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14076r73'></a></span><span class='ec-lmtk-10x-x-50'>#ifdef</span><span class='ec-lmtt-8x-x-62'> _WANT_MACHINE_IDENTIFICATION </span><br /> 
<span class='label'><a id='x1-14077r74'></a></span><span class='ec-lmtt-8x-x-62'>     RtlInitUnicodeString( &amp;CmRegistryMachineSystemCurrentControlSetControlBiosInfo, </span><br /> 
<span class='label'><a id='x1-14078r75'></a></span><span class='ec-lmtt-8x-x-62'>                                 CmpRegistryMachineSystemCurrentControlSetControlBiosInfoString); </span><br /> 
<span class='label'><a id='x1-14079r76'></a></span><span class='ec-lmtk-10x-x-50'>#endif</span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14080r77'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14081r78'></a></span><span class='ec-lmtti-10x-x-50'>     //</span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14082r79'></a></span><span class='ec-lmtti-10x-x-50'>     // Initialize the type names for the hardware tree.</span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14083r80'></a></span><span class='ec-lmtti-10x-x-50'>     //</span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14084r81'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14085r82'></a></span><span class='ec-lmtt-8x-x-62'>     </span><span class='ec-lmtk-10x-x-50'>for</span><span class='ec-lmtt-8x-x-62'> (i = 0; i &lt;= MaximumType; i++) { </span><br /> 
<span class='label'><a id='x1-14086r83'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14087r84'></a></span><span class='ec-lmtt-8x-x-62'>          RtlInitUnicodeString( &amp;(CmTypeName[i]), </span><br /> 
<span class='label'><a id='x1-14088r85'></a></span><span class='ec-lmtt-8x-x-62'>                                      CmTypeString[i] ); </span><br /> 
<span class='label'><a id='x1-14089r86'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14090r87'></a></span><span class='ec-lmtt-8x-x-62'>     } </span><br /> 
<span class='label'><a id='x1-14091r88'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14092r89'></a></span><span class='ec-lmtti-10x-x-50'>     //</span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14093r90'></a></span><span class='ec-lmtti-10x-x-50'>     // Initialize the class names for the hardware tree.</span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14094r91'></a></span><span class='ec-lmtti-10x-x-50'>     //</span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14095r92'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14096r93'></a></span><span class='ec-lmtt-8x-x-62'>     </span><span class='ec-lmtk-10x-x-50'>for</span><span class='ec-lmtt-8x-x-62'> (i = 0; i &lt;= MaximumClass; i++) { </span><br /> 
<span class='label'><a id='x1-14097r94'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14098r95'></a></span><span class='ec-lmtt-8x-x-62'>          RtlInitUnicodeString( &amp;(CmClassName[i]), </span><br /> 
<span class='label'><a id='x1-14099r96'></a></span><span class='ec-lmtt-8x-x-62'>                                      CmClassString[i] ); </span><br /> 
<span class='label'><a id='x1-14100r97'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14101r98'></a></span><span class='ec-lmtt-8x-x-62'>     } </span><br /> 
<span class='label'><a id='x1-14102r99'></a></span><span class='ec-lmtt-8x-x-62'> </span><br /> 
<span class='label'><a id='x1-14103r100'></a></span><span class='ec-lmtt-8x-x-62'>     </span><span class='ec-lmtk-10x-x-50'>return</span><span class='ec-lmtt-8x-x-62'>; </span><br /> 
<span class='label'><a id='x1-14104r101'></a></span><span class='ec-lmtt-8x-x-62'>}</span></div>
<!-- l. 176 --><p class='indent'>   The repetition of the <span class='lstinline'><span class='ec-lmtt-8'>RtlInitUnicodeString</span></span> call in the first part of this listing
stands at odds with today’s industry-standard practices of not repeating
oneself; these would rather point towards the second part of the code, the two
<span class='lstinline'><span class='ec-lmtt-8'>for()</span></span> statements. While this practice would only be formalized in Andy
Hunt’s <span class='ec-lmri-10'>The Pragmatic Programmer </span>in 1999<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, the longevity of the windows
2000 operating system and its update cycle would nonetheless have affected
how this code is written. The reason why such a repetition applies is the
requirement of registering each string with the kernel. Dealing with a different
problem domain (kernel instructions) leads to a different kind of expected
aesthetics<span class='footnote-mark'><a href='#fn12x2' id='fn12x2-bk'><sup class='textsuperscript'>12</sup></a></span><a id='x1-14105f12'></a>.
</p><!-- l. 178 --><p class='indent'>   Verbosity, the act of explicitly writing out statements which could be functionally
                                                                  

                                                                  
equivalent in a compacted form, is a significant feature of the Windows 2000
codebase, and also relies on a particular semantic environment: that of using the C
programming language. As mentioned above, the development of C and
UNIX in the 1970s have led to wide adoption of the former, and to some
extent of the later (even though Windows is a notable exception since it is an
operation system not based on the UNIX tradition). What we see in this
listing is the consequence of this development: using a verbose language
inevitably leads to a verbose program text, something we will see in the
following section on hacker’s code and will explore much further in chapter
5.
</p><!-- l. 180 --><p class='indent'>   Another significant aesthetic feature of the Windows 2000 program text is its use
of comments, and specifically how those comments representing the multiple,
layered authorship. This particular source code is one that is written across
individuals and across time, each with presumably its own writing style.
Yet, writing source code within a formal organization leads to the adoption
of coding styles, with the intent that <span class='ec-lmri-10'>all code in any code-base should look
</span><span class='ec-lmri-10'>like a single person typed it, no matter how many people contributed</span><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. For
instance, the following excerpt from <span class='lstinline'><span class='ec-lmtt-8'>jdhuff.c</span></span> is a example of such overlapping of
styles:
</p>
   <!-- l. 182 -->
                                                                  

                                                                  
<!-- l. 182 --><p class='indent'>   </p><figure class='float' id='-bufferc'>
                                                                  

                                                                  
<a id='x1-14106r1'></a>
<a id='x1-14107'></a>
<div class='lstlisting' id='listing-5'><span class='label'><a id='x1-14108r1'></a></span><span class='ec-lmtt-8'>  no_more_data: </span><br /> 
<span class='label'><a id='x1-14109r2'></a></span><span class='ec-lmtt-8'>                  // There should be enough bits still left in the data segment; </span><br /> 
<span class='label'><a id='x1-14110r3'></a></span><span class='ec-lmtt-8'>                  // if so, just break out of the outer while loop. </span><br /> 
<span class='label'><a id='x1-14111r4'></a></span><span class='ec-lmtt-8'>                  if (bits_left &gt;= nbits) </span><br /> 
<span class='label'><a id='x1-14112r5'></a></span><span class='ec-lmtt-8'>                          break; </span><br /> 
<span class='label'><a id='x1-14113r6'></a></span><span class='ec-lmtt-8'>                        /* Uh-oh.  Report corrupted data to user and stuff zeroes into </span><br /> 
<span class='label'><a id='x1-14114r7'></a></span><span class='ec-lmtt-8'>                         * the data stream, so that we can produce some kind of image. </span><br /> 
<span class='label'><a id='x1-14115r8'></a></span><span class='ec-lmtt-8'>                         * Note that this code will be repeated for each byte demanded </span><br /> 
<span class='label'><a id='x1-14116r9'></a></span><span class='ec-lmtt-8'>                         * for the rest of the segment.  We use a nonvolatile flag to ensure </span><br /> 
<span class='label'><a id='x1-14117r10'></a></span><span class='ec-lmtt-8'>                         * that only one warning message appears. </span><br /> 
<span class='label'><a id='x1-14118r11'></a></span><span class='ec-lmtt-8'>                         */ </span><br /> 
<span class='label'><a id='x1-14119r12'></a></span><span class='ec-lmtt-8'>                  if (! *(state-&gt;printed_eod_ptr)) </span><br /> 
<span class='label'><a id='x1-14120r13'></a></span><span class='ec-lmtt-8'>                  { </span><br /> 
<span class='label'><a id='x1-14121r14'></a></span><span class='ec-lmtt-8'>                          WARNMS(state-&gt;cinfo, JWRN_HIT_MARKER); </span><br /> 
<span class='label'><a id='x1-14122r15'></a></span><span class='ec-lmtt-8'>                          *(state-&gt;printed_eod_ptr) = TRUE; </span><br /> 
<span class='label'><a id='x1-14123r16'></a></span><span class='ec-lmtt-8'>                  } </span><br /> 
<span class='label'><a id='x1-14124r17'></a></span><span class='ec-lmtt-8'>                  c = 0;                  // insert a zero byte into bit buffer </span><br /> 
<span class='label'><a id='x1-14125r18'></a></span><span class='ec-lmtt-8'>      } </span><br /> 
<span class='label'><a id='x1-14126r19'></a></span><span class='ec-lmtt-8'>    } </span><br /> 
<span class='label'><a id='x1-14127r20'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-14128r21'></a></span><span class='ec-lmtt-8'>    /* OK, load c into get_buffer */ </span><br /> 
<span class='label'><a id='x1-14129r22'></a></span><span class='ec-lmtt-8'>    get_buffer = (get_buffer &lt;&lt; 8) | c; </span><br /> 
<span class='label'><a id='x1-14130r23'></a></span><span class='ec-lmtt-8'>    bits_left += 8; </span><br /> 
<span class='label'><a id='x1-14131r24'></a></span><span class='ec-lmtt-8'>  } </span><br /> 
<span class='label'><a id='x1-14132r25'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-14133r26'></a></span><span class='ec-lmtt-8'>  /* Unload the local registers */ </span><br /> 
<span class='label'><a id='x1-14134r27'></a></span><span class='ec-lmtt-8'>  state-&gt;next_input_byte = next_input_byte; </span><br /> 
<span class='label'><a id='x1-14135r28'></a></span><span class='ec-lmtt-8'>  state-&gt;bytes_in_buffer = bytes_in_buffer; </span><br /> 
<span class='label'><a id='x1-14136r29'></a></span><span class='ec-lmtt-8'>  state-&gt;get_buffer = get_buffer; </span><br /> 
<span class='label'><a id='x1-14137r30'></a></span><span class='ec-lmtt-8'>  state-&gt;bits_left = bits_left; </span><br /> 
<span class='label'><a id='x1-14138r31'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-14139r32'></a></span><span class='ec-lmtt-8'>  return TRUE; </span><br /> 
<span class='label'><a id='x1-14140r33'></a></span><span class='ec-lmtt-8'>}</span></div>
<figcaption class='caption'><span class='id'>Listing 2.1:</span><span class='content'>buffer.c</span></figcaption><!-- tex4ht:label?: x1-14106r2.1  -->
                                                                  

                                                                  
   </figure>
<!-- l. 218 --><p class='indent'>   Here, we see three different writings of comments <span class='lstinline'><span class='ec-lmtt-8'>//</span></span>, <span class='lstinline'><span class='ec-lmtt-8'>/* */</span></span> as well as different
kinds of capitalizations. Those comments are ignored at compile time: that is, they
are not meaningful to the machine, and are only expected to be read by other
programmers, primarily programmers belonging to one’s organization. This hints at
the various origins of the authors, or at the very least at the different moments,
and possible mental states of the potential single-author: irregularity in
comment writing can connect to irregularities in semantic content of the
comments. This irregularity becomes suspicious, and leads to ascribing a
different epistemological value to them. If comments aren’t procedurally
guaranteed to be reflected in the execution, and outcome, of the program,
then one tend to rely on the fact that “The only document that describes
your code completely and correctly is the code itself” (<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>). This excerpt
highlights the constant tension between source code as the canonical origin of
knowledge of what the program does and how it does it, while comments refelect
the idiosyncratic dimension of all natural-language expressions of human
programmers.
</p><!-- l. 220 --><p class='indent'>   And yet, this chronological and interpersonal spread of the program text, as well
as organizational practices require the use of comments in order to maintain aesthetic
and cognitive coherence in the program, if only by the use of comment headers, which
locate a specific file within the greater architectural organization of the program text.
For instance, in <span class='lstinline'><span class='ec-lmtt-8'>pnpenum.c</span></span>:
</p>
   <!-- l. 222 -->
                                                                  

                                                                  
<!-- l. 222 --><p class='indent'>   </p><figure class='float' id='-enumc'>
                                                                  

                                                                  
<a id='x1-14141r2'></a>
<a id='x1-14142'></a>
<div class='lstlisting' id='listing-6'><span class='label'><a id='x1-14143r1'></a></span><span class='ec-lmtt-8'>  /*++ </span><br /> 
<span class='label'><a id='x1-14144r2'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-14145r3'></a></span><span class='ec-lmtt-8'>Copyright (c) 1996 Microsoft Corporation </span><br /> 
<span class='label'><a id='x1-14146r4'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-14147r5'></a></span><span class='ec-lmtt-8'>Module Name: </span><br /> 
<span class='label'><a id='x1-14148r6'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-14149r7'></a></span><span class='ec-lmtt-8'>    enum.c </span><br /> 
<span class='label'><a id='x1-14150r8'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-14151r9'></a></span><span class='ec-lmtt-8'>Abstract: </span><br /> 
<span class='label'><a id='x1-14152r10'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-14153r11'></a></span><span class='ec-lmtt-8'>    This module contains routines to perform device enumeration </span><br /> 
<span class='label'><a id='x1-14154r12'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-14155r13'></a></span><span class='ec-lmtt-8'>Author: </span><br /> 
<span class='label'><a id='x1-14156r14'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-14157r15'></a></span><span class='ec-lmtt-8'>    Shie-Lin Tzong (shielint) Sept. 5, 1996. </span><br /> 
<span class='label'><a id='x1-14158r16'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-14159r17'></a></span><span class='ec-lmtt-8'>Revision History: </span><br /> 
<span class='label'><a id='x1-14160r18'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-14161r19'></a></span><span class='ec-lmtt-8'>    James Cavalaris (t-jcaval) July 29, 1997. </span><br /> 
<span class='label'><a id='x1-14162r20'></a></span><span class='ec-lmtt-8'>    Added IopProcessCriticalDeviceRoutine. </span><br /> 
<span class='label'><a id='x1-14163r21'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-14164r22'></a></span><span class='ec-lmtt-8'>--*/</span></div>
<figcaption class='caption'><span class='id'>Listing 2.2:</span><span class='content'>enum.c</span></figcaption><!-- tex4ht:label?: x1-14141r2.1  -->
                                                                  

                                                                  
   </figure>
<!-- l. 247 --><p class='indent'>   This highlights both the multiple authorship (here, we have one original author
and one revisor) as well as the evolution in time of the file: comments are the only
manifestation of this layering of revisions which ultimately results in the "final"
software<span class='footnote-mark'><a href='#fn13x2' id='fn13x2-bk'><sup class='textsuperscript'>13</sup></a></span><a id='x1-14165f13'></a>.
</p><!-- l. 249 --><p class='indent'>   A complementary example is the Kirby
CMS<span class='footnote-mark'><a href='#fn14x2' id='fn14x2-bk'><sup class='textsuperscript'>14</sup></a></span><a id='x1-14166f14'></a>.
With development starting in 2011, a first release in 2012 and
having developed a steady userbase, correlated in Google Trends
analytics<span class='footnote-mark'><a href='#fn15x2' id='fn15x2-bk'><sup class='textsuperscript'>15</sup></a></span><a id='x1-14167f15'></a>, consistent
forum posts<span class='footnote-mark'><a href='#fn16x2' id='fn16x2-bk'><sup class='textsuperscript'>16</sup></a></span><a id='x1-14168f16'></a> and
commit history<span class='footnote-mark'><a href='#fn17x2' id='fn17x2-bk'><sup class='textsuperscript'>17</sup></a></span><a id='x1-14169f17'></a>,
it exhibits a particular set of features, in both its purpose and its source code alike.
Kirby is an open-source, developer-first (meaning that it affords direct engagement of
other developers with its architecture through modification, extension or
partial replacement), single-purpose project. As such, it stands at the other
end of the commercial, efficient software spectrum than Microsoft Windows
2000.
</p><!-- l. 251 --><p class='indent'>   The Kirby source code is entirely available online, and the following snippets hint
at another set of formal values—conciseness, expliciteness and delimitation.
Conciseness can be seen in the lengths of the various components of the
code base. For instance, the core of Kirby consists in 248 files, with the
longest being <span class='lstinline'><span class='ec-lmtt-8'>src/Database/Query.php</span></span> at 1065 lines, and the shortest being
<span class='lstinline'><span class='ec-lmtt-8'>src/Http/Exceptions/NextRouteException.php</span></span>, for an average of 250 lines per
file. At the third level, the length of the function bodies is also minimal,
ranging from XXXX to XXXX<span class='ec-lmri-10'>calculate</span>. Compared to the leading project
in the field, Wordpress.org, which has respectively XXXX <span class='ec-lmri-10'>insert analysis
</span><span class='ec-lmri-10'>here</span>.
</p><!-- l. 253 --><p class='indent'>   If we look at a typical function declaration within Kirby, we found one such as the
distinct setter for Kirby’s database:
</p>
                                                                  

                                                                  
   <!-- l. 255 -->
                                                                  

                                                                  
<!-- l. 255 --><p class='indent'>   </p><figure class='float' id='-queryphp'>
                                                                  

                                                                  
<a id='x1-14170r3'></a>
<a id='x1-14171'></a>
<div class='lstlisting' id='listing-7'><span class='label'><a id='x1-14172r1'></a></span><span class='ec-lmtt-8'>  /** </span><br /> 
<span class='label'><a id='x1-14173r2'></a></span><span class='ec-lmtt-8'>  * Enables distinct select clauses. </span><br /> 
<span class='label'><a id='x1-14174r3'></a></span><span class='ec-lmtt-8'>  * </span><br /> 
<span class='label'><a id='x1-14175r4'></a></span><span class='ec-lmtt-8'>  * @param bool $distinct </span><br /> 
<span class='label'><a id='x1-14176r5'></a></span><span class='ec-lmtt-8'>  * @return \Kirby\Database\Query </span><br /> 
<span class='label'><a id='x1-14177r6'></a></span><span class='ec-lmtt-8'>  */ </span><br /> 
<span class='label'><a id='x1-14178r7'></a></span><span class='ec-lmtt-8'> public function distinct(bool $distinct = true) </span><br /> 
<span class='label'><a id='x1-14179r8'></a></span><span class='ec-lmtt-8'> { </span><br /> 
<span class='label'><a id='x1-14180r9'></a></span><span class='ec-lmtt-8'>     $this-&gt;distinct = $distinct; </span><br /> 
<span class='label'><a id='x1-14181r10'></a></span><span class='ec-lmtt-8'>     return $this; </span><br /> 
<span class='label'><a id='x1-14182r11'></a></span><span class='ec-lmtt-8'> }</span></div>
<figcaption class='caption'><span class='id'>Listing 2.3:</span><span class='content'>Query.php</span></figcaption><!-- tex4ht:label?: x1-14170r2.1  -->
                                                                  

                                                                  
   </figure>
<!-- l. 269 --><p class='indent'>   Out of these 11 lines, the actual functionality of the function is focused on one
line, <span class='lstinline'><span class='ec-lmtt-8'>$this-&gt;distinct = $distinct;</span></span>. Around it are machine-readable comment snippets,
and a function wrapper around the simple variable setting. The textual overhead
then comes from the wrapping itself: the actual semantic task of deciding whether a
query should be able to include distinct select clauses (as opposed to only allowing
join clauses), is now decoupled from its actual implementation (one could describe to
the computer such an ability to generate distinct clauses by assigning it a boolean
value, or an integer value, or passing it as an argument for each query, etc.). The
quality of this writing, at first verbose, actually lies in its conciseness in
relation to the possibilities for extension that such a form of writing allows:
the <span class='lstinline'><span class='ec-lmtt-8'>distinct()</span></span> function could, under other circumstances, be implemented
differently, and still behave similarly from the perspective of the rest of the
program. Additionally, this wrapping enables the setting of default values
(here, <span class='lstinline'><span class='ec-lmtt-8'>true</span></span>), a minimal way to catch bugs by always providing a fallback
case.
</p><!-- l. 271 --><p class='indent'>   Kirby’s source code is also interestingly explicit in comments, and succint in code.
Let us take, for instance„ from the <span class='lstinline'><span class='ec-lmtt-8'>Http\\Route</span></span> class (<a href='#x1-14183r4'>2.4<!-- tex4ht:ref: route.php  --></a>).
</p>
   <!-- l. 273 -->
                                                                  

                                                                  
<!-- l. 273 --><p class='indent'>   </p><figure class='float' id='-routephp'>
                                                                  

                                                                  
<a id='x1-14183r4'></a>
<a id='x1-14184'></a>
<div class='lstlisting' id='listing-8'><span class='label'><a id='x1-14185r1'></a></span><span class='ec-lmtt-8'>  /** </span><br /> 
<span class='label'><a id='x1-14186r2'></a></span><span class='ec-lmtt-8'>  * Tries to match the path with the regular expression and </span><br /> 
<span class='label'><a id='x1-14187r3'></a></span><span class='ec-lmtt-8'>  * extracts all arguments for the Route action </span><br /> 
<span class='label'><a id='x1-14188r4'></a></span><span class='ec-lmtt-8'>  * </span><br /> 
<span class='label'><a id='x1-14189r5'></a></span><span class='ec-lmtt-8'>  * @param string $pattern </span><br /> 
<span class='label'><a id='x1-14190r6'></a></span><span class='ec-lmtt-8'>  * @param string $path </span><br /> 
<span class='label'><a id='x1-14191r7'></a></span><span class='ec-lmtt-8'>  * @return array|false </span><br /> 
<span class='label'><a id='x1-14192r8'></a></span><span class='ec-lmtt-8'>  */ </span><br /> 
<span class='label'><a id='x1-14193r9'></a></span><span class='ec-lmtt-8'> public function parse(string $pattern, string $path) </span><br /> 
<span class='label'><a id='x1-14194r10'></a></span><span class='ec-lmtt-8'> { </span><br /> 
<span class='label'><a id='x1-14195r11'></a></span><span class='ec-lmtt-8'>     // check for direct matches </span><br /> 
<span class='label'><a id='x1-14196r12'></a></span><span class='ec-lmtt-8'>     if ($pattern === $path) { </span><br /> 
<span class='label'><a id='x1-14197r13'></a></span><span class='ec-lmtt-8'>         return $this-&gt;arguments = []; </span><br /> 
<span class='label'><a id='x1-14198r14'></a></span><span class='ec-lmtt-8'>     } </span><br /> 
<span class='label'><a id='x1-14199r15'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-14200r16'></a></span><span class='ec-lmtt-8'>     // We only need to check routes with regular expression since all others </span><br /> 
<span class='label'><a id='x1-14201r17'></a></span><span class='ec-lmtt-8'>     // would have been able to be matched by the search for literal matches </span><br /> 
<span class='label'><a id='x1-14202r18'></a></span><span class='ec-lmtt-8'>     // we just did before we started searching. </span><br /> 
<span class='label'><a id='x1-14203r19'></a></span><span class='ec-lmtt-8'>     if (strpos($pattern, ’(’) === false) { </span><br /> 
<span class='label'><a id='x1-14204r20'></a></span><span class='ec-lmtt-8'>         return false; </span><br /> 
<span class='label'><a id='x1-14205r21'></a></span><span class='ec-lmtt-8'>     } </span><br /> 
<span class='label'><a id='x1-14206r22'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-14207r23'></a></span><span class='ec-lmtt-8'>     // If we have a match we’ll return all results </span><br /> 
<span class='label'><a id='x1-14208r24'></a></span><span class='ec-lmtt-8'>     // from the preg without the full first match. </span><br /> 
<span class='label'><a id='x1-14209r25'></a></span><span class='ec-lmtt-8'>     if (preg_match(’#^’ . $this-&gt;regex($pattern) . ’$#u’, $path, $parameters)) { </span><br /> 
<span class='label'><a id='x1-14210r26'></a></span><span class='ec-lmtt-8'>         return $this-&gt;arguments = array_slice($parameters, 1); </span><br /> 
<span class='label'><a id='x1-14211r27'></a></span><span class='ec-lmtt-8'>     } </span><br /> 
<span class='label'><a id='x1-14212r28'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-14213r29'></a></span><span class='ec-lmtt-8'>     return false; </span><br /> 
<span class='label'><a id='x1-14214r30'></a></span><span class='ec-lmtt-8'> }</span></div>
<figcaption class='caption'><span class='id'>Listing 2.4:</span><span class='content'>Route.php</span></figcaption><!-- tex4ht:label?: x1-14183r2.1  -->
                                                                  

                                                                  
   </figure>
<!-- l. 306 --><p class='indent'>   The 9 lines above the function declaration are machine-readable documentation. It can be
parsed by a programmatic system and used as input to generate more classical, human-readable
documentation<span class='footnote-mark'><a href='#fn18x2' id='fn18x2-bk'><sup class='textsuperscript'>18</sup></a></span><a id='x1-14215f18'></a>.
This is noticeable due to the highly formalized syntax <span class='lstinline'><span class='ec-lmtt-8'>param string name_of_var</span></span>, rather
than writing out "this function takes a parameter of type string named <span class='lstinline'><span class='ec-lmtt-8'>name_of_var</span></span>".
This does compensate for the tendency of comments to drift out of synchronicity
with the code that they are supposed to comment, by tying them back to some
computational system to verify its semantic contents, while providing information
about the inputs and outputs of the function.
</p><!-- l. 308 --><p class='indent'>   Beyond expliciting inputs and outputs, the second aspect of these comments is
targeted at the <span class='ec-lmri-10'>how </span>of the function, helping the reader understand the rationale
behind the programmatic process. Comments here aren’t cautionary notes on specific
edge-cases, as seen in fig. XX above, but rather natural language renderings of the
overall rationale of the process. The implication here is to provide a broader, and
more explicit understanding of the process of the function, in order to allow for
further maintenance, extension or modification.
</p><!-- l. 310 --><p class='indent'>   Finally, let us look at a subset of the function, the clause of the third <span class='lstinline'><span class='ec-lmtt-8'>if statement</span></span>:
<span class='lstinline'><span class='ec-lmtt-8'>(preg_match(’#^’ . $this-&gt;regex($pattern). ’$#u’, $path, $parameters))</span></span>. Without
comments, one must realize on cognitive gymnastics and knowledge of the PHP
syntax in order to render this as an extraction of all route parameters, implying the
removal of the first element of the array. In this sense, then, Kirby’s code for
parsing an HTTP route is both verbose—in comments—and parsimonious—in
code.
</p><!-- l. 312 --><p class='indent'>   What these aesthetic features (small number of files, short file length, short
function length) imply is an immediate feeling of <span class='ec-lmri-10'>building blocks</span>. Short,
graspable, (re-)usable (conceptual) blocks are made available to the developer
directly, as the Kirby ecosystem, like many other open-source projects, relies
on contributions from individuals who are not expected to have any other
encounter with the project other than, at the bare minimum, the source code
                                                                  

                                                                  
itself.
</p><!-- l. 316 --><p class='indent'>   These two examples, Microsoft Windows 2000 and Kirby CMS, highlight some
of the presentations of source code—repetition, verbosity, commenting and
conciseness—within socio-technical ecosystems made up of hardware, institutional
practices from corporation to open-source, efficiency and usability, both at the result
level (the software) and at the process level (the code).
</p><!-- l. 318 --><p class='indent'>   Software developers are a large group of practitioners whose focus on producing
effective, reliable and sustainable software, leads them to writing in more-or-less
codified manner. Before diving into how such a manner of writing relates to
references from architecture and engineering in order to foster simplicity and
understandability, in section 2.2, we acknowledge that the bondary between groups of
practicioners isn’t a clear-cut one, and so we turn to another practice closely linked
to professional development—hacking.
</p>
   <h4 class='subsectionHead' id='hackers-p'><span class='titlemark'>2.1.2   </span> <a id='x1-150002.1.2'></a>Hackers - 6p</h4>
<!-- l. 322 --><p class='noindent'>Joseph Weizenbaum’s description of what seems to be computer science graduate
students is one which has had wide echoes in the public imagination: hackers are
often depicted as lonely, obsessed programmers, hyperfocused on the task at hand
and able to switch altered mental states as they dive into computational
problems<span class='footnote-mark'><a href='#fn19x2' id='fn19x2-bk'><sup class='textsuperscript'>19</sup></a></span><a id='x1-15001f19'></a>.
While some of it is true—for instance, the gender, the compulsive behaviour and
the embodied connection to the machine—, hackers nonetheless designate a
wider group of people, one which writes code driven by curiosity, cleverness
and freedom, and which has had a significant influence in the culture of
programming.
</p><!-- l. 324 --><p class='indent'>   To hack, in the broadest sense, is to enthusiastically
inquire about the possibilities of exploitation of technical
systems<span class='footnote-mark'><a href='#fn20x2' id='fn20x2-bk'><sup class='textsuperscript'>20</sup></a></span><a id='x1-15002f20'></a> and, as such, predates
                                                                  

                                                                  
the advent of the computer<span class='footnote-mark'><a href='#fn21x2' id='fn21x2-bk'><sup class='textsuperscript'>21</sup></a></span><a id='x1-15003f21'></a>.
Computer hacking specifically came to proeminence as early computers started
to become available in north-american universities, and coalesced around
the Massachussets Institute of Technology’s Tech Model Railroad Club<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.
Computer hackers were skilled and highly-passionate individuals, with an
autotelic inclination to computer systems: these systems mattered most
when they referenced themselves, instead of interfacing with a given
problem domain. Early hackers were often self-taught, learning to tinker
with computers while still in high-school<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>, and as such tend to exhibit a
radical position towards expertise: skill and knowledge aren’t derived from
academic degrees or credentials, but rather from concrete ability and practical
efficacy<span class='footnote-mark'><a href='#fn22x2' id='fn22x2-bk'><sup class='textsuperscript'>22</sup></a></span><a id='x1-15004f22'></a>.
</p><!-- l. 326 --><p class='indent'>   The histories of hacking and of software development are deeply intertwined:
some of the early hackers worked on software engineering projects—such as the
graduate students who wrote the Apollo Guidance Computer routines under
Margaret Hamilton—, and then went on to profoundly shape computer infrastructure.
Particularly, the development of the UNIX operating system by Dennis Ritchie and
Ken Thompson is a key link in connecting hacker practices and professional ones.
Developed from 1969 at Bell Labs, AT&amp;T’s research division, UNIX was “very close
to being the first system under which a programmer could sit down directly at a
machine and compose programs on the fly, exploring possibilities and testing
while composing” (<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>), and was “was brainstormed by three people and
implemented by Ken Thompson in two days — on an obsolete machine that
had been designed to be a graphics terminal for a ’real’ computer.” (<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>).
This was a system which was supporting the free exploration of a system’s
boundaries central to the hacker culture, and which relied on sharing and
circulating source code in order to allow anyone to improve it—in effect,
AT&amp;T’s inexpensive licensing model until the 1980s, and the use of the C
programming language starting from 1977 made it widely available within university
settings<span class='footnote-mark'><a href='#fn23x2' id='fn23x2-bk'><sup class='textsuperscript'>23</sup></a></span><a id='x1-15005f23'></a>.
UNIX, then, was spreading its design philosophy of clear, modular, simple and
                                                                  

                                                                  
transparent design across programming communities.
</p><!-- l. 328 --><p class='indent'>   The next step in the evolution of hacker culture was to build on this tenet to
share source code, and hence to make written software understandable from its
textual manifestation. The switch identified in the previous section from hardware
being the most important component of a computing system to software had lead
manufacturers to stop distributing source code, making proprietary software the
norm. Until then, executable software was the consequence of running the source
code through a compilation process; around the 1980s, executable software
was distributed directly as a binary file, its exact contents an unreadable
series of 0s and 1s. As a result to licensing changes of the UNIX system, the
GNU project was created, and in its wake the Free Software Foundation,
which established the ethical requirement to access the source code of any
software.
</p><!-- l. 330 --><p class='indent'>   In the meantime, personal microcomputers came to the market and opened up
this ability to tinker and explore computer systems beyond the realms of
academic-licensed large mainframes and operating systems. Starting with models
such as the Altair 8800, the Apple II and the Commodore 64, as well as with easier,
interpreted computer languages such as BASIC, whose first version for such
micro-computers was written by Bill Gates, Paul Allen and Monte Davidoff<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.
While not considered "proper" programming by other programmers, the
microcomputer revolution allowed for new groups of individuals to explore the
interactivity of source code due to their small size when published as type-in
listings.
</p><!-- l. 332 --><p class='indent'>   In the wake of the larger free software movement, emerged its less radical
counterpart, the open-source movement, as well as its more illegal counterpart,
security hacking. The former are usually the types of individuals depicted in
mainstream news outlets when they reference hackers: programmers indulging
breaching private systems, sometimes in order to cause illegal financial, intelligence or
material harm. Security hackers, sometimes called crackers, form a community of
practice of their own, with ideas of superior intelligence, subversion, adventure and
stealth<span class='footnote-mark'><a href='#fn24x2' id='fn24x2-bk'><sup class='textsuperscript'>24</sup></a></span><a id='x1-15006f24'></a>.
                                                                  

                                                                  
These practices do refer to the original conception of hacking—getting something done
quickly, but not well—and include such a practical, efficient appoach into its own set
of values and ideals, which are in turn represented in the kinds of program
texts<span class='footnote-mark'><a href='#fn25x2' id='fn25x2-bk'><sup class='textsuperscript'>25</sup></a></span><a id='x1-15007f25'></a>.
</p><!-- l. 334 --><p class='indent'>   Meanwhile, the open-source movement took the tenets of hacking culture and
adapted it to make it more compatible to the requirements of businesses.
Open-source can indeed be seen as a compromise between the software industry
development practices and the efficacy of free software development. Indeed, beyond
the broad values of intellectual curiosity and skillful exploration, free software
projects such as the Linux kernel, the Apache server or the OpenSSL project
are highly efficient, and used in both commercial, non-commercial, critical
and non-critical environments<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. Such an approach sidesteps the political
and ethical values held in previous iterations of the hacker ethos in order
to focus exclusively on the sharing of source code and open collaboration
while remaining within an inquisitive and productive mindframe. With the
advent of corporate <span class='ec-lmri-10'>hackathons</span>—short instances of intense collaboration in
order to create new software, or new features on a software system—are a
particularly salient example of this overlap between industry practices and hacker
practices<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span><span class='footnote-mark'><a href='#fn26x2' id='fn26x2-bk'><sup class='textsuperscript'>26</sup></a></span><a id='x1-15008f26'></a>.
</p><!-- l. 338 --><p class='indent'>   Hackers are programmers which, while overlapping with industry-embedded
software developers, hold a set of values and ideals regarding the purpose and state of
software. Whether academic hackers, amateurs, security hackers or open-source
contributors, all are centered around the object of source code as a vehicle for
communicating the knowledge held within the software, bypassing auxiliary resources
such as natural-language documentation. Those political and ethical values often
overlap with aesthetic values associated to how the code exists in its textual
manifestation.
</p><!-- l. 340 --><p class='noindent'>
                                                                  

                                                                  
</p>
   <h5 class='subsubsectionHead' id='sharp-and-clever'><a id='x1-160002.1.2'></a>Sharp and clever</h5>
<!-- l. 342 --><p class='noindent'>
     </p><blockquote class='quote'>
     <!-- l. 343 --><p class='noindent'>To hack is, according to the dictionary, "to cut irregularly, without
     skill or definite purpose; to mangle by or as if by repeated strokes
     of a cutting instrument". I have already said that the compulsive
     programmer,  or  hacker  as  he  calls  himself,  is  usually  a  superb
     technician. It seems therefore that he is not "without skill" as the
     definition will have it. But the definition fits in the deeper sense that
     the hacker is "without definite purpose": he cannot set before him a
     clearly defined long-term goal and a plan for achieving it, for he has
     only technique, not knowledge. He has nothing he can analyze or
     synthesize; in short, he has nothing to form theories about. His skill is
     therefore aimless, even disembodied. It is simply not connected with
     anything other than the instrument on which it may be exercised.
     His skill is that of a monastic copyist who, though illiterate, is a first
     rate calligrapher.<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span></p></blockquote>
<!-- l. 346 --><p class='noindent'>While he looks down on hackers, perhaps unfairly, from the perspective of a computer
scientist whose theoretical work can be achieved only through thought, pen and
paper—an approach to programming which we will address in the next section—, the
point still remains: hackers are first and foremost technical experts who can get lost
into technics for their own sake. From a broad perspective, hackers therefore seem to
exhibit an attitude of <span class='ec-lmri-10'>direct engagement</span>, <span class='ec-lmri-10'>subverted use </span>and <span class='ec-lmri-10'>technical excellence</span>.
Gabriella Coleman, in her anthropological study of hackers, <span class='ec-lmri-10'>Coding Freedom: The
</span><span class='ec-lmri-10'>Ethics and Aesthetics of Hacking</span>, highlights that hackers value both semantic
ingenuity<span class='footnote-mark'><a href='#fn27x2' id='fn27x2-bk'><sup class='textsuperscript'>27</sup></a></span><a id='x1-16001f27'></a>
and technical wittiness, even though source code written by hackers can take multiple
shapes, from one-liners, to whole operating systems, to deliberate decisions to subvert
                                                                  

                                                                  
best practices in crucial moments
</p><!-- l. 348 --><p class='indent'>   The <span class='ec-lmri-10'>one-liner </span>is a piece of source code which fits on one line, and is usually
intepreted immediately by the operating system. They are terse, concise, and
eminently functional: they accomplish one task, and one task only. This
binary requirement of functionality (in the strict sense of: "does it do what
it’s supposed to do, or not?") actually finds a parallel in a different kind of
one-liners, the humoristic ones in jokes and stand-up comedy. In this context, the
one-liner also exhibits the features of conciseness and impact, with the setup
conflated with the punch line, within the same sentence. One-liners are therefore
self-contained, whole semantic statements which, through this syntactic
compression, appear to be clever—in a similar way that a good joke is labelled
clever.
</p><!-- l. 350 --><p class='indent'>   In programming, one-liners have their roots in the philosophy of the UNIX
operating system, as well as in the early diffusion of computer programs for personal
computer hobbyists<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. On the one side, the Unix philosophy is fundamentally about
building simple tools, which all do one thing well, in order to manipulate text
streams<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. Each of these tools can then be piped (directing one output of a
program-tool into the input of the next program-tool) in order to produce complex
results—reminiscing of the orthogonality feature of programming languages.
Sometimes openly acknowledged by language designers—such as those of AWK—the
goal is to write short programs which shouldn’t be longer than one line. Given
that constraint, a hacker’s response would then be: how short can you make
it?
</p><!-- l. 352 --><p class='indent'>   If writing one-line programs is within the reach of any medium-skilled programmer,
writing the shortest of all programs does become a matter of skill, coupled with a
compulsivity to reach the most syntactically compressed version. For instance, Guy
Steele<span class='footnote-mark'><a href='#fn28x2' id='fn28x2-bk'><sup class='textsuperscript'>28</sup></a></span><a id='x1-16002f28'></a>
recalls:
</p><!-- l. 354 --><p class='indent'>
     </p><blockquote class='quote'>
                                                                  

                                                                  
     <!-- l. 355 --><p class='noindent'>This may seem like a terrible waste of my effort, but one of the
     most satisfying moments of my career was when I realized that I had
     found a way to shave one word off an 11-word program that [Bill]
     Gosper had written. It was at the expense of a very small amount
     of execution time, measured in fractions of a machine cycle, but I
     actually found a way to shorten his code by 1 word and it had only
     taken me 20 years to do it<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>.</p></blockquote>
<!-- l. 358 --><p class='indent'>   This sort of compulsive behaviour is also manifested in the practice of <span class='ec-lmri-10'>code golf</span>,
challenges in which programmers must solve problems by using the least possible
amount of characters—here, the equivalent of <span class='ec-lmri-10'>par </span>in golf would be Kolmogorov
complexity<span class='footnote-mark'><a href='#fn29x2' id='fn29x2-bk'><sup class='textsuperscript'>29</sup></a></span><a id='x1-16003f29'></a>.
So minimizing program length in relation to the problem complexity is a definite
feature of one-liners, since choosing the right programming language for the right
taks can lead to a drastic reduction of syntax, while keeping the same expressive and
effective power. Tasked with parsing a text file to find which lines had a
numerical value greater than 6, Brian Kernighan writes the following code in
C<span class='footnote-mark'><a href='#fn30x2' id='fn30x2-bk'><sup class='textsuperscript'>30</sup></a></span><a id='x1-16004f30'></a>:
                                                                  

                                                                  
</p>
   <!-- l. 362 -->
<div class='lstlisting' id='listing-9'><span class='label'><a id='x1-16005r1'></a></span><span class='ec-lmtt-8'>  #include &lt;stdio.h&gt; </span><br /> 
<span class='label'><a id='x1-16006r2'></a></span><span class='ec-lmtt-8'>  #include &lt;strings.h&gt; </span><br /> 
<span class='label'><a id='x1-16007r3'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-16008r4'></a></span><span class='ec-lmtt-8'>  int main(void){ </span><br /> 
<span class='label'><a id='x1-16009r5'></a></span><span class='ec-lmtt-8'>    char line[1000], line2[1000]; </span><br /> 
<span class='label'><a id='x1-16010r6'></a></span><span class='ec-lmtt-8'>    char *p; </span><br /> 
<span class='label'><a id='x1-16011r7'></a></span><span class='ec-lmtt-8'>    double mag; </span><br /> 
<span class='label'><a id='x1-16012r8'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-16013r9'></a></span><span class='ec-lmtt-8'>    while(fgets(line, sizeof(line), stdin) != NULL) { </span><br /> 
<span class='label'><a id='x1-16014r10'></a></span><span class='ec-lmtt-8'>      strcpy(line2, line); </span><br /> 
<span class='label'><a id='x1-16015r11'></a></span><span class='ec-lmtt-8'>      p = strtok(line, "\t"); </span><br /> 
<span class='label'><a id='x1-16016r12'></a></span><span class='ec-lmtt-8'>      p = strtok(NULL, "\t"); </span><br /> 
<span class='label'><a id='x1-16017r13'></a></span><span class='ec-lmtt-8'>      p = strtok(NULL, "\t"); </span><br /> 
<span class='label'><a id='x1-16018r14'></a></span><span class='ec-lmtt-8'>      sscanf(p, "%lf", &amp;mag); </span><br /> 
<span class='label'><a id='x1-16019r15'></a></span><span class='ec-lmtt-8'>      if(mag &gt; 6) /* $3 &gt; 6 */ </span><br /> 
<span class='label'><a id='x1-16020r16'></a></span><span class='ec-lmtt-8'>        printf("%s", line2); </span><br /> 
<span class='label'><a id='x1-16021r17'></a></span><span class='ec-lmtt-8'>    } </span><br /> 
<span class='label'><a id='x1-16022r18'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-16023r19'></a></span><span class='ec-lmtt-8'>    return 0 </span><br /> 
<span class='label'><a id='x1-16024r20'></a></span><span class='ec-lmtt-8'>  }</span></div>
<!-- l. 385 --><p class='indent'>   The equivalent in AWK, a language he designed, and which he actually refers to
in the comment on line 15, presumably as a heuristic as he is writing the function,
is:
</p>
   <!-- l. 387 -->
<div class='lstlisting' id='listing-10'><span class='label'><a id='x1-16025r1'></a></span><span class='ec-lmtt-8'>  awk ’$3 &gt; 6’ data.txt</span></div>
<!-- l. 391 --><p class='indent'>   The difference is obvious, not just in terms of formal clarity and cleanliness of the
surface structure, but also in terms of matching the problem domain: this obviously
prints every line in which the third field is greater than 6. The AWK one-liner is
more efficient, more understandable because more intuitive, and therefore more
beautiful. On the other hand, however, one-liners can be so condensed that they loose
all sense of clarity for someone who doesn’t have a deep knowledge in the specific
language in which it is written. Here is Conway’s game of life implemented in one line
of APL:
                                                                  

                                                                  
</p>
   <pre class='verbatim' id='verbatim-1'>
  life ← {⊃1 ⍵ ∨.∧ 3 4 = +/ +⌿ ¯1 0 1 ∘.⊖ ¯1 0 1 ⌽¨ ⊂⍵}
</pre>
<!-- l. 395 --><p class='nopar'>
</p><!-- l. 397 --><p class='indent'>   The obscurity of such a line—due to its highly-unusual character notation, and
despite the pre-existing knowledge of the expected output—shows why one-liners are
usually highly discouraged for any sort of code which needs to be <span class='ec-lmri-10'>worked on </span>by other
programmers. Cleverness in programming indeed tends to be seen as a display of
the relationship between the programmer and the machine, rather than
between different programmers, and only tangentially about the machine.
On the other hand, though, the nature of one-liners makes them highly
portable and shareable, infusing them with what one could call <span class='ec-lmri-10'>social beauty</span>.
Popular with early personal computer adopters, at a time during which the
source code of programs were printed in hobbyist magazines and needed to
be input by hand, and during which the potential of computation wasn’t
as widely distributed amongst society, being able to type just one line in,
say, a BASIC interpreter, and resulting in unexpected graphical patterns
created a sense of magic and wonder in first-time users—how can so little do so
much?<span class='footnote-mark'><a href='#fn31x2' id='fn31x2-bk'><sup class='textsuperscript'>31</sup></a></span><a id='x1-16026f31'></a>.
</p><!-- l. 399 --><p class='indent'>   Another example of beautiful code written by hackers is the UNIX operating
system, whose inception was an informal side-project spearheaded by Ken Thompson
and Dennis Ritchie in the 1970s. As the first portable operating system, UNIX’s
influence in modern computing was significant, e.g. in showing the viability and
efficiency of text-based processing, hierarchical file-system, shell scripting and regular
expressions, amongst others. UNIX is also one of the few pieces of production
software which has been carefully studied and documented by other developers. One
of the most famous examples is <span class='ec-lmri-10'>Lions’ Commentary on UNIX 6th Edition,
</span><span class='ec-lmri-10'>with Source Code </span>by John Lions, an annotated edition of the UNIX source
                                                                  

                                                                  
code, which was circulated illegaly in classrooms for twenty years before
its official publication was authorized by the copyright owners<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. Coming
back to the relationship between architecture and software development,
Christopher Alexander asks, in the preface of Richard P. Gabriel’s <i>Patterns of
Software</i><span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>,
</p><!-- l. 401 --><p class='indent'>
     </p><blockquote class='quote'>
     <!-- l. 402 --><p class='noindent'><i>For a programmer, what is a comparable goal? What is the Chartres
     of programming? What task is at a high enough level to inspire people
     writing programs, to reach for the stars?</i></p></blockquote>
<!-- l. 405 --><p class='indent'>   And UNIX might be one of the answers to that question, both by its
functionality, and by its conciseness, if not alone by its availability. Another
program which qualifies as beautiful hacker code, due both to its technical
excellence, unusual solution and open-source availability is the function to
compute the inverse square root of a number, a calculation that is particularly
necessary in any kind of rendering application (which heavily involves
vector arithmetic). It was found in the <span class='ec-lmri-10'>Quake </span>source code, listed here
verbatim<span class='footnote-mark'><a href='#fn32x2' id='fn32x2-bk'><sup class='textsuperscript'>32</sup></a></span><a id='x1-16027f32'></a>:
                                                                  

                                                                  
</p>
   <!-- l. 409 -->
<div class='lstlisting' id='listing-11'><span class='label'><a id='x1-16028r1'></a></span><span class='ec-lmtt-8'>  float Q_rsqrt( float number ) </span><br /> 
<span class='label'><a id='x1-16029r2'></a></span><span class='ec-lmtt-8'>  { </span><br /> 
<span class='label'><a id='x1-16030r3'></a></span><span class='ec-lmtt-8'>      long i; </span><br /> 
<span class='label'><a id='x1-16031r4'></a></span><span class='ec-lmtt-8'>      float x2, y; </span><br /> 
<span class='label'><a id='x1-16032r5'></a></span><span class='ec-lmtt-8'>      const float threehalfs = 1.5F; </span><br /> 
<span class='label'><a id='x1-16033r6'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-16034r7'></a></span><span class='ec-lmtt-8'>      x2 = number * 0.5F; </span><br /> 
<span class='label'><a id='x1-16035r8'></a></span><span class='ec-lmtt-8'>      y  = number; </span><br /> 
<span class='label'><a id='x1-16036r9'></a></span><span class='ec-lmtt-8'>      i  = * ( long * ) &amp;y;    // evil floating point bit level hacking </span><br /> 
<span class='label'><a id='x1-16037r10'></a></span><span class='ec-lmtt-8'>      i  = 0x5f3759df - ( i &gt;&gt; 1 );               // what the fuck? </span><br /> 
<span class='label'><a id='x1-16038r11'></a></span><span class='ec-lmtt-8'>      y  = * ( float * ) &amp;i; </span><br /> 
<span class='label'><a id='x1-16039r12'></a></span><span class='ec-lmtt-8'>      y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration </span><br /> 
<span class='label'><a id='x1-16040r13'></a></span><span class='ec-lmtt-8'>  //  y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, </span><br /> 
<span class='label'><a id='x1-16041r14'></a></span><span class='ec-lmtt-8'>                                                // this can be removed </span><br /> 
<span class='label'><a id='x1-16042r15'></a></span><span class='ec-lmtt-8'> </span><br /> 
<span class='label'><a id='x1-16043r16'></a></span><span class='ec-lmtt-8'>      return y; </span><br /> 
<span class='label'><a id='x1-16044r17'></a></span><span class='ec-lmtt-8'>  }</span></div>
<!-- l. 429 --><p class='indent'>   What we see here is indeed a combination of the understanding of the problem
domain (what’s the acceptable result I need to maintain a high-framerate
with complex graphics), and how the specific knowledge of computers (i.e.
bit-shifting of a float cast as an integer) and the snappiness and wonder of the the
comments<span class='footnote-mark'><a href='#fn33x2' id='fn33x2-bk'><sup class='textsuperscript'>33</sup></a></span><a id='x1-16045f33'></a>.
The use of <span class='lstinline'><span class='ec-lmtt-8'>0x5f3759df</span></span> is what programmers call a <span class='ec-lmri-10'>magic number</span>, a literal value whose
role in the code isn’t made clearer by a descriptive variable name. Usually bad
practice and highly-discouraged, the magic number here is exactly that: it does
makes the magic happen.
</p><!-- l. 431 --><p class='indent'>   Further examples of such intimate knowledge of both the language and the
machine can be found in the works of the <span class='ec-lmri-10'>demoscene</span>. Starting in Europe in the
1980s, demos were first short audio-visual programs which were distributed along
with <span class='ec-lmri-10'>crackware </span>(pirated software), and to which the names of the people having
cracked the software were prepended, in the form of a short animation<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span>. Due to this
very concrete constraint—there was only so much memory left on a pirated disk to fit
such a demo—programmers had to work with these limitations in order to
produce the most awe-inspiring effects. Indeed, one notable feature of the
demoscene is that the output should be as impressive as possible, as an
immediate, phenomenological appreciation of the code which could make this
happen<span class='footnote-mark'><a href='#fn34x2' id='fn34x2-bk'><sup class='textsuperscript'>34</sup></a></span><a id='x1-16046f34'></a>.
Indeed, the <span class='lstinline'><span class='ec-lmtt-8'>comp.sys.ibm.pc.demos</span></span> news group states in their FAQ:
</p><!-- l. 433 --><p class='indent'>
     </p><blockquote class='quote'>
     <!-- l. 434 --><p class='noindent'>A Demo is a program that displays a sound, music, and light show,
                                                                  

                                                                  
     usually in 3D. Demos are very fun to watch, because they seemingly
     do things that aren’t possible on the machine they were programmed
     on.
     </p><!-- l. 436 --><p class='noindent'>Essentially, demos "show off". They do so in usually one, two, or all
     three of three following methods:
</p>
    <ul class='itemize1'>
    <li class='itemize'>They show off the computer’s hardware abilities (3D objects,
    multi-channel sound, etc.)
    </li>
    <li class='itemize'>They show off the creative abilities of the demo group (artists,
    musicians)
    </li>
    <li class='itemize'>They  show  off  the  programmer’s  abilities  (fast  3D  shaded
    polygons, complex motion, etc.)<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span></li></ul>
     </blockquote>
<!-- l. 445 --><p class='indent'>   This showing off, however, does not happen through immediate engagement with
the code from the reader’s part, but rather in the thorough explanation of the minute
functionalities of the demo by its writer. Because of these constraints of size, the
demos are usually written in C, openGL, Assembly, or the native language of the
targeted hardware. Source code listings of demos also make extensive use of shortcuts
and tricks, and little attention is paid to whether or not other humans would
directly read the source—the only intended recipient is a very specific machine
(e.g. Commodore 64, Amiga VCS, etc.). The release of demos, usually in
demoparties, are sometimes accompanied by documentation, write-ups or
                                                                  

                                                                  
presentations<span class='footnote-mark'><a href='#fn35x2' id='fn35x2-bk'><sup class='textsuperscript'>35</sup></a></span><a id='x1-16047f35'></a>.
However, this presentation format acknowledges a kind of individual, artistic feat,
rather than the <span class='ec-lmri-10'>egoless programming </span>lauded by Brooks in professional software
development<span class='footnote-mark'><a href='#fn36x2' id='fn36x2-bk'><sup class='textsuperscript'>36</sup></a></span><a id='x1-16048f36'></a>.
</p><!-- l. 447 --><p class='indent'>   Pushing the boundaries of how much can be done in how little code, here is a
256-bytes demo resulting in a minute-long music video<span class='cite'>[<span class='ec-lmbx-10'>?</span>]</span> on the Commodore 64. It is
firsted listed as a hexademical dump by its author:
</p>
   <!-- l. 449 -->
<div class='lstlisting' id='listing-12'><span class='label'><a id='x1-16049r1'></a></span><span class='ec-lmtt-8'>  0000000 0801 080d d3ff 329e 3232 0035 0000 4119 </span><br /> 
<span class='label'><a id='x1-16050r2'></a></span><span class='ec-lmtt-8'>  0000010 d01c dc00 0000 d011 0be0 3310 610e f590 </span><br /> 
<span class='label'><a id='x1-16051r3'></a></span><span class='ec-lmtt-8'>  0000020 0007 1fff 4114 24d5 2515 5315 6115 29d5 </span><br /> 
<span class='label'><a id='x1-16052r4'></a></span><span class='ec-lmtt-8'>  0000030 0f1b 13e6 13e6 02d0 20e6 61a9 1c85 20a7 </span><br /> 
<span class='label'><a id='x1-16053r5'></a></span><span class='ec-lmtt-8'>  0000040 3fe0 08f0 0c90 114e 6cd0 fffc 6da0 2284 </span><br /> 
<span class='label'><a id='x1-16054r6'></a></span><span class='ec-lmtt-8'>  0000050 d784 4b4a a81c 13a5 3029 02d0 1cc6 2fe0 </span><br /> 
<span class='label'><a id='x1-16055r7'></a></span><span class='ec-lmtt-8'>  0000060 11f0 02b0 02a2 10c9 09f0 298a aa03 f3b5 </span><br /> 
<span class='label'><a id='x1-16056r8'></a></span><span class='ec-lmtt-8'>  0000070 0a85 ab2d b000 b711 b622 9521 a500 4b13 </span><br /> 
<span class='label'><a id='x1-16057r9'></a></span><span class='ec-lmtt-8'>  0000080 aa0e f8cb cc86 0749 0b85 13a5 0f29 0fd0 </span><br /> 
<span class='label'><a id='x1-16058r10'></a></span><span class='ec-lmtt-8'>  0000090 b8a9 1447 0290 1485 0729 b5aa 85f7 a012 </span><br /> 
<span class='label'><a id='x1-16059r11'></a></span><span class='ec-lmtt-8'>  00000a0 b708 910d 880f f910 b7a8 9109 8803 f9d0 </span><br /> 
<span class='label'><a id='x1-16060r12'></a></span><span class='ec-lmtt-8'>  00000b0 7e4c 78ea 868e 8e02 d021 4420 a2e5 bdfd </span><br /> 
<span class='label'><a id='x1-16061r13'></a></span><span class='ec-lmtt-8'>  00000c0 0802 0295 d0ca 8ef8 0315 cc4c a900 8d50 </span><br /> 
<span class='label'><a id='x1-16062r14'></a></span><span class='ec-lmtt-8'>  00000d0 d011 ad58 dc04 c3a0 1c0d 48d4 044b 30a0 </span><br /> 
<span class='label'><a id='x1-16063r15'></a></span><span class='ec-lmtt-8'>  00000e0 188c 71d0 e6cb 71cb 6acb 2005 58a0 d505 </span><br /> 
<span class='label'><a id='x1-16064r16'></a></span><span class='ec-lmtt-8'>  00000f0 cb91 dfd0 aa2b 6202 1800 2026 2412 1013</span></div>
<!-- l. 468 --><p class='indent'>   Even with knowledge of how hexadecimal instructions map to the instruction set
of the specific chip of of the Commodore 64 (in this case, the SID 8580), the practical
use of these instructions takes productive advantage of ambivalence and side-effects.
In the words of the author, Linus Akesson (emphasis mine):
</p><!-- l. 470 --><p class='indent'>
     </p><blockquote class='quote'>
     <!-- l. 471 --><p class='noindent'>We need to tell the VIC chip to look for the video matrix at address
     $0c00 and the font at $0000. This is done by writing $30 into the
     bank register ($d018). But this will be done from within the loop, as
     doing so allows us to use the value $30 for two things. <span class='ec-lmri-10'>An important
     </span><span class='ec-lmri-10'>property of this particular bank configuration is that the system stack
     </span><span class='ec-lmri-10'>page becomes part of the font definition</span>.</p></blockquote>
<!-- l. 474 --><p class='indent'>   Demosceners therefore tend to write beautiful, deliberate code which is
hardly understandable by other programmers without explanation, and yet
hand-optimized for the machine. This presents a different perspective of
the relationship between aesthetics and understanding, in which aesthetics
do not support and enable understanding, but rather become a proof of
                                                                  

                                                                  
the mastery and skill required to input such a concise input for such an
overwhelming output. This shows in an extreme way that one does need a
degree of expert knowledge in order to appreciate it—in this sense, aesthetics
in programming are shown to be almost often dependent on pre-existing
knowledge.
</p><!-- l. 478 --><p class='indent'>   The ideals at play in the writing and reading of source code is thus centered
around specific means of knowledge: knowledge of the hardware, knowledge of the
programming language used and knowledge of the tradeoffs acceptable all the
while exhibiting an air of playfulness—how far can one go before breaking
the system entirely? Still, one aspect that seems to elude hackers in their
conception of code is that of conceptual soundness. If code is considered beautiful
by attaining previously unthought of purposes with the least amount of
resources, rationalization as to why, whether <span class='ec-lmri-10'>a prior </span>or <span class='ec-lmri-10'>a posteriori</span>, does not
seem to be a central value, unlike computer scientists, to whom we turn to
next.
</p>
     <ul class='itemize1'>
     <li class='itemize'>ad hoc, locality, implication of the hardware as a crucial, central piece of
     information
     </li>
     <li class='itemize'>technical knowledge
     </li>
     <li class='itemize'>"You can create art and beauty on the computer"
     </li>
     <li class='itemize'>unlinguistic -&gt; more material approach of "shaving off characters"
     </li>
     <li class='itemize'>gabriella coleman: coding freedom</li></ul>
<!-- l. 490 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='scientists-p'><span class='titlemark'>2.1.3   </span> <a id='x1-170002.1.3'></a>Scientists - 4p</h4>
     <ul class='itemize1'>
     <li class='itemize'>PL &amp; algo implementers
     </li>
     <li class='itemize'>textbooks
     </li>
     <li class='itemize'>data scientists   <a class='url' href='https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.1001745'><span class='ec-lmtt-10'>https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.1001745</span></a></li></ul>
<!-- l. 498 --><p class='noindent'>binary search algorithm’s implementation is only accurate in is only found in five out
of twenty textbooks Pattis, Richard E. (1988). "Textbook errors in binary searching".
SIGCSE Bulletin. 20: 190–194. doi:10.1145/52965.53012.
</p><!-- l. 500 --><p class='indent'>   examples of beautiful scientist code:
</p>
                                                                  

                                                                  
     <ul class='itemize1'>
     <li class='itemize'>LISP (full of concepts)
     </li>
     <li class='itemize'>some sort of quicksort -&gt; https://stackoverflow.com/questions/26301/your-favourite-algorithm-and-the-lesson-it-taught-you
     </li>
     <li class='itemize'>fractals?
     </li>
     <li class='itemize'>list               of               implementations               in               julia
     https://github.com/mossr/BeautifulAlgorithms.jl</li></ul>
<!-- l. 510 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='poets-p'><span class='titlemark'>2.1.4   </span> <a id='x1-180002.1.4'></a>Poets - 4p</h4>
     <ul class='itemize1'>
     <li class='itemize'>history of creative coding
     </li>
     <li class='itemize'>digital art vs. software art
                                                                  

                                                                  
     </li>
     <li class='itemize'>code poets</li></ul>
<!-- l. 519 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='ideals-of-beauty-p'><span class='titlemark'>2.2   </span> <a id='x1-190002.2'></a>Ideals of beauty - 15p</h3>
<!-- l. 521 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='introduction-to-the-methodology-p'><span class='titlemark'>2.2.1   </span> <a id='x1-200002.2.1'></a>Introduction to the Methodology - 3p</h4>
<!-- l. 523 --><p class='noindent'>Kintsch and Van Dijk
</p><!-- l. 525 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='lexical-field-in-programmer-discourse-p'><span class='titlemark'>2.2.2   </span> <a id='x1-210002.2.2'></a>Lexical Field in Programmer Discourse -12p</h4>
<!-- l. 527 --><p class='noindent'>Positive words (13p)
</p>
     <ul class='itemize1'>
     <li class='itemize'>clean
     </li>
     <li class='itemize'>simple
                                                                  

                                                                  
     </li>
     <li class='itemize'>elegant
     </li>
     <li class='itemize'>transparent/self-explanatory</li></ul>
<!-- l. 536 --><p class='indent'>   Negative words (2p)
</p>
     <ul class='itemize1'>
     <li class='itemize'>smelly
     </li>
     <li class='itemize'>entangled</li></ul>
<!-- l. 543 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='types-of-beauty-p'><span class='titlemark'>2.3   </span> <a id='x1-220002.3'></a>Types of beauty - 20p</h3>
<!-- l. 545 --><p class='noindent'>Now that we’ve done some empirical work, we can try to abstract away a bit and
then look into how this relates to existing frameworks of aesthetics.
</p><!-- l. 547 --><p class='indent'>   Now that <span class='ec-lmri-10'>we look at proofs, through discourse</span>, what kind of beauty can we be
dealing with?
                                                                  

                                                                  
</p><!-- l. 549 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='literary-beauty'><span class='titlemark'>2.3.1   </span> <a id='x1-230002.3.1'></a>Literary Beauty</h4>
<!-- l. 551 --><p class='noindent'>This second approach contrasts with the functional component of the first one, but
nonetheless stands in relationship with it. the creative beauty, by defying traditional
beauty standards, does help us highlight, through deviance, what the norm is. These
texts on "creative beauty" include the classical perl poetry, code poems, IOCC, code
poetry contest, etc.
</p><!-- l. 553 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='mathematical-beauty'><span class='titlemark'>2.3.2   </span> <a id='x1-240002.3.2'></a>Mathematical beauty</h4>
<!-- l. 555 --><p class='noindent'>Mostly elegance, could be a good place to work on the distinction between proof and
theorem, concept and appearance.
</p><!-- l. 557 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='architectural-beauty'><span class='titlemark'>2.3.3   </span> <a id='x1-250002.3.3'></a>Architectural beauty</h4>
<!-- l. 559 --><p class='noindent'>This allows a segue into everyday aesthetics and environmental aesthetics
</p><!-- l. 561 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='craft-and-beauty-p'><span class='titlemark'>2.4   </span> <a id='x1-260002.4'></a>Craft and beauty - 10p</h3>
<!-- l. 563 --><p class='noindent'>Now that we’ve seen how the aesthetic ideals of code borrow from different registers,
we need to think about practice, or ways. all of the above can be seen through the
prism of craft
                                                                  

                                                                  
</p><!-- l. 565 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='functional-beauty'><span class='titlemark'>2.4.1   </span> <a id='x1-270002.4.1'></a>Functional beauty</h4>
<!-- l. 567 --><p class='noindent'>This first approach, by comparing both source and comment at the same time
(taking texts which are explicitly described as being beautiful), explicitly highlights
the requirements for source code to be beautiful.
</p><!-- l. 569 --><p class='indent'>   There is also an emerging development in aesthetics of integrating function as a
criteria for an aesthetic experience.
</p><!-- l. 571 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='embodiment'><span class='titlemark'>2.4.2   </span> <a id='x1-280002.4.2'></a>Embodiment</h4>
<!-- l. 573 --><p class='noindent'>also note the place and role of tools (IDEs, teletypes, fast compiling, etc.)
</p><!-- l. 575 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='tacit-knowledge'><span class='titlemark'>2.4.3   </span> <a id='x1-290002.4.3'></a>Tacit knowledge</h4>
                                                                  

                                                                  
                                                                  

                                                                  
                                                                  

                                                                  
   <div class='footnotes'><!-- l. 47 --><p class='indent'>     <span class='footnote-mark'><a href='#fn1x1-bk' id='fn1x1'><sup class='textsuperscript'>1</sup></a></span><span class='ec-lmr-8'>https://linfo.org/sourcecode.html</span></p>
<!-- l. 73 --><p class='indent'>     <span class='footnote-mark'><a href='#fn2x1-bk' id='fn2x1'><sup class='textsuperscript'>2</sup></a></span><span class='ec-lmr-8'>See Annex for the list of collected corpus</span></p>
<!-- l. 77 --><p class='indent'>     <span class='footnote-mark'><a href='#fn3x1-bk' id='fn3x1'><sup class='textsuperscript'>3</sup></a></span><span class='ec-lmr-8'>Plato, Republic</span></p>
<!-- l. 77 --><p class='indent'>     <span class='footnote-mark'><a href='#fn4x1-bk' id='fn4x1'><sup class='textsuperscript'>4</sup></a></span><span class='ec-lmr-8'>Aristotle, Poetics; Kant, Critique of the Power of Judgment</span></p>
<!-- l. 77 --><p class='indent'>     <span class='footnote-mark'><a href='#fn5x1-bk' id='fn5x1'><sup class='textsuperscript'>5</sup></a></span><span class='ec-lmr-8'>Leibniz, Ars Combinatoria</span></p>
<!-- l. 77 --><p class='indent'>     <span class='footnote-mark'><a href='#fn6x1-bk' id='fn6x1'><sup class='textsuperscript'>6</sup></a></span><span class='ec-lmr-8'>Baumgarten, Aesthetics</span></p>
<!-- l. 89 --><p class='indent'>     <span class='footnote-mark'><a href='#fn7x1-bk' id='fn7x1'><sup class='textsuperscript'>7</sup></a></span><span class='ec-lmr-8'>For instance, Venustas, Firmitas, Utilitas; See Fishwisck, P. (éd), </span><span class='ec-lmri-8'>Aesthetic Computing</span></p>
<!-- l. 89 --><p class='indent'>     <span class='footnote-mark'><a href='#fn8x1-bk' id='fn8x1'><sup class='textsuperscript'>8</sup></a></span><span class='ec-lmr-8'>As we’ve seen with Goodman, there is nonetheless a tight connection between those to
</span><span class='ec-lmr-8'>states.</span></p><!-- l. 196 --><p class='indent'> <span class='footnote-mark'><a href='#fn9x1-bk' id='fn9x1'><sup class='textsuperscript'>9</sup></a></span><span class='ec-lmr-8'>With exceptions of the recent works cited above.</span></p>
<!-- l. 199 --><p class='indent'>     <span class='footnote-mark'><a href='#fn10x1-bk' id='fn10x1'><sup class='textsuperscript'>10</sup></a></span><span class='ec-lmr-8'>For instance, see the work done in the field of platform studies</span><span class='cite'><span class='ec-lmr-8'>[</span><span class='ec-lmbx-8'>?</span><span class='ec-lmr-8'>]</span></span></p>
<!-- l. 225 --><p class='indent'>     <span class='footnote-mark'><a href='#fn11x1-bk' id='fn11x1'><sup class='textsuperscript'>11</sup></a></span><span class='ec-lmr-8'>While software was circulating freely on ARPANET and early networks, the application of
</span><span class='ec-lmr-8'>the intellectual property regime on software in 1974 significantly reduced the open-availability of
</span><span class='ec-lmr-8'>source code.</span></p><!-- l. 225 --><p class='indent'> <span class='footnote-mark'><a href='#fn12x1-bk' id='fn12x1'><sup class='textsuperscript'>12</sup></a></span><span class='ec-lmr-8'>A build system is a fairly complex series of code transformations intended to generate
</span><span class='ec-lmr-8'>executable code.</span></p><!-- l. 233 --><p class='indent'> <span class='footnote-mark'><a href='#fn13x1-bk' id='fn13x1'><sup class='textsuperscript'>13</sup></a></span><span class='ec-lmr-8'>Such a distinction isn’t a strict binary, and systems of inscription exist which couple code a
</span><span class='ec-lmr-8'>commentary more tightly, such as WEB or Juptyer Notebook.</span></p>
<!-- l. 17 --><p class='indent'>     <span class='footnote-mark'><a href='#fn1x2-bk' id='fn1x2'><sup class='textsuperscript'>1</sup></a></span><span class='ec-lmr-8'>For instance, Microsoft’s Visual Basic for Applications, Ableton’s Max For Live, MIT’s
</span><span class='ec-lmr-8'>Scrath or McNeel’s Grasshopper are all programming frameworks which are not covered within the
</span><span class='ec-lmr-8'>scope of this study. In the case of VBA and similar office-based high-level programming, it is
</span><span class='ec-lmr-8'>because such a practice is a highly personal and </span><span class='ec-lmri-8'>ad hoc </span><span class='ec-lmr-8'>one, and therefore is less available for
</span><span class='ec-lmr-8'>study.</span></p>
<!-- l. 25 --><p class='indent'>     <span class='footnote-mark'><a href='#fn2x2-bk' id='fn2x2'><sup class='textsuperscript'>2</sup></a></span><span class='ec-lmr-8'>One of the first operating systems, MIT’s Tape Director, would be only developped in
</span><span class='ec-lmr-8'>1956</span><span class='cite'><span class='ec-lmr-8'>[</span><span class='ec-lmbx-8'>?</span><span class='ec-lmr-8'>]</span></span></p>
<!-- l. 27 --><p class='indent'>     <span class='footnote-mark'><a href='#fn3x2-bk' id='fn3x2'><sup class='textsuperscript'>3</sup></a></span><span class='ec-lmr-8'>source?</span></p><!-- l. 29 --><p class='indent'> <span class='footnote-mark'><a href='#fn4x2-bk' id='fn4x2'><sup class='textsuperscript'>4</sup></a></span><span class='ec-lmr-8'>For a more detailed account of the personal computer revolution, see: Cerruzzi, P., A
</span><span class='ec-lmr-8'>History of Modern Computing</span><span class='cite'><span class='ec-lmr-8'>[</span><span class='ec-lmbx-8'>?</span><span class='ec-lmr-8'>]</span></span></p>
<!-- l. 31 --><p class='indent'>     <span class='footnote-mark'><a href='#fn5x2-bk' id='fn5x2'><sup class='textsuperscript'>5</sup></a></span><span class='ec-lmr-8'>See, for instance, Chapter 1: "</span><span class='ec-lmri-8'>On our inability to do much</span><span class='ec-lmr-8'>"</span></p>
<!-- l. 37 --><p class='indent'>     <span class='footnote-mark'><a href='#fn6x2-bk' id='fn6x2'><sup class='textsuperscript'>6</sup></a></span><span class='ec-lmr-8'>See     </span><a class='url' href='https://catless.ncl.ac.uk/Risks/'><span class='ec-lmtt-8'>https://catless.ncl.ac.uk/Risks/</span></a> <span class='ec-lmr-8'>for such risks</span></p>
<!-- l. 37 --><p class='indent'>     <span class='footnote-mark'><a href='#fn7x2-bk' id='fn7x2'><sup class='textsuperscript'>7</sup></a></span><span class='ec-lmr-8'>See Jackson, Principles of Program Design, or Martin, Clean Code, among others.</span></p>
<!-- l. 43 --><p class='indent'>     <span class='footnote-mark'><a href='#fn8x2-bk' id='fn8x2'><sup class='textsuperscript'>8</sup></a></span><span class='ec-lmr-8'>Such as the Microsoft Windows XP source code</span><span class='cite'><span class='ec-lmr-8'>[</span><span class='ec-lmbx-8'>?</span><span class='ec-lmr-8'>]</span></span><span class='ec-lmr-8'>.</span></p>
<!-- l. 54 --><p class='indent'>     <span class='footnote-mark'><a href='#fn9x2-bk' id='fn9x2'><sup class='textsuperscript'>9</sup></a></span><span class='ec-lmr-8'>Following C. Anthony Hoare’s assessment in his Turing Award Lecture that </span><span class='ec-lmri-8'>"there are two
</span><span class='ec-lmri-8'>ways of constructing a software design: one way is to make it so simple that there are obviously no
</span><span class='ec-lmri-8'>deficiencies, and the other way is to make it so complicated that there are no obvious
</span><span class='ec-lmri-8'>deficiencies."</span></p>
<!-- l. 54 --><p class='indent'>     <span class='footnote-mark'><a href='#fn10x2-bk' id='fn10x2'><sup class='textsuperscript'>10</sup></a></span><span class='ec-lmr-8'>The term software construction refers to the detailed creation of working software through
</span><span class='ec-lmr-8'>a combination of coding, verification, unit testing, integration testing, and debugging.</span><span class='cite'><span class='ec-lmr-8'>[</span><span class='ec-lmbx-8'>?</span><span class='ec-lmr-8'>]</span></span><span class='ec-lmr-8'>.</span></p>
<!-- l. 62 --><p class='indent'>     <span class='footnote-mark'><a href='#fn11x2-bk' id='fn11x2'><sup class='textsuperscript'>11</sup></a></span><span class='ec-lmr-8'>McConnell estimates that the industry average is about 15 - 50 errors per 1000 lines of
</span><span class='ec-lmr-8'>delivered code.</span><span class='cite'><span class='ec-lmr-8'>[</span><span class='ec-lmbx-8'>?</span><span class='ec-lmr-8'>]</span></span><span class='ec-lmr-8'>.</span></p>
<!-- l. 176 --><p class='indent'>     <span class='footnote-mark'><a href='#fn12x2-bk' id='fn12x2'><sup class='textsuperscript'>12</sup></a></span><span class='ec-lmr-8'>Effectively, references to </span><span class='lstinline'><span class='ec-lmtt-8'>RtlInitUnicodeString()</span></span> <span class='ec-lmr-8'>happen 1580 times across 336
</span><span class='ec-lmr-8'>files</span></p><!-- l. 247 --><p class='indent'><span class='footnote-mark'><a href='#fn13x2-bk' id='fn13x2'><sup class='textsuperscript'>13</sup></a></span><span class='ec-lmr-8'>The term "final" is in quotes, since the Windows 2000 source contains the mention </span><span class='lstinline'><span class='ec-lmtt-8'>BUGBUG</span></span>
<span class='ec-lmr-8'>7436 times across 2263 files, a testatment to the constant state of unfinishedness that some software
</span><span class='ec-lmr-8'>might remain in.</span></p>
<!-- l. 249 --><p class='indent'>     <span class='footnote-mark'><a href='#fn14x2-bk' id='fn14x2'><sup class='textsuperscript'>14</sup></a></span><span class='ec-lmr-8'>Allgeier, Bastian et. al., https://github.com/getkirby/kirby, 2011, consulted in
</span><span class='ec-lmr-8'>2022</span></p>
<!-- l. 249 --><p class='indent'>     <span class='footnote-mark'><a href='#fn15x2-bk' id='fn15x2'><sup class='textsuperscript'>15</sup></a></span><span class='ec-lmr-8'>https://trends.google.com/trends/explore?date=all&amp;q=kirby%20cms</span></p>
<!-- l. 249 --><p class='indent'>     <span class='footnote-mark'><a href='#fn16x2-bk' id='fn16x2'><sup class='textsuperscript'>16</sup></a></span><span class='ec-lmr-8'>https://forum.getkirby.com</span></p>
<!-- l. 249 --><p class='indent'>     <span class='footnote-mark'><a href='#fn17x2-bk' id='fn17x2'><sup class='textsuperscript'>17</sup></a></span><span class='ec-lmr-8'>https://github.com/getkirby/kirby</span></p>
<!-- l. 306 --><p class='indent'>     <span class='footnote-mark'><a href='#fn18x2-bk' id='fn18x2'><sup class='textsuperscript'>18</sup></a></span><span class='ec-lmr-8'>See, for instance, JavaDocs, or ReadTheDocs</span></p>
<!-- l. 322 --><p class='indent'>     <span class='footnote-mark'><a href='#fn19x2-bk' id='fn19x2'><sup class='textsuperscript'>19</sup></a></span><span class='ec-lmr-8'>“ Wherever computer centers have become established, that is to say, in countless places in
</span><span class='ec-lmr-8'>the United States, as well as in virtually all other industrial regions of the world, bright young
</span><span class='ec-lmr-8'>men of disheveled appearance, often with sunken glowing eyes, can be seen sitting at
</span><span class='ec-lmr-8'>computer consoles, their arms tensed and waiting to fire their fingers, already poised
</span><span class='ec-lmr-8'>to strike, at the buttons and keys on which their attention seems to be as riveted as a
</span><span class='ec-lmr-8'>gambler’s on the rolling dice. When not so transfixed, they often sit at tables strewn with
</span><span class='ec-lmr-8'>computer printouts over which they pore like possessed stu­dents of a cabalistic text.”
</span><span class='ec-lmr-8'>(</span><span class='cite'><span class='ec-lmr-8'>[</span><span class='ec-lmbx-8'>?</span><span class='ec-lmr-8'>]</span></span><span class='ec-lmr-8'>)</span></p>
<!-- l. 324 --><p class='indent'>     <span class='footnote-mark'><a href='#fn20x2-bk' id='fn20x2'><sup class='textsuperscript'>20</sup></a></span><span class='ec-lmr-8'>“HACKER [originally, someone who makes furniture with an axe] n. 1. A person who
</span><span class='ec-lmr-8'>enjoys learning the details of programming systems and how to stretch their capabilities, as opposed
</span><span class='ec-lmr-8'>to most users who prefer to learn only the minimum necessary. 2. One who programs
</span><span class='ec-lmr-8'>enthusiastically, or who enjoys programming rather than just theorizing about programming.”
</span><span class='ec-lmr-8'>(</span><span class='cite'><span class='ec-lmr-8'>[</span><span class='ec-lmbx-8'>?</span><span class='ec-lmr-8'>]</span></span><span class='ec-lmr-8'>)</span></p>
<!-- l. 324 --><p class='indent'>     <span class='footnote-mark'><a href='#fn21x2-bk' id='fn21x2'><sup class='textsuperscript'>21</sup></a></span><span class='ec-lmr-8'>See Rosenbaum’s report in the October 1971 issue of Esquire for an account of phreaking,
</span><span class='ec-lmr-8'>computer hacking’s immediate predecessor</span><span class='cite'><span class='ec-lmr-8'>[</span><span class='ec-lmbx-8'>?</span><span class='ec-lmr-8'>]</span></span><span class='ec-lmr-8'>.</span></p>
<!-- l. 324 --><p class='indent'>     <span class='footnote-mark'><a href='#fn22x2-bk' id='fn22x2'><sup class='textsuperscript'>22</sup></a></span><span class='ec-lmr-8'>A meritocratic stance which has been analyzed in further in </span><span class='cite'><span class='ec-lmr-8'>[</span><span class='ec-lmbx-8'>?</span><span class='ec-lmr-8'>]</span></span></p>
<!-- l. 326 --><p class='indent'>     <span class='footnote-mark'><a href='#fn23x2-bk' id='fn23x2'><sup class='textsuperscript'>23</sup></a></span><span class='ec-lmr-8'>“Unix has become well entrenched in the nation’s colleges and universities due to Western
</span><span class='ec-lmr-8'>Electric’s extensive, inexpensive licensing of the system. As a result, many of today’s graduating
</span><span class='ec-lmr-8'>computer scientists are familiar with it.” (</span><span class='cite'><span class='ec-lmr-8'>[</span><span class='ec-lmbx-8'>?</span><span class='ec-lmr-8'>]</span></span><span class='ec-lmr-8'>)</span></p>
<!-- l. 332 --><p class='indent'>     <span class='footnote-mark'><a href='#fn24x2-bk' id='fn24x2'><sup class='textsuperscript'>24</sup></a></span><span class='ec-lmr-8'>For a lyrical account of this perception of the hacker ethos, see </span><span class='ec-lmri-8'>The Conscience of a
</span><span class='ec-lmri-8'>Hacker</span><span class='ec-lmr-8'>, published in Phrack Magazine: “ This is our world now... the world of the electron and the
</span><span class='ec-lmr-8'>switch, the beauty of the baud. We make use of a service already existing without paying for what
</span><span class='ec-lmr-8'>could be dirt-cheap if it wasn’t run by profiteering gluttons, and you call us criminals. We
</span><span class='ec-lmr-8'>explore... and you call us criminals. We seek after knowledge... and you call us criminals.”
</span><span class='ec-lmr-8'>(</span><span class='cite'><span class='ec-lmr-8'>[</span><span class='ec-lmbx-8'>?</span><span class='ec-lmr-8'>]</span></span><span class='ec-lmr-8'>)</span></p>
<!-- l. 332 --><p class='indent'>     <span class='footnote-mark'><a href='#fn25x2-bk' id='fn25x2'><sup class='textsuperscript'>25</sup></a></span><span class='ec-lmr-8'>Those program texts include computer viruses, worms, trojan horses and injections,
</span><span class='ec-lmr-8'>amongst others.</span></p>
<!-- l. 334 --><p class='indent'>     <span class='footnote-mark'><a href='#fn26x2-bk' id='fn26x2'><sup class='textsuperscript'>26</sup></a></span><span class='ec-lmr-8'>Along with the address of the software corporate giant Meta’s headquarters: 1, Hacker Way,
</span><span class='ec-lmr-8'>Menlo Park, CA 94025, U.S.A.</span></p>
<!-- l. 346 --><p class='indent'>     <span class='footnote-mark'><a href='#fn27x2-bk' id='fn27x2'><sup class='textsuperscript'>27</sup></a></span><span class='ec-lmr-8'>Hackers themselves tend to favor puns—the free software GNU project is a recursive
</span><span class='ec-lmr-8'>acronym for </span><span class='ec-lmri-8'>GNU’s Not UNIX</span><span class='ec-lmr-8'>.</span></p>
<!-- l. 352 --><p class='indent'>     <span class='footnote-mark'><a href='#fn28x2-bk' id='fn28x2'><sup class='textsuperscript'>28</sup></a></span><span class='ec-lmr-8'>Influential langugage designer, who worked on Scheme, ECMAScript and Java, among
</span><span class='ec-lmr-8'>others.</span></p><!-- l. 358 --><p class='indent'> <span class='footnote-mark'><a href='#fn29x2-bk' id='fn29x2'><sup class='textsuperscript'>29</sup></a></span><span class='ec-lmr-8'>See:     </span><a class='url' href='https://en.wikipedia.org/wiki/Kolmogorov_complexity'><span class='ec-lmtt-8'>https://en.wikipedia.org/wiki/Kolmogorov_complexity</span></a></p>
<!-- l. 358 --><p class='indent'>    <span class='footnote-mark'><a href='#fn30x2-bk' id='fn30x2'><sup class='textsuperscript'>30</sup></a></span><span class='ec-lmr-8'>From Succesful Language Design, Brian Kernighan at the University of Nottingham,</span>
<a class='url' href='https://www.youtube.com/watch?v=Sg4U4r_AgJU'><span class='ec-lmtt-8'>https://www.youtube.com/watch?v=Sg4U4r_AgJU</span></a></p>
<!-- l. 397 --><p class='indent'>    <span class='footnote-mark'><a href='#fn31x2-bk' id='fn31x2'><sup class='textsuperscript'>31</sup></a></span><span class='ec-lmr-8'>For an example fo such one-liner, see for instance:    </span><a class='url' href='https://www.youtube.com/watch?v=0yKwJJw6Abs'><span class='ec-lmtt-8'>https://www.youtube.com/watch?v=0yKwJJw6Abs</span></a></p>
<!-- l. 405 --><p class='indent'>    <span class='footnote-mark'><a href='#fn32x2-bk' id='fn32x2'><sup class='textsuperscript'>32</sup></a></span><span class='ec-lmr-8'>The Quake developers aren’t the authors of that function—the merit of which goes to Greg
</span><span class='ec-lmr-8'>Walsh—but are very much the authors of the comments.</span></p>
<!-- l. 429 --><p class='indent'>     <span class='footnote-mark'><a href='#fn33x2-bk' id='fn33x2'><sup class='textsuperscript'>33</sup></a></span><span class='ec-lmri-8'>what the fuck? </span><span class='ec-lmr-8'>indeed</span></p>
<!-- l. 431 --><p class='indent'>     <span class='footnote-mark'><a href='#fn34x2-bk' id='fn34x2'><sup class='textsuperscript'>34</sup></a></span><span class='ec-lmr-8'>For an example, see </span><span class='ec-lmri-8'>Elevated</span><span class='ec-lmr-8'>, programmed by iq, for a total program size of 4 kilobytes:</span>
<a class='url' href='https://www.youtube.com/watch?v=jB0vBmiTr6o'><span class='ec-lmtt-8'>https://www.youtube.com/watch?v=jB0vBmiTr6o</span></a></p>
<!-- l. 445 --><p class='indent'>    <span class='footnote-mark'><a href='#fn35x2-bk' id='fn35x2'><sup class='textsuperscript'>35</sup></a></span><span class='ec-lmr-8'>You can find </span><span class='ec-lmri-8'>Elevated</span><span class='ec-lmr-8'>’s technical presentation here:</span>
<a class='url' href='https://www.iquilezles.org/www/material/function2009/function2009.pdf'><span class='ec-lmtt-8'>https://www.iquilezles.org/www/material/function2009/function2009.pdf</span></a></p>
<!-- l. 445 --><p class='indent'>    <span class='footnote-mark'><a href='#fn36x2-bk' id='fn36x2'><sup class='textsuperscript'>36</sup></a></span><span class='ec-lmr-8'>In architecture, such technical and artistic feat for its own sake, devoid of any reliable social
</span><span class='ec-lmr-8'>use, is the pavillion, or the folly.</span></p>                                                                               </div>
                                                                  

                                                                  
 
</body> 
</html>