\chapter{Aesthetic ideals in programming practices}

The first step in our study of aesthetics in source code aims at identifying the aesthetic ideals that programmers ascribe to source code. To that end, we first start by clarifying whom we refer to by this term, which in turn reveals a multiplicity of practices and purposes that exist, from \emph{ad hoc}, one-line solutions, to printed code and distributed codebases.

We then turn to the kinds of beauty that these programmers aspire to. After expliciting our methodology of discourse analysis, we engage in a review of the various kinds of publications and writings that programmers write, read and refer to when it comes to qualifying their practice. From this will result a clust of adjectives—e.g. \emph{clean}, \emph{simple}, \emph{smelly}—which we argue are used in an aesthetic sense. These will provide a useful framework to inspect, in subsequent chapters, their formal manifestations as typed-out tokens.

From these, we can then move to a description of which aesthetic fields are being referenced by programmers on a broader level, and consider how multiple kinds of beauties, from functional beauty, to literary, architectural and mathematical conceptions of beauty can overlap and be referred to by the same concrete medium.

Finally, we focus our attention on one of the points of overlap in these different references: the importance of craft and knowledge in the disposition and representation of code. We will show how this particular way of working  plays a central role in an aesthetic approach to sourec code and results from the specificity of code as a cognitive material, a specificity we will inquire further about in the next chapter.

\section{The practice of programmers - 20p}

The history of software development is that of an elite, reserved practice which was born in the aftermath of the second world war, to trickle down to broader and broader audiences at the eve of the twenty-first century. Through this development, multiple practices, approaches and applications have been involved with software, resulting in different communities and types of programming. Each of these focus on the description of specific instructions to the computer. To do so, we take a socio-historical stance on the field of programming, highlighting that diverse practices emerge at different moments in time, and are as such connected to their contemporary technical and economic organizations.

Even though such types of reading and writing source code often overlap with one another, this section will highlight a diversity iof ways in which code is being apprehended, notably in terms of references, purposes and examples. In the following, we highlight loose areas within which individuals write code. First, we take a look at the software industry, to identify professional \emph{software developers}, the large code bases they work on and the specific organizational practices within which they produce software. They are responsible for the majority of source code written today, and do so in a professional and productive context, where maintanainability, testability and reliability are main concerns. Then, we turn to a parallel practice, one that is often exhibited by software developers, who often take on the stance of \emph{hackers}. Disambiguating the term reveals a set of practices where curiosity, cleverness, and idiosyncracy are central, finding unexpected solutions to complex problems, sometimes within artificial constraints. In guise of bookends, we look at \emph{scientists} and \emph{poets}. On one end, \emph{scientists} embody a rather academic approach,  focusing on abstract concepts such as simplicity and minimalism; they are often focused on theoretical issues, such as implementation of mathematical algorithms and models, and programming language design. On the other end, \emph{poets} read and write code first and foremost for its textual and semantic qualities, publishing code poems online and in print, and engaging deeply with the range of metaphors allowed by a dynamic linguistic medium such as code.

While this overview encompasses most of the programming practices, we leave aside some approaches to code, mainly because they do not directly engage with the representation of source code as a textual matter. More and more, end-user applications provide the possibility to program in more or less rudimentary ways, and thus contributing to the blurring of boundaries between programmers and non-programmers\footnote{For instance, Microsoft's Visual Basic for Applications, Ableton's Max For Live, MIT's Scrath or McNeel's Grasshopper are all programming frameworks which are not covered within the scope of this study. In the case of VBA and similar office-based high-level programming, it is because such a practice is a highly personal and \emph{ad hoc} one, and therefore is less available for study.}.

\subsection{Software developers - 6p}

\begin{itemize}
    \item knuth
    \item clean code
    \item djikstra
\end{itemize}

\subsection{Hackers - 6p}

\begin{itemize}
    \item paul graham
    \item unix hackers, wizards staying up late, bazaar and cathedral
    \item montfort, box darkly
    \item "You can create art and beauty on the computer"
    \item tinkerers and amateurs
\end{itemize}

\subsection{Scientists - 4p}

\begin{itemize}
    \item PL \& algo implementers
    \item textbooks
    \item data scientists
\end{itemize}

\subsection{Poets - 4p}

\begin{itemize}
    \item history of creative coding
    \item digital art vs. software art
    \item code poets
\end{itemize}


\section{Ideals of beauty - 15p}

\subsection{Introduction to the Methodology - 3p}

Kintsch and Van Dijk

\subsection{Lexical Field in Programmer Discourse -12p}

Positive words (13p)

\begin{itemize}
    \item clean
    \item simple
    \item elegant
    \item transparent/self-explanatory
\end{itemize}

Negative words (2p)

\begin{itemize}
    \item smelly
    \item entangled
\end{itemize}

\section{Types of beauty  - 20p}

Now that we've done some empirical work, we can try to abstract away a bit and then look into how this relates to existing frameworks of aesthetics. 

Now that \emph{we look at proofs, through discourse}, what kind of beauty can we be dealing with?

\subsection{Functional beauty}

This first approach, by comparing both source and comment at the same time (taking texts which are explicitly described as being beautiful), explicitly highlights the requirements for source code to be beautiful. 

There is also an emerging development in aesthetics of integrating function as a criteria for an aesthetic experience.

\subsection{Literary Beauty}

This second approach contrasts with the functional component of the first one, but nonetheless stands in relationship with it. the creative beauty, by defying traditional beauty standards, does help us highlight, through deviance, what the norm is. These texts on "creative beauty" include the classical perl poetry, code poems, IOCC, code poetry contest, etc.

\subsection{Mathematical beauty}

Mostly elegance, could be a good place to work on the distinction between proof and theorem, concept and appearance.

\subsection{Architectural beauty}

This allows a segway into everyday aesthetics and environmental aesthetics

\section{Craft and beauty - 10p}

Now that we've seen how the aesthetic ideals of code borrow from different registers, we need to think about practice, or ways. all of the above can be seen through the prism of craft

\subsection{Embodiment}

also note the place and role of tools (IDEs, teletypes, fast compiling, etc.)

\subsection{Tacit knowledge}

