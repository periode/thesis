\chapter{Conclusion}
\label{chap:conclusion}

%
% BITCH BE HUMBLE
%
% this is supposed to specify what we have found, why it's valuable, how it can be applied, what is new and exciting
% his will show how it has made a valid, and useful, contribution to knowledge.

% WHAT DO METAPHORS OF ARCH/LIT/MATH/ENG HIGHLIGHT OR HIDE ABOUT CODE? HOW APPLICABLE ARE THEY? HOW SYSTEMATIC? ARE THEY REINFORCING OR SUBVERTING EACH OTHER?

% _reflective equilibrium_ rawls and goodman on how to balance intuition with inquisition

A piece of source code, as the linguistic representation of computational processes, themselves representations of a problem domain, is an ambiguous object. Such an object exists at the overlap of both human and machine comprehension, operates through un-intuitive scales of time and space, and is often hidden away by the executed processes of which it is the source. And yet, source code practitioners, those who write and read code, agree on the existence of a certain sense of \emph{beauty} in program texts.

The research aims of this thesis were to highlight the specific aesthetic properties exhibited by varieties of source code. How does source code beauty manifest itself? Under which conditions? And to what end? Answering these questions, we showed how other aesthetic fields are used as metaphors in the aesthetic appreciation of source code and we identified the role aesthetics play in the existence and purpose of source code—with a particular focus on its role as a cognitive facilitato, and on its relationship to function. Our methodology started from an empirical approach, looking at specific instances of source code, and from the analysis of the discourses surrounding and commenting these instances. From this initial study, we identified several lexical fields that programmers refer to when they evoke the aesthetic properties of source code—literature, architecture, mathematics and craft.

Along with this first research axis, we also noted how the aesthetic judgement in source code is closely tied to its fuctionality. Indeed, any aesthetic value is dependent on the correct behaviour of the source code; ugly code is often related to its apparent bugginess and difficulty in understanding its function, while beautiful code implies that the actions resulting from the source code are conform to what the programmer had intended, along with being presented in the best possible way.

Such a definition of a \emph{best possible way} is dependent on the social, cultural and economic spheres within which the code is produced. These include the social environment of the programmer(s), the technical environment in which the code is run and built, and the problem it aims at solving. Similarly, the concept of function within program texts has been shown to also be multifaceted, includin what the code should do, what it actually does, and how it does it.

The aesthetic properties of source code are therefore those of a semantic representation of computational space-time, whose purpose is the effortless communication of the operations of the computer, the intention of the programmer(s) and the representation of the world. In this sense, aesthetics perform a cognitive function.

\section{Findings}
\label{sec:findings}

The rest of this conclusion will address each of our initial research questions' findings, followed by an examination of the limitations and contributions to existing research on source code. Throughout, we will summarize how our comparative approach highlighted medium-specific aesthetic devices whose function is to engage epistemically with their audience.

\subsection{What does source code have to say about itself?}
\label{subsec:conclusion-rq-1}

One of the gaps we identified in source code-related literature is that there was a missing overlap between a broad empirical approach and a robust conceptual framework, expliciting the nature of source's code properties. For instance the works of \citep{paloque-berges_poetique_2009,cox_speaking_2013,black_art_2002} establish an overview of source code with explicit aesthetic properties, but rely on a remediating approach to assess source code as a literary-semantic tool, or as a discursive-political object, respectively, all the while focusing on the subset of so-called creative code. We intended to complement this initial work by highlighting source-code-specific aesthetics—that is, formal manifestations with a communicative purpose, beyond a strictly literary perspective.

Starting from trade literature on the topic, and complementing it by cases of close-reading program-texts, we have highlighted both structural and contextual specificities of source code. Building on existing work across disciplines, such as Martin (see \ref{subsubsec:crafting-software}), Gabriel (see \ref{subsec:patterns-structures}), Lakoff and Johnson (see \ref{subsec:metaphor-computation}) or Détienne (see \ref{subsec:psychology-programming}), we have found several properties which seem to be unique to source code, and supports a conception of source code as a material used to construct dynamic semantic spaces.

First, \emph{conceptual distance} is key at a structural level: correlated expressions, statements or variables that affect or depend on the same concept (e.g. a file operation or a user account), should be located close to one another in the source code. This counterbalances the entropic tendency of source code to tangle itself, such that the reader has to follow the convoluted machine path of execution, rather than the human conceptual grouping of executable statements.

The \emph{conceptual coherence}, and thus its ease of understandability, is also manifested in conceptual atomicity and conceptual symmetry, respectively meaning that a given explicit fragment of source code should only refer to one specific operation, at a given level of abstraction, and that fragments of source code that do similar things should look similar as well. Also previously identified as \emph{separation of concerns}, these two principles allow for the abstraction of a given syntactic unit by grouping all the statements into a single action or declaration, thus operating as a bridge between human understanding and machine understanding.

At the lexical level, source code is multi-dimensional. On the one hand, it operates on an axis that goes from \emph{global} to \emph{local}, whereby global tokens that are used, and are visible, across the whole application code are very explicitly named, sometimes in all uppercase, while local tokens, whose lifetime does not exceed a few lines, tend to be composed of just a few letters. Here, variable length and cap size is closely related to the concept of \emph{scope}, yet in a slightly looser way than from a strict programming language perspective. On the other hand, lexical tokens can belong to three different lexical fields. These lexical fields are whether a given token refers to (1) an individual meaning, (2) a machine meaning, or (3) a domain meaning. For instance, the names \lstinline{start_time}, \lstinline{UTC_UNIX_STRING_NOW} and \lstinline{meeting_time} might all refer to the same moment in time, yet from different perspectives. The first naming, as an individual meaning, is significant in a narrow context, for a narrow set of individuals at the moment of writing or reading. The second naming is a machine meaning, which refers to how that moment is perceived by the computer. The third is the domain meaning, which is how end-users will refer to that particular moment. The use of a different names to refer to a single entity has also shown that metaphor theory comes into play.

For some, a piece of source code which can choose a token that will balance these three meanings in order to convey these three senses of the value at hand will be considered aesthetically pleasing. For others, writing tokens at the extreme of either of these three poles can be considered as a marker of aesthetic success, accompanied by a certain degree of expertise. For instance, code poets would tend to focus on the domain meaning, in which tokens are only referring to non-computing terms, and evoke poetic concepts instead. Conversely, hackers share a standard for brevity and directness—by making their tokens as short as possible, e.g. reducing them to bytecode, they strive towards existing as close as possible to the hardware that the code depends on, and therefore display unsual feats of performance.

As source code gets closer to the hardware, the representation of its semantics change. Aesthetics move away from surface and towards depth, and human-readable names disappear. So, while syntax such as names and comments might be beacons with an aesthetic potential, positively-valued structural arrangements subsist in a different form. One form of structure, such as the files and folders organization of some codebases, create a sense of familiarity in the situated programmer, as seen in \ref{subsubsec:compression-habitability}. However, we can also note that structure can evoke less-human concepts, and  be considered aesthetic insofar as they present a stimulating mental puzzle where  the discovery of the program text's computational function is the ultimate reward, as discussed in \ref{subsec:hackers}. For instance, the program text presented in \ref{code:0x31} displays an aesthetic structure, independent from syntax. It seems at first very cryptic, but nonetheless exhibits a certain regularity and symmetry in its layout.

Published in \emph{xchg rax, rax}, a collection of riddles in the Assembly language, this seemingly cryptic example allows us to show that, while no arbitrary names are used, structure nonetheless survives \citep{xorpd_xchg_2014}. Borrowing from poetry's lexicon, we can identify four stanzas, twice of four lines, and twice of a single line. Syntactically, one can easily spot the repeating of a pattern, with a mirrored relationship between \lstinline{rcx} and \lstinline{rdx}, two of the CPU's memory registers where temporary information is stored. The first stanza raises a given number to the exponential of itself, bitshifted to the right (\lstinline{x^(x>>1)}). The second increases the original number, the third stanza repeats the first operatio with the previous number and the last, concluding line calculates the \lstinline{xor} result. The 3-1-3-1 repeating pattern and the similar registers being used across stanzas makes it such that, at first glance, its structure evokes the concept of reflection and symmetry.

\begin{listing}
    \inputminted{asm}{./corpus/riddle_0x31.asm}
    \caption{This Assembly listing represents a pair of numbers as reflected binary numbers, and then performs a logical \lstinline{xor} operation on a pair of numbers. The structure of the program text itself, through its symmetry, hints at the patterns exhibited by such reflected binary encoding \citep{xorpd_xchg_2014}.}
    \label{code:0x31}
\end{listing}

Semantically, \ref{code:0x31} tells another story. The semantics of this program text is to compute the exclusive OR of two consecutive reflected binary codes. The binary reflected code, also called Gray Code, is a way to represent binary numbers in such a way that incrementing from one number to another only changes one byte. Following this notation, incrementing from 1 to 2 would be written from 001 to 011 rather than from 001 to 010\footnote{For more details on how this particular program text does its encoding, see \citep{sanchez_solutions_2016}}.

This kind of binary number representation relies on a linear increment which exhibits further structural properties. For instance, reflected binary numbers are used in electronic and digital communications, as well as signal processing, in order to reduce errors in information analysis (since only one bit changes from one binary number to the next, it becomes easier to trace through linear changes and catch mistakes). For instance, this particular snippet could be used to detect if there was an error in an encoding of information by acting as a test control: since it calculates the exclusive or of two consecutive numbers, there should only ever be a single \lstinline{1} in the result, and any more or less flipped bits would indicate an error in the processing.

However, like the aesthetics of mathematics, we here start from this somewhat simple syntactical representation, followed by a changing of the scale at which it operates, in order to grasp a more complex, yet highly regular, structure. In fact, such a structure is used in puzzles like the Towers of Hanoi, or the Chinese rings puzzle, and is an example of combinatorial algorithms \citep{knuth_art_2011}, reconnecting the hacker aesthetic to a certain kind of playfulness. Through a poetry-like layout and with a mathematical intent at evoking complex numerical concept, a seemingly simple program text allows us, with a subset of source code aesthetics, to grasp a complex computational structure. Away from names and human idiosyncracies, aesthetics persist.

The name Assembly, the language in which \ref{code:0x31} is written, also evokes hints of craft, and program texts in Assembly are often referred to as "hand-crafted". As we showed in \ref{subsubsec:crafting-software}, with craft comes communities of practice. Such communities are also an influence on what is to be considered aesthetically pleasing code.  With a strong ethos of craft running as a thread throughout each of these identified communities (see \ref{chap:ideals}), well-written code is \emph{idiomatic code}. This implies that the reader and the writer both possess some knowledge of the specificities of the language or hardware that the code is being written with and executed with. While skilled work is often related to a positive appreciation of the result, craft also includes a conception of being usable.

This social existence of code and its connection to skilled work also led us to examine the role of \emph{style}. Style, in this case, is valued positively when it represents the acknowledgment of the social existence of code: by choosing style as a group marker rather than as an individual marker, a source code is judged positively based on its altruistic ethical nature.

More fundamentally, the aesthetic properties of source code are derived from a conception of code as a semantic material which in terms is assembled, and apprehended, as a spatial construct, rather than a strictly literary, mathematical, or architectural material. Code \emph{navigation}, code \emph{structure} or code \emph{compression}, are terms which all belong to a lexical field of spatiality, whether visible or not; the aesthetic properties of source code are tightly related to this apprehension and revealing of conceptual spaces constructed from machine-readable lexical tokens represeting problem domains—or, in other words, \emph{thought-stuff} \citep{brooksjr_mythical_1975}.

\subsection{How does source code relate to other aesthetic fields?}
\label{subsec:conclusion-rq-2}

Aesthetic properties of source code were deduced from an empirical approach. We identified the different lexical fields that programmers referred to as they justified their aesthetic judgments on program texts. Specifically, we have identified how references to other fields of activity were used as a metaphorical device in order to better qualify source code (e.g. "source code is \emph{like} literature\dots").

Literature acts as a metaphor for source code through the mapping of linguistic tokens as the building blocks of both natural language texts and program texts (see \ref{sec:aesthetic-literature}), while the architecture metaphor includes spatiality and habitability, along with an explicit dimension of function (see \ref{sec:arch-understanding}) and the mathematics metaphor works through a mapping on abstract conceptual structures and strive for elegance (see \ref{sec:aesthetic-scientific}). We saw that the metaphorical mapping of each of these source domains ultimately reveal and hide particular aspects and aaffordances of source code.

Literary aesthetics facilitate the comprehension of the scope of variables and of the intent of the programmer in relation with the problem domain. They denote the purpose and intent of specific values, expressions, declarations and statements in a natural language, with a potential both for poetic evokation, cryptic obfuscation, or plain misinterpretation. Despite Yukihiro Matsumoto and Donald Knuth's statements that writing source code is a literary art \citep{knuth_literate_1984,matsumoto_treating_2007}, this turns out to only be partially true: the most literary parts of source code—comments—are also the parts that are the most decoupled from the actual source code, and are entirely invisible to the machine.

A strictly literary understanding of source sets aside the particularities of the reading process of source code and the temporal control of the writer. A traditional, natural language literary work will assume a linear, front-to-back readership, while source code is defined by its potential ability to jump from any part of the text to any other part of the text. Given this radical difference, references to architectural aesthetics help to establish structural patterns of familiarity and spatiality. Even though it does not operate on concrete, "natural" space, the quality of the disposition and combination of the application components on the source code page enable a better navigation of the source code's conceptual space. Furthermore the metaphor of code as literature also hides the differences in authorship: literature often assumes a single author, while code is in majority written collaboratively, in such an intertwined way that it is complicated to attribute the origin of program texts to a single person (as in the tracing of the authorship of \ref{code:fast_sqrt_c}), a complication which increases with time and the modification of program texts.

This reduction of a vast conceptual space to natural language representations, and presented as clear, delimited set of interrelated components reveals the tension in source code between form, function, and the fundamental concepts of computation. In this respect, mathematical aesthetics enable the condensation of knowledge and insight in the least amount of tokens, minimizing noise, and related to poetic expression. Particularly, this ability of representing complex ideas into simple terms is a process of \emph{compression} shared across poetry, architecture and mathematics, and resulting in an elegant structure.

% architecture: structure, function and craft.
The architectural metaphor of source code further confirms this structural aspect nature of source code. In architecture, a building ultimately enables flows of people within a static configuration. Similarly, one can consider source code as the static structure within which the dynamic processes of computation are executed, as illustrated by the term \emph{control flow} or \emph{leaky abstractions}. In a sense, then, source code can be considered as the blueprint of software, just as a floorplan can be considered the blueprint of a building—even if such floorplan, in this case, would need to be at the 1:1 scale. Structure for computational processes, then, but also structure for humans. As discussed in \ref{subsubsec:compression-habitability}, the formal arrangement of source code which enables a programmer to inhabit it, to feel at ease in reading and modifying such source code is also positively valued. The structural metaphor of architecture thus works at these two levels.

The maxim \emph{form follows function} emanates from the field of architecture and therefore allows us to highlight the requirement of function in the definition of source code aesthetics. software needs to be functional in order to be aesthetically judged, and aesthetics facilitate the programmer's understanding of what a program text's function is. This functional aspect also corresponds to a distinction between the essential and the superfluous or, in architectural terms,, between the decorative and the load-bearing. In both architecture and programming, there are aguments being made for the decorative, as a communicative device for a human touch, while the load-bearing element maps to the elegant engineer, the rather impersonal construction which can nonetheless do the most with the least.

Finally, thinking of code as architecture allows us to highlight the notion of craft in the appreciation of well-written source code. Software craftsmanship is both an approach to detail as a particular relationship to material, tools and knowledge. It is a pendant to an overall architectural structure in which a bird's eye view of folder, files, variables and function declarations can provide a grasp of the overall arrangement and style of the software described by the program text. At the micro-level, an architectural approach to source code raises the question of its status as matter to which one can shape into functional structures. The carefully assembling of a program text, by programmers as craftpersons, ultimately reveals the materiality of source code as a medium. A crafted program text takes source code as a material; a cognitive material, but a material nonetheless, a kind of \emph{thought-stuff}. The attention to detail, superfluous for the amateur practitioner, nonetheless communicates a certain kind of know-how (see \ref{subsec:knowing-what-how}) in the places where one can express their individuality, or focus on a more impersonal and altruistic approach, thus displying a deep understanding of what they are doing.

% mathematcs: depth of engagement, intellectual reward, 
This cognitive element is further revealed by the mathematical metaphor. The most obvious connection is through the common use of a formal syntax in order to express complex concepts. While initially terse and foreign, such a language enables a certain kind of play. One can reduce an expression, replace its terms, consider problems from a different angle, at different scales, under different conditions. etc. This play with symbols reveals a certain malleability and modularity of its object, and further supports our approach of code as a cognitive material. As shown in \ref{subsubsec:beauty-mathematics}, aesthetics in source code, as in mathematics, can be seen as both a by-product and a goal to be reached, implying a certain ideal formal configuration of symbols for a given problem. Conversely, this relationship with cognition also operates at the earlier stages of writing code: as a heuristic, a positive aesthetic judgment on a work-in-progress leads the programmer and the mathematician alike in the right direction of a correctly functioning program text or demonstration.

Most visible in the hacker aesthetic \ref{subsec:hackers}, code as mathematics makes obvious the relationship of aesthetics with intellectual engagement. Whether it is to understand certain subtleties at the algorithm design level, at the programming language use level, or at the hardware configuration level, aesthetics have the function of communicating the author's knowledge to the reader, either by making the syntactic representation the simplest possible, while not compromising with the integrity of the underlying concepts or by making this representation so obfuscated that these formal arrangements anounce a pleasurable brain-twisting puzzle. In any case, the aesthetic experience of code, just like the aesthetic experience of mathematics is not one which relies on immediate, emotional reaction. Rather, it demands from the reader a focused attention and cognitive abilities of modelling the space time of a program text; in turn these two requirements are impacted by formal arrangements, making concepts harder or easier to grasp.

Aligning with the conceptions of code as literature and code as architecture is that of \emph{elegance}. We defined in \ref{sec:ideals-beauty} the notion of elegance, from poetry to engineering, as the ability to do the most with the least. Mapping these aesthetic metaphors onto soure code confirmed that a program text written in a way that uses the minimum amount of required tokens in order to perform the fullest version of its function is one of the most praised aesthetic abilities. Robust, sparse and straightforward program text is considered a beautiful achievement, one in which function, structure and skill are intertwined to produce the most with the least. Here, this definition of "the most" is not only one based on quantitative performance such as CPU cycles, but also on its easing of the cognitive burden in understanding and engaging with the technical object that is source code.

However, what the mathematical metaphor does not show is the relationship between elegance and context. What "the minimum required" and what "the fullest version of its function" depend on various factors, from external technical requirements, programming language, number and skill of collaborators, etc., something which mathematics, in its presentation as a \emph{lingua unversalis}, sets aside.

Overall, then, the overlap of these metaphors have led us to identify two main aspects: semantic compression and spatial exploration. Semantic compression concerns the ability of a notation to express complex concepts through quantitatively and qualitatively simple combination, while spatial exploration concerns the ability of source code to be structured in such a way that is both evocative (the broad shape of things have a relative connotation to what these things can do) and sustainable (the structuring of a function ensures that a given action will not have unexpected side-effects), with the ultimate purpose of facilitating the navigation of program texts by the programmer. Furthermore, rather than being opposites of one another, each reference contributes to the purpose of source code aesthetics by clarifying the structure of the code at multiple levels and dimensions.

Ultimately, all of these elements thus relate to communication and cognition, and to how the (invisible) purpose and intent of the code can be communicated in (visible) lines of a language straddling the line between machine and human comprehension. Literature, architecture, mathematics and engineering all rely on a set vocabulary to enable through understanding; their efficiency at doing so can be assessed by the reader's correct or erroneous estimation of what are the fundamental concepts of what is being communicated to them. Keywords, tokens and beacons are all elements which have been found to structure the writing and reading of source code, allow the programmer to establish a cognitive map of the abstract structure of the program text.

\subsection{How do the aesthetics of source code relate to its functionality?}
\label{subsec:conclusion-rq-3}

This final correlation of aesthetics with the communication of intent and purpose now leads us to address our third research question: the connections between form and function in source code. We have shown that, in the case of software engineers, aesthetics can be used to facilitate understanding in a functional context, or that, in the case of hackers, aesthetics can be a display of a deep understanding of the material at hand. As for scientists and poets, aesthetics perform a role of compression of complex concepts (be they scientific or poetic) into a concrete form. Aesthetics are both conditioned to, and signifiers of function.

However, the most crucial aspect of the aesthetics of source code is that they any positive evaluation is negatively affected if the executed code does not perform as intended, such as if there is a mismatch between what the original programmer(s) intended, and how the actual machine behaves. There is very little guarantee of such a synchronization: the programmer might say something and the machine do something different, and it is not \emph{clear} what or where exactly is that difference. In this case, the program text, as the only component of software taken into account by the computer, is also the only canonical source of investigation into fulfilling the functional nature of the program.

In this sense, the quality of an aesthetic property (e.g. consistence or coherence) can be judged on whether it adequately represents a given concept, behaviour or intent. The unique aspect of this aesthetic judgment of source code is that there are indeed two judges: the human(s) and the machine, whereby the possibility for human assessment is dependent on a presupposed machine assessment. In all the different groups of writers identified, \emph{correctness} always conditions \emph{pleasantness}.

This is verified only to a certain extent for poets, whom do not require a program text to be productive in order to be given an aesthetic value. Still, in the case that the poet does write a syntactically correct text from a machine perspective, and a semantically evocative text from a human person, the artistic quality of the work created emanates from this technical feat. Traditionally, the effect is similar: by respecting particular formats (e.g. the sonnet, the haïku or the alexandrine verse), the poet displays technical virtue along with emotional sublimation. One understanding of the poem's functioning (rather than its producing) is how each chosen words manage to fulfill the expectation of the technical form and the evocative content. One might say that a particular choice of word or line "works" at a certain location but "doesn't work if moved at another part of the poem.

Poems also perform a kind of function that is not as immediately productive as a database query. By joining the technical and the emotional, they perform a more symbolic function about the space of possibilities and the space of the thinkable given to humans. The poet's dual display of skill relates to a conception of art as a connection between the technological and magical highlighted in subsection \ref{subsubsec:software-relational}. Displaying artistic creativity within source code can thus be seen as a way to enchant the technology of software, by representing it as a technically excellent crafted object, imbued with poetic expressivity.

This tight coupling of function and appearance, something already very present in architectural aesthetics (see section \ref{sec:arch-understanding}), also echoes with Nelson Goodman's theory of art as composed of a language system used to express complex ideas (see \ref{subsec:source-code-language-art}), and practices of craft and toolmaking (see \ref{subsubsec:crafting-software}). Source code, while remaining subject to function, nonetheless allows for a certain versatility in the expression of the concept (ranging from explicit to implicit); in turn, this expressivity depends on a given level of skill and practice in the idiosyncracies of the programming languages used and the programming communities in which the source code is written (see \ref{subsec:style-idioms-programming}). The proficiency in a language involves a "right way to do things", resulting in "things looking good", and hints at the fact that there is a certain level of expertise needed to assess the quality of the aesthetic properties of a program text, and that the novice cannot be expected to provide an informed aesthetic value judgment.

\section{Contribution}
\label{sec:conclusion-contribution}

Overall, this thesis has aimed at showing that the specific formal properties of source code have a functional pupose of enabling epistemic action based on understanding of a machine language and a problem domain, itself conjugated in various contexts.

Source code, as the base of software, belongs first and foremost to the technological realm, embodying a function and an intent of what should be achieved. Its aesthetics are thus inscribed within this technological essence by enabling the communication of the complex ideas which constitute the basis of software (its ideal version, as opposed to its implemented version, and its process of implementation, as opposed to its result).

While psychological studies and consolidated practical knowledge have shown that particular kinds of layout and presentation are beneficial to program understanding (see section \ref{subsec:psychology-programming}), this is only one aspect of the system of aesthetic properties. Aesthetic values in source code are also based on the context in which said source code is written or read. These values, while varying, are nonetheless recurrently depending on a skilled relation with the program, the machine, and the audience of the program, as well as the intent of the use.

In order to achieve this epistemic function, and due to software's ambiguous nature as an \emph{abstract artifact} (see \ref{subsubsec:abstract-artifact}), a variety of aesthetic domains are summoned by programmers in order to make sense of what they describe as occurences of software beauty. Looking specifically at the overlap of these domains, we have shown that each aim at facilitating a transition between the surface-level syntax immediately accessible to the reader to the deep-level semantics of the topic at hand. Respectively, literature aims at evoking themes and narratives (section \ref{sec:aesthetic-literature}), architecture aims at evoking atmospheres and functions (section \ref{sec:arch-understanding}), while mathematics tries to communicate theorems (\ref{sec:aesthetic-scientific}) and engineering focuses on structural integrity and efficiency (\ref{subsec:aesthetics-heuristics}), with all domains above modulated by an approach to craft as a personal, hands-on skill.

From the perspective of aesthetic theory, these findings also contribute to a conception of aesthetics as a communicative endeavour. Specifically, we have shown that the concept of aesthetics amongst programmers is not seen exclusively as autotelic, but rather as a possible means to accurately represent \emph{something} to \emph{someone}, which falls in line with the works of Goodman and Parsons and Carlson \citep{goodman_languages_1976,parsons_functional_2012}. As such, source code aesthetics acts as an expressive interface between a concept, a technology and two distinct individuals. Located within the particular techno-social environment of source code, this communicative role is also subject to relatively clear assessments of success or failure. A successful communication is a communication which is correctly interpreted, whereby the original ideas transmitted from the writer via the program text are found in an equivalent representation in the reader, and enable further effective action. Here, the interpretation is, at minima, what the program does, and what the program intents to do, things that might not always be aligned, resulting in the provision of agency in correctly predicting the implications of the program's operations and in the ability to correctly modify the program.

The contributions of this thesis have therefore been in the development of an aesthetic understanding of source code through an interdisciplinary analysis of a discourse analysis, drawing across media studies (from literature to software studies), science and technology studies and aesthetic philosophy. These discourses were composed of a corpus of both program-texts and commentaries and analyses by practitioners of those program texts—analyzing 65  selected source code snippets. In this sense, we have extended on the contributions of Paloque-Bergès and MacLean and Cox by applying on their concepts of \emph{double-meaning}  and \emph{double-coding} and showing how this co-existence of computer meaning and human meaning extends beyond the more creative writings of source code, and across communities of source code writers (see \ref{subsec:humans-machines}).

In doing so, we have also confirmed and extended Piñeiros' work on describing code aesthetics as instrumental action, bridging his field of research of software developers with other kinds of source code, and confronting it with specific example. While Piñeiro's work thoroughly explores programmers' perspectives and discourses, it does not extend its findings to other aesthetic practices mentioned by programmers—by connecting it to related field, we inscribe the practice of programming within a wider field of creative practices.

We proposed a conceptualization of code as semantic matter, from which executable structures are built. This approach builds on Katherine Hayles' distinction between the media properties of print and code—the former being flat, the latter being deep—and has shown the aesthetic implications of such a distinction. The contribution was to enrich our understanding of what code depth is made of, and how surface-level syntactical tokens enable the creation of deep conceptual structures.

Based on Cayley's scalar approach, we offered a typology of aesthetic properties in code, based on the purpose of aesthetics as a communicative endeavour with specific outcomes (see \ref{subsec:matters-of-scale}). At the level of structure, we saw that folder and file structure first provided a macro level of familiarity with the kind of application being developed, relying on convention and \emph{family resemblance}, that data modelling offered an expressive way to communicate the important aspects of the problem domain being operated on, and that groups of statements resulted both in local coherence of operations and conceptual symmetry as these operations were repeated across the program text. At the syntax level, it is the programming language which influences the aesthetic experience of the programmer, by involving both idiomatic writing and linguistic references, as a way to demonstrate concise and precise knowledge of ones tool. Finally, the level of vocabulary enables the most expressiveness for the programmer, with both typographical parameters such as character length and casing, but also grammatical parameters, such as naming functions as verbs and variable as nouns, ultimately enabling a practice of \emph{double-meaning}.

This complements the perspectives provided in Oram and Wilson's edited volume \citep{oram_beautiful_2007}. Instances of beautiful code have been given a practical framework as a way to idenfity positive aesthetic properties, beyond their praise by highly-skilled professionals.

Through an empirical take, we have also qualified how Florian Cramer and his approach to source code as a form of magic relies on very concrete technical processes and habits across practices of source code writing. Building on the work of Alfred Gell describing art as the enchantment of technology, we have explicited what exactly are the complex technical hurdles and associated skills required to understand software (section \ref{subsec:software-complexity}). If there is magic in software, it is also manifested through the artistic appreciation of source code, particularly through hacking (section \ref{subsec:hackers}) and code poetry (section \ref{subsec:poets}), and examplified in works like \lstinline{forkbomb.pl} (see listing \ref{code:forkbomb}).

\begin{listing}
    \inputminted{perl}{./corpus/forkbomb.pl}
    \caption{forkbomb.pl is an artwork in the exhibited sense of the term, displaying conciseness and metaphorical expression along with expressive power through its technical expansion, all the while breaking the expectation for a program not to overload the hardware on which it runs.}
    \label{code:forkbomb}
\end{listing}

In fact, \lstinline{forkbomb.pl} is a program whose function is to replicate itself until the computer on which it run crashes. By subverting the expectation of what a functional artefact should do, what is allowed, and what is not, this program text suggests more fundamental questions about what we expect from automatic productive processes. Nonetheless, it also gains artistic value from using the aesthetic devices of compression and double meaning, particularly in the use of \lstinline{my $strength} variable name.

Finally, this thesis has contributed to a text-based approach to software aesthetics, as compared to execution-based approaches, in which source code syntax and semantic tend to be secondary. Within those studies of code-dependent aesthetics, such as interface design \citep{fishwick_aesthetic_2002} or creative coding \citep{cox_aesthetic_2020}, the aim was to provide an account of what code, considered as the material of software, offers in terms of representational specificities to enrich and complement those studies. Without directly contradicting any of the work mentioned in our literature review (see \ref{subsec:literature-review}), our conclusions offer a detailed account of the material origins upon which subsequent interpretations of code are based.

\subsection{Limitations}
\label{subsec:conclusion-limitations}

The first and most obvious of the limitations of this work is that a lot of source code is not accessible. While originally a freely-circulating commodity, the emergence of proprietary software at the dawn of the 1980s (see \ref{subsec:software-developers}) has drastically limited free and open access to source code. As such, most of the source code written by software engineers in a commercial context remains confidential. For hackers, due to the nature of the work as an \emph{ad hoc} and localized practice, few examples are made publicly available, as they are often enmeshed in more commercial projects, themselves subject to property restrictions, or in personal, \emph{ad hoc} projects.

A second limitation is the expertise level required not just in programming, but in idiomaticity—that is, in knowing how to best phrase an action in a specific languages, as addressed in subsection \ref{subsec:style-idioms-programming}—and, to a lesser extent, in the relevant problem domains. This implication of having already a solid grasp on the technical and problem context for an aesthetic judgment can have affected the accuracy of the analyses that I have given in this thesis. Consequently, it is inevitable that other experts programmers might have different opinions given their personal styles and backgrounds.

Finally, our focus on the knowledge-component of both aesthetics and source code has led us to venture into the application of cognitive sciences to fields such as programming, literature or architecture. Since this is still a burgeoning endeavour of active research,  some of the connections evoked by the current literature between code and cognition, or beauty and cognition are still bound to evolve.

\section{Opening}
\label{sec:opening}

Grounded in media studies and aesthetic philosophy, this thesis has nonetheless aimed at expanding the domain of what is traditionally considered beautiful, and how it is considered so, by examining the relations between beauty, function and knowledge in the specific medium of source code. Drawing on an interdisciplinary approach, the outcomes of this research therefore have some impact  on both the arts and sciences in general, and programming in particular.

Deliberately eschewing notions of the artistic in favor of the beautiful, the definition work at the beginning of this thesis implicitly hypothesized that studies of beauty decoupled from art can be rich and fruitful, revealing a plethora of practices focusing on making something nice, rather than, e.g., sublime. This thesis is therefore inscribed in aesthetics of the everyday, and would suggest ways to apply aesthetic judgments to objects of study usually excluded from the aesthetic realm. Additionally, we have shown how such an object—source code—possess mechanics of meaning-making of their own, enabling unique semantic structures.

We also consider implications for programmers and craftspeople. Not that they need this work to realize that aesthetics and functionality are deeply intertwined, but rather as an explicit account of the ways in which this entanglement happens. For programmers, keeping in mind notions of scale, distance and metaphor within a particular source code would support better work. For other creators, we hope this would encourage them to investigate what is it that makes their material unique, and how it relates to other disciplines, and how formal arrangements  can be rigorously thought about, as an effective communication medium.

Ultimately, this work also has ethical implication. Knowledge, by enabling one's agency, supports and encourages good work, as opposed to meaningless labour. By organizing program texts in such a way that the next individual can discover and understand underlying concepts transmitted through the medium of source code, and then build on and complement this knowledge with their own contribution, one engages in an ethically altruistic behaviour, as opposed to self-reflexive references.

\spacer

In closing, we see two main directions which can spring form this thesis, exploring the intricacies of ciomputer-readable knowledge management, and the worldmaking of code.

The unfolding of digital media in the second half of the twentieth century has been seen as an epochal shift, along with other technologies of information reproduction and diffusion. However, computational media is specific insofar as it can be compressed and presented under various forms (from electricity to three-dimensional graphical environments and highly-dimensional vector spaces in recent machine learning approaches). How does the shape of software impact knowledge management and transmission, not just for programmers, but for end users as well, starting from those in the information sciences such as librarians, educators, journalists, researchers, and expanding to anyone engaging in a meaning-making work within a computer environment. While aesthetics can help to signify complex concepts within source code, do those concepts translate at other interface levels, or do these subsequent levels hold aesthetics principles of their own? How can the malleability of code help understanding at various levels of representation?

In terms of worldview, or how the particular structure of a text has a particular effect on an audience, the question would be to which extent does source code structure model and affect the "real world"\footnote{Throughout this work, we have been referring to the "real world" as the problem domain.}. Particularly in terms of  time and space, as we have seen how the execution of source code engages in a deeply different scale of both of these components of our experience of reality. In terms of modelling, we could ask does a particular data structure, in how it is written, reveal social, political and economical agency? To what extent do languages such as Rust, Java or JavaScript influence the programmer's perception of the world? What is the worldview of a compiler? Could that effective impact be observed in an empirical manner? This move from static form to dynamic action would look at code's consequences beyond programmers and towards society at larg, all the while remaining grounded in a materialist approach. This relationship between form-giving and meaning-making in digital environments might start with those who write source code and compose electrical circuits, but ultimately affect all whose lives are tangled with computers.
