\chapter{Conclusion} %30k - 5-7% of total

%
% BITCH BE HUMBLE
%
% this is supposed to specify what we have found, why it's valuable, how it can be applied, what is new and exciting
% his will show how it has made a valid, and useful, contribution to knowledge.

A piece of source code, as the lexical representation of computational processes, themselves representations of worldly matters, is an ambiguous object. Such an object exists at the overlap of both human and machine comprehension, and is often hidden away by the executed processes of which it is the source. And yet, source code practioners, those who write and read code, agree on the existence of a certain sense of \emph{beauty} in source code.

The research aims of this thesis were to highlight the origins and implications of the aesthetic properties exhibited by varieties of source code. That is, we intended to show how aesthetic properties relate to other aesthetic fields, and what role they played in the existence and purpose of source code—with a particular focus on its relationship to function. Our methodology started from an empirical approach of looking at specific instances of source code, and on analyzing of the discourses surrounding and commenting these instances. From this initial study, we identified several lexical fields that programmers refer to when they evoke the aesthetic properties of source code—literature, architecture, mathematics and craft.

Along with this first research axis, we also noted how the aesthetic judgement in source code is closely tied to its fuctionality. Indeed, any aesthetic value is dependent on the correct behaviour of the source code; ugly code is related to its apparent bugginess and difficulty in engaging with it, while beautiful code implies that the actions resulting from the source code are conform to what the programmer had intended, along with being presented in the best possible way\footnote{Such a definition of a \emph{best possible way} is dependent on the social, cultural and economic spheres within which the code is produced.}. The aesthetic properties of source code are therefore those of a semantic representation of computational space-time, whose purpose is the effortless communication of the operations of the computer, the intention of the programmer(s) and the representation of the world.

The rest of this conclusion will address each of our initial research questions' findings, followed by an examination of the limitations and contributions to existing research on source code.

\subsubsection{What does source code have to say about itself?} %5k

One of the gaps we identified in source code-related literature is that there was a missing overlap between a broad empirical approach and a robust conceptual framework, expliciting the nature of source's code properties. for instance the works of \citep{paloque-berges_poetique_2009,cox_speaking_2013} establish an overview of source code with explicit aesthetic properties, but rely on a remediating approach to assess source code as a literary-semantic tool, or as a discursive-political object, respectively. We intended to complement this initial work to highlight source-code-specific aesthetics—that is, formal manifestations with a communicative purpose.

Starting from trade literature on the topic, and complementing it by cases of close-reading, we have highlighted both structural and contextual specificities to source code. Building on existing work, we have found several properties which seem to be unique to source code. Altogether, these properties support our theory of source code as a material used to construct dynamic semantic spaces.

\emph{Conceptual distance} is key at a structural level: correlated expressions, statements or variables that affect or depend on the same concept (e.g. a file operation or a user account), should be located close to one another in the source code. This counterbalances the entropic tendency of source code to tangle itself, such that the reader has to follow the convoluted machine path of execution, rather than the human conceptual grouping of executable statements.

\begin{listing}
    insert example / comparison here
\end{listing}

The conceptual coherence, and thus its ease of understandability, is also manifested in \emph{conceptual atomicity} and \emph{conceptual symmetry}, respectively meaning that a given explicit fragment of source code should do only one thing and do it well, and that fragments of source code that do similar things should look similar as well. Also previously identified as \emph{separation of concerns}, these two principles allow for the abstraction of a given syntactic unit by grouping all the statements into a single action or declaration.

At the lexical level, source code operates on a multi-dimensional level. On the one hand, it operates on an axis that goes from \emph{global} to \emph{local}, whereby global tokens that are used, and are visible, across the whole application code are very explicitly named, sometimes in all uppercase, while local tokens, whose lifetime does not exceed a few lines, tend to be composed of just a few letters. Here, variable length and cap size is closely related to the concept of \emph{scope}, yet in a slightly looser way than from a strict programming language perspective. On the other hand, lexical tokens can belong to three different lexical fields. These lexical fields are whether a given token refers to (1) an individual meaning, (2) a machine meaning, or (3) a domain meaning. For instance, the names \lstinline{start_time}, \lstinline{UTC_UNIX_STRING_NOW} and \lstinline{meeting_time} might all refer to the same moment in time, yet from different perspectives. The first naming, as an individual meaning, is significant in a narrow context, for a narrow set of individuals at the moment of writing or reading. The second naming is a machine meaning, which refers to how that moment is perceived by the computer. The third is the domain meaning, which is how users (and not writers or readers of source code) will refer to that particular moment.

For some, a piece of source code which can choose a token that will balance these three meanings in order to convey these three senses of the value at hand will be considered aesthetically pleasing. For others, writing tokens at the extreme of either of these three poles can be considered as a marker of aesthetic success and expertise. For instance, code poets would tend to focus on the domain meaning, in which tokens are only referring to non-computing terms, evoke poetic concepts insted. Conversely, hackers share a standard for brevity and directness—by making their tokens as short as possible, e.g. reducing them to bytecode, they strive towards existing as close as the hardware the code will run on, and therefore display unsual feats of performance.

This context-sensitiveness brings us to another aspect of source code—that it is eminently dependent on communities of practice to establish what is beautiful code. With a strong ethos of craft running as a thread throughout each of these identified communities\footnote{Software engineers, scientists, hackers and poets}, well-written code is \emph{idiomatic code}. This implies that the reader and the writer both possess some knowledge of the specificities of the language or hardware that the code is being written with and executed with. This approach to craft thus resonates with a concept of mastery and technical excellence, but also with that of \emph{style}. Style, in this case, highlights the acknowledgment of the social existence of code: by choosing style as a group marker rather than as an individual marker, a source code is judge positively based on its altruistic ethical nature—even if that style is enforced by software itself.

In this research, we have shown that code exhibits specific aesthetic properties, whether they are judged as being positive or negative. We have also shown that these positive or negative judgments are themselves the results of specific communities of practices—argumenting for a social conception of an aesthetic value judgment.

More fundamentally, the aesthetic properties of source code are derived from a conception of code as a semantic material which in terms is assembled, and apprehended, as a spatial construct, rather than a strictly literary, mathematical, or architectural material. Code \emph{navigation}, code \emph{structure} or \emph{code} compression, are terms which all belong to a lexical field of spatiality; the aesthetic properties of source code are tightly related to this apprehension of conceptual spaces constructed from machine-readable lexical tokens represeting problem domains—or, in other words, \emph{thought-stuff} \citep{brooks_mythical_1975}.

\subsubsection{How does source code relate to other aesthetic fields?} % 5k

These aesthetic properties were formalized through an empirical approach, whose first stage included the identification of the different lexical fields that programmers referred to in order to justify their aesthetic judgments of source code. Specifically, we have identified references to literature, architecture, mathematics and engineering. Each of these were used as a metaphorical device in order to better qualify source code (e.g. "source code is \emph{like} literature\dots").

To which aspect of source code did these references map to? Overall, we have identified two main aspects: semantic compression and spatial expression. Semantic expression concerns the ability of a notation to express complex concepts through quantitatively and qualitatively simple combination, while spatial expression concerns the ability of source code to be structured in such a way that is both evocative (the broad shape of things have a relative connotation to what things do) and sustainable (the structuring of a function ensures that a given action will not have unexpected side-effects).

All of these references point to the fact that structure and expressivity are closely tied when it comes to source code. Furthermore, rather than being opposites of one another, each reference contributes to the purpose of source code aesthetics by clarifying the structure of the code at multiple levels and dimensions.

Literary aesthetics facilitate the comprehension of the scope of variables and of the intent of the programmer in relation with the problem domain. They denote the purpose and intent of specific values, expressions, declarations and statements in a natural language, with a potential both for poetic evokation, cryptic obfuscation, or plain misinterpretation. Despite Yukihiro Matsumoto and Donald Knuth's statements that writing source code is a literary art, this turns out to only be partially true: the most literary parts of source code—comments—are also the parts that are the most decoupled from the actual source code, and are entirely invisible to the machine.

A strictly literary understanding of source sets aside the particularities of the reading process of source code and the temporal control of the writer. A traditional, natural language literary work will assume a linear, front-to-back readership, while source code is defined by its potential ability to jump from any part of the text to any other part of the text. Given this radical difference, references to architectural aesthetics help to establish structural patterns of familiarity and spatiality. Even though it does not operate on concrete, "natural" space, the quality of the disposition and combination of the application components on the source code page enable a better navigation of the source code's conceptual space.

This reduction of a vast conceptual space to natural language representations, and presented as clear, delimited set of interrelated components  reveals the tension in source code between form, function, and the fundamental concepts of the function. In this respect, mathematical aesthetics enable the condensation of knowledge and insight in the least amount of tokens, minimizing noise, and related to poetic condensation. Particularly, this ability of representing complex ideas into simple terms is a process of \emph{compression} shared across poetry and mathematics, and resulting in an elegant structure.

This concept of elegance is also found at an overlap of mathematics and architecture, in the form of engineering. Robust, sparse and straightforward engineering is considered a beautiful achievement, one in which function, structure and skill are intertwined to produce the most with the least. Here, this definition of "the most" is not one based on performance or CPU cycles\footnote{As mentioned previously, the most efficient code is machine generated and human-unreadable.}, but rather on its easing of the human's cognitive burden in understanding and engaging with the technical object that is source code.

Ultimately, all of these elements relate to communication and cognition, and to how the (invisible) purpose and intent of the code can be communicated in (visible) lines of a language straddling the line between machine and human comprehension. Literature, architecture, mathematics and engineering all rely on formal tokens to refer to \emph{something else}, and their efficiency at doing so can be assessed by the reader's correct or erroneous estimation of what are the fundamental concepts of what is being communicated to them. Keywords, tokens and beacons are all elements which have been found to structure the writing and reading of source code, allow the programmer to establish a cognitive map of the abstract structure of the program text.

\subsubsection{How do the aesthetics of source code relate to its functionality?} %5k

This final correlation of aesthetics the communication of intent and purpose now leads us to address our third research question: the connections between form and function in source code. we have shown that, in the case of software engineers, aesthetics can be used to facilitate understanding in a functional context, or that, in the case of hackers, aesthetics can be a display of a deep understanding of the material at hand. As for scientists and poets, aesthetics perform a role of compression of complex concepts (be they scientific or poetic) into a concrete form.

However, the most crucial aspect of the aesthetics of source code is that they are rendered moot if the executed code does not perform as intended. In this case, there is a mismatch between what the original programmer(s) intended, and how the actual machine perfomance. This actuality can be referrenced in comments or documentations\footnote{Such as "TODOs" notes or open issues in tracking software.}, but lacks any guarantee of synchronization: the programmer might say something and the machine do something different, and it is not \emph{clear} what exactly is that difference. In this case, the program text, as the only component of software taken into account by the computer, is also the only canonical source of investigation into restoring the nature of the programmer—its function.

In this sense, the quality of an aesthetic property can be judged on whether it adequately represents a given concept, behaviour or intent\footnote{These are indeed three different things, but all involve some sort of some aspect of being remote for direct grasp.}. The unique aspect of this aesthetic judgment of source code is that there are indeed to judges: the human(s) and the machine, whereby the possibility for human assessment is dependent on the machine assessment. In all the different groups of writers identified, \emph{correctness} always conditions \emph{pleasantness}.

This is only verified to a certain extent for poets, who do not require a program text to be functional in the machinic sense in order to be given an aesthetic value. Still, in the case that the poet does write a syntactically correct text from a machine perspective, and a semantically evocative text from a human person, the artistic quality of the work created emanates from this technical feat. This dual display of skill relates to a conception of art as a connection between the technological and magical highlighted in subsection \ref{subsec:software_relational}. Displaying artistic creativity within source code can thus be seen as a way to enchant the technology of software, by representing it as a technically excellent crafted object.

This tight coupling of function and appearance, something already very present in modernist architecture and explored in section \ref{sec:arch_understanding}, echoes across theories of art as a language system used to express complex ideas, and practices of craft and toolmaking. Source code, while remaining subject to function, allows for a certain versatility in the expression of the concept (ranging from explicit to implicit) and, in turn, this expressivity depends on a given level of skill and practice in the idiosyncracies of the languages used. Related to our findings on the diversity of communities who read and write code, these communities are defined based on the purpose of the code they write, but there also exists a set of communities which are organized around the specific language that they use. The proficiency in a language involves a "right way to do things", and hints at the fact that there is a certain level of expertise is needed to assess the quality of the aesthetic properties of a source, and that the novice cannot be expected to provide an informed aesthetic value judgment.

\section{Contribution}  %6k

Overall, this thesis has aimed at showing that the formal properties of source code as a specific medium have a close relationship to \emph{episteme}, itself conjugated in various contexts.

Because software, underpinned by source code, belongs first and foremost to the technological realm, embodying a function and an intent of what should be achieved, aesthetics are inscribed within this technological essence by enabling the communication of the complex ideas which constitute the basis of software (its ideal version, as opposed to its implemented version, and its process of implementation, as opposed to its result).

While psychological studies and consolidated practical knowledge have shown that particular kinds of layout and presentation are beneficial to program understanding (see section \ref{sec:psychology-programming}), this is only one aspect of the system of aesthetic properties. Aesthetic values in source code are also based on the \emph{context} in which said source code is written or read. These values, while varying, are nonetheless recurrently depending on the relation with the program, the machine, and the audience of the program, as well as the intent of the use.

In order to achieve this epistemic function, and due to software's ambiguous nature as an \emph{abstract artifact}, a variety of aesthetics domains are summoned by programmers in order to make sense of what they describe as occurences of software beauty. Looking specifically at the overlap of these domains, we have shown that each aim at facilitating a transition between the surface-level syntax immediately accessible to the reader to the deep-level semantics of the topic at hand. Respectively, literature aims at evoking themes and stories (section \ref{sec:aesthetic-literature}), architecture aims at evoking atmospheres and functions (section \ref{sec:arch_understanding}), while mathematics tries to communicate theorems (\ref{sec:aesthetic-mathematics}) and engineering focuses on structural integrity and efficiency (\ref{sec:aesthetic-engineering}), with all domains above modulated by an approach to craft.

From the perspective of aesthetic theory, these findings also contribute to a conception of aesthetics as a communicative endeavour. Specifically, we have shown that the concept of aesthetics amongst programmers is not seen exclusively as an end to all things, but rather as a possible means to represent \emph{something} to \emph{someone}. As such, aesthetics acts as an expressive interface between a concept and two distinct individuals\footnote{The assumption specific to source code being that the same individual differs over time.}. Located within the particular techno-social environment of source code, this communicative role is also subject to relatively clear assessments of success or failure. A successful communication is a communication which is correctly interpreted, whereby the original ideas transmitted from the writer via the program text are found in an equivalent representation in the reader. Here, the interpretation is, at minima, what the program does, and what the program intents to do, things that might not always be aligned, resulting in the provision of agency in correctly predicting the implications of the program's operations and in the ability to correctly modify the program.

The contributions of this thesis have therefore been in the development of an aesthetic understanding of source code through an interdisciplinary analysis of a discourse analysis, drawing across media studies (from literature to software studies), science and technology studies and aesthetic philosophy. These discourses were composed of a corpus of both program-texts and commentaries and analyses by practicioners of those program texts—reading and analyzing  XXXX INSERT EXACT NUMBER XXXX selected source code snippets. In this sense, we have extended on the contributions of Paloque-Bergès and MacLean and Cox by applying on their concepts of \emph{double-meaning} and showing how this co-existence of computer meaning and human meaning extends beyong the more creative writings of source code, and across communities of source code writers.

In doing so, we have also confirmed and extended Piñeiros' work on describing code aesthetics as instrumental action, bridging his field of research of software developers with other kinds of source code, and confronting it with specific example. While Piñeiro's work thoroughly explores programmers' perspectives, it does not extend its findings to other aesthetic practices mentioned by programmers—by connecting it to literature, architecture, mathematics and engineering, we inscribe the practice of programming within a wider array of creative practices.

I proposed a conceptualize of code as semantic matter, from which executable structures are built. This approach builds on Katherine Hayles' distinction between the media properties of print and code—the former being flat, the latter being deep. The contribution was to enrich our understanding of what code depth is made of, and how syntactical tokens create conceptual structures.

I offered a typology of how to exert aesthetic properties in code, based on the purpose of aesthetics as a communicative endeavour with specific outcomes. This complements the perspectives provided in the Oram and Wilson's edited volume \citep{oram_beautiful_2007}. Instances of beautiful code have been given a theoretical framework as a criterai for belonging to the category of exhibiting positive aesthetic properties, beyond their praise by highly-skilled practitioners.

Through an empirical take, we have also qualified how Florian Cramer and his approach to source code as a form of magic relies on very concrete technical processes and habits across practices of source code writing. Building on the conception of Alfred Gell of art as the enchantment of technology, we have explicited what exactly are the complex technical hurdles and associated skills required to understand software (section \ref{subsec:software-complexity}). If there is magic in software, it is also manifested through the aesthetic appreciation of source code, particularly through hacking (section \ref{subsec:hackers}) and code poetry (section \ref{subsec:poets}), and examplified in works like \lstinline{forkbomb.pl} (see listing \ref{code:forkbomb}).

\begin{listing}
    \inputminted{perl}{./corpus/forkbomb.pl}
    \caption[]{forkbomb.pl is an artwork in the exhibited sense of the term, displaying conciseness along with expressive power through its technical expansion}
    \label{code:forkbomb}
\end{listing}

Finally, this thesis has contributed to a text-based approach to software aesthetics, as compared to execution-based approaches, in which source code syntax and semantic tend to be set aside. Within those studies of code-dependent aesthetics, such as interface design \citep{fishwick_aesthetic_2001} or creative coding \citep{cox_aesthetic_2020}, the aim was to provide an account of how code, the material itself, offers in terms of representational specificities to enrich those studies.

Without directly contradicting any of the work mentioned in our literature review (see \ref{subsec:literature-review}), our conclusions offer a detailed account of the material origins upon which subsequent interpretations of code are based.

\subsection{Limitations}

The first and most obvous of this limitation is that a lot of source code is not accessible. While originally a freely-circulating commodity, the emergence of proprietary software at the dawn of the 1980s \citep{hassett_impact_2012} has drastically limited free and open access to source code. As such, most of the source code written by software engineers in a commercial context remains confidential. For hackers, due to the nature of the work as an \emph{ad hoc} and localized practice, few examples are made publicly available, as they are often enmeshed in more commercial projects, themselves subject to property restrictions.


A second limitation is the expertise level required not just in programming, but in idiomaticity—that is, in knowing how to best phrase an action in a specific languages, as addressed in subsection \ref{subsec:idiomaticity}—and, to a lesser extent, in the relevant problem domains. This implication of having already a solid grasp on the technical and problem context can have affected the expositions of aesthetic judgments that I have given in this thesis. Consequently, it is inevitable that other experts programmers might have different opinions given their personal styles and backgrounds.

Finally, our focus on the knowledge-component of both aesthetics and source code has led us to venture into the application of cognitive sciences through empirical studies to fields such as programming, literature or architecture. Since this is still a burgeoning endeavour, in active research,  some of the connections evoked by the current literature between code and cognition, or beauty and cognition are still bound to evolve.

\section{Opening}

Firmly grounded into aesthetic philosophy, this thesis has nonetheless aimed at expanding the domain of what is traditionally considered beautiful, and how it is considered so, by examining its relations with function and knowledge. Resulting from an interdisciplinary approach, the outcomes of this research therefore have some impact  on both the arts and sciences in general, and programming in particular.

Deliberately eschewing notions of the artistic in favor of the beautiful, the definition work at the beginning of this thesis implied that studies of beauty decoupled from art can be rich and fruitful, revealing a plethora of practices focusing on making something nice, rather than, e.g., gorgeous. This thesis is therefore inscribed in aesthetics of the everyday, and can suggest ways to apply aesthetic judgments to objects of study usually excluded from such. Additionally, we have shown how such objects—source code—possess mechanics of meaning-making of their own, enabling unique semantic structures.

Conversely, we also consider implications for programmers and craftspeople. Not that they need this work to realize that aesthetics and functionality are deeply intertwined, but rather as an explicit account of the ways in which this entanglement happens. For programmers, keeping in mind notions of scale, distance and metaphor within a particular source code would support better work. For other creators, we hope this would encourage them to investigate what is it that makes their material unique, and how it relates to other disciplines.

Ultimately, this work also has ethical implication. Knowledge, by enabling one's agency, supports and encourages good work, as opposed to meaningless labour. By organizing program texts in such a way that the next individual can discover and understand underlying concepts transmitted through the medium of source code, one engages in an ethically altruistic behaviour, as opposed to self-reflexive references.

\vspace{1\baselineskip}
\centerline{\rule{0.13334\linewidth}{.4pt}}
\vspace{2\baselineskip}

In closing, we see two main directions which can unfold form this thesis, either exploring the poetics of code, or the intricacies of cimputer-readable knowledge management.

The unfolding of digital media in the second half of the twentieth century has been seen as an epochal shift, along with other technologies of information reproduction and diffusion. However, computational media is specifici insofar as it can be compressed and unfolded under various forms (from electricity to three-dimensional graphical environments and highly-dimensional vector spaces in recent machine learning approaches). How does the shape of software impact knowledge management and transmission, not just for programmers, but for end users as well, starting from those in the information sciences such as librarians, educators, journalists, researchers, and expanding to anyone engaging in a meaning-making work within a computer environment. While aesthetics can help to signify complex concepts within source code, do those concepts translate at other interface levels, or do these subsequent levels hold aesthetics principles of their own?

In terms of poetics, or how the particular structure of a text has a particular effect on an audience, the question would be to which extent does source code structure model and affect the "real world"\footnote{Throughout this work, we have been referring to the "real world" as the problem domain.}. Particularly in terms of  time and space, as we have seen how the execution of source code enegage in a deeply different scale of both components of our experience of reality. In terms of moddelling, we could ask does a particular data structure, in how it is written, reveal social, political and economical agency? To what extent do languages such as Rust, Java or JavaScript influence the programmer's perception of the world? Could that effective impact be observed in an empirical manner? This move from form to consequence would look at an impact beyond programmers and at a broader audience. This relationship between form-giving and meaning-making in digital environments might start with those who write source code and compose electrical circuits, but affect all who engage with computers.