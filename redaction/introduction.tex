\section{Introduction}

This thesis is an inquiry into the formal manifestations of source code and how particular configurations of lines of code allow for aesthetic judgments. The implications of this inquiry will lead us to consider the different ways in which people who read and write code, and through these, we will explore the different ways in which source code can be represented, depending on what it aims at communicating.
This study on source code involves the different groups of people which read and write it, the purposes for which they write it, the languages they use to write it, and the language they use to speak about it. Most importantly, this thesis focuses on source code as a material, linguistic manifestation of a larger digital ecosystem of software and hardware to which it belongs. Since source code isn't code, as we will see below, this thesis also aims at studying the reality of written code, rather than its conceptual interpretations.

Starting from pieces of source code, henceforth called \emph{program texts}\cite{detienne_software_2012}, this thesis will aim at assessing what programmers have to say about it, and attempt to identify one or more specific \emph{aesthetic registers}. This aim depends on two facts: first, source code is a medium for expression, both to express the programmer's intent to the computer\cite{dijkstra_chapter_1972} and the programmer's intent to another programmer\cite{abelson_structure_1979}. Second, source code is a relatively new medium of expression, compared to either fine arts or engineering practices. As a recent medium for expression, the development and solidification of aesthetic practices—that is, of ways of doing which do not find their immediate justification in a practical accomplishment—is an ongoing research project in computer science, software development and more recent fields within the digital humanities. Formal judgments of source code are therefore existing and well-documented, and they are related to a need for expressiveness, as we will see in chapter X, but their formalization is still an ongoing process.

Source code thus has ways of being presented which are subject to aesthetic judgments by programmers; that is, code \emph{has} aesthetics, but it is unclear exactly \emph{which} aesthetics. Indeed, these aesthetic judgments as they exist today rely on different domains to assess source code, as a means to grasp the cognitive object that is software. These draw from metaphors which range from literature, architecture, mathematics and engineering. And yet, source code, while qualified on all of these, source code isn't specifically any of these. Liked the story of the seven blind men and the elephant\cite{chun_sourcery_2008}, each of these domains touch on some specific aspect of the nature of code, but none of them are enough to entirely provide a solid basis for the aesthetic judgments of source code. It is at the crossroads of these domains that this thesis locates its work.

The examination of source code, and of the discourses around source code will integrate both the myriad of ways in which source code can exist, and the invariant aspects which underline all diverse approaches of source code. Particularly, we will see how each groups of practicionners tend to deploy references to one particular set of metaphorical references drawing from the domains above, but also how these references overlap across groups. The point of overlap, as we will demontrate, is that of \emph{using a formal linguistic system to communicate the understanding of complex cognitive structures}. Relying heavily on Nelson Goodman's work on the languages of art\cite{goodman_languages_1976}, we end on connecting this to the broader role of aesthetics as a cognitive mechanism to deal with complexity.

The rest of this introduction will consist in establishing a more complete view of the context in which this research takes place, from computer science to digital humanities and science and technology studies. With this context at hand, we will proceed to highlight the specific problems which will be tackled—the current place of aesthetics in source code. After outlining our methodology and the theoretical frameworks which will be mobilized throughout this study, we will sketch out how the different chapters of this thesis will attempt at providing some responses to our research questions.

\subsection{Context - 15p}

\subsubsection{The research territory: code}

Most of our modern infrastructure depends, to a more or less dramatic extent, on computer systems\cite{kitchin_codespace_2011}, from commercial spaces to classrooms, transport systems to cultural institutions, scientific production and entertainment products. The complex processes are described in what is called source code, and the number of lines of code involved in running these processes is hard to estimate; one can only rely on disclosures from companies, and publicly available repositories. For instance, all of Google's services amounted to over two billions source lines of code (SLOC)\cite{scale_why_2015}, while the 2005 release of the OSX operating system comprised 86 millions lines of code, and while the version 1.0 of the Linux kernel (an operating system which powers most of the internet and specialized computation) totalled over 175,000 SLOC, version 4.1 jumped to over 19.5 million lines of code in the span of twenty years\cite{noauthor_linux_2021}.

Who reads this code? To answer this question, we must start diving a little bit deeper into what source code really is.

At a high-level, source code consists in a series of instructions, composed in a particular programming language, which is then processed by a computer in order to be executed. For instance, using the language called Python, the source code:

\begin{lstlisting}
    a = 4
    b = 6

    def compute(first, second):
        return (first * 2) + second
    
    compute(a, b)
\end{lstlisting}

consists in telling the computer to store two numbers in what are called \emph{variables}, then proceeds with describing the \emph{procedure} for adding the double of the first terms to the second term, and concludes in actually executing the above procedure. Given this particular piece of source code, the computer will output the number \lstinline{14} as the result of the operation \lstinline{(4 * 2) + 6}. In this sense, then, source code is the requirement for software to exist. If computers are procedural machines, acting upon themselves and upon the world, they need a specification of what to do, and this specification exists in the form of source code.

Source code is here both a requirement and a by-product, since it isn't required anymore once the computer has processed and stored it into a \emph{binary} representation, a series of 0s and 1s which represent the successive states that the computer has to go through in order to perform the action that was described in the source code. \emph{Binary code} is what most of the individuals who interact with computers deal with, and (almost) never have to inquire about, or read its source code. On one hand, then, source code only matters until it gets processed by a computer, through which it realizes its intended function.

On the other hand, source code isn't just about telling computers what to do, but also about a particular economy: that of software development. Software developers are the ones who write the source code and this process is first and foremost a collaborative endeavour. Software developers write code in successive steps, because they add features over time, or they fix errors that have shown up in their software, or they decide to rewrite parts of the source code based on new ideas, skills or preferences. In this case, source code is not used to communicate to the computer what it does, but it is used to communicated to other software developers what the \emph{intent} of the software is. Source code is then the locus of human, collaborative work; it represents iterations of ideas, formalization of processes and approaches to problem-solving.

Official definitions of source code straddle the line between the first role of source code (as instructions to a computer) and the second role of source code (as indications to a programmer). For instance, a definition within the context of the Institute of Electrical and Electronics Engineering (IEEE) is that of \emph{any fully executable description of a software system, which therefore includes various representations of this description, from machine code to high-level languages and graphical representations using visual programming languages}\cite{harman_why_2010}. This definition focuses on the ability of code to be processed by a machine, and mentions little about its readability (i.e. processability by other humans).

On the other hand, the definition of source code provided by the Linux Information Project\footnote{https://linfo.org/sourcecode.html} focuses on source code as \emph{the version of software as it is originally written (i.e. typed into a computer), by a human in plain text (i.e. human-readable, alphanumeric characters).}\cite{noauthor_source_nodate}. The emphasis here is on source code as the support of human activity, as software developers need to understand the pieces of code that they are creating, or modifying. Source code thus has two kinds of readabilities: a computer one, which is geared towards the correct execution of the program, and a human one, which is geared towards the correct understanding of the program. In the lineage of this human-readability, we can point to the Free Software Foundation's equation of the free circulation and publication of source code with the free circulation of publication of ideas. Particularly, Freedom 1 (\emph{The freedom to study how the program works, and adapt it to your needs}) and Freedom 2 (\emph{The freedom to improve the program, and release your improvements to the public, so that the whole community benefits.}\cite{stallman_free_2002}) as stated in the FSF's definition of Free Software stipulates that access to source code is required to support these freedoms, a version of source code that is \emph{not concealed}, i.e. readable by both human and machine.

In addition to this ability to communicate the ideas latent in it, source code, as an always potentially collaborative object, can be the locus multiple subjectivities coming together. As Krysa and Sedek state it in their definition, \emph{source code is where change and influence can happen}, and where \emph{intentionality and style are expressed}\cite{fuller_software_2008}. In their understanding, source code shares some features with natural languages as an intersubjective process\cite{voloshinov_marxism_1986}, and as such is different from the machine language representation of a program, an object which they do not consider source code due to its unilaterality. The intelligibility of source code, they continue, facilitates its circulation and duplication among programmers. It is this aspect of a socio-technical object that we intend to highglight.

In this research, we build on these definitions to propose the following:

\begin{quote}
    Source code is defined as one or more text files which are written by a human or by a machine in such a way that they elicit a meaningful response from a digital compiler or interpreter, and describe a software system. These text files are the starting point to produce an execution of the system described, whether the very first starting point, or an intermediate representation used for subsequent compilations. These files are called \emph{program texts}.
\end{quote}

This definition takes into account a broad view of source code, including steps such as intermediate representations (transitory representations from one version of the source to another one), but also obfuscations (deliberately complicating the code to prevent human-readability while maintaining machine-readability) and minifications (reducing the amount of characters used in source code to its minimum). This will allow us to compare human-authorship of source code, machine-authorship, and hybrid modes, in which a human writes unreadable code with the help of tools. One aspect that is being more narrowly defined for the purpose of this study is the actual manifestation of code: while multiple media for source code exist, we exclude here all of those that are not written in the UTF-8 character set—i.e. textual representations. Since one of the questions of this study is to examine the literariness of source code aesthetics, other forms of source code, such as visual programming languages or biological computation, stand outside the scope of this study and should be investigated in subsequent work.

As for the term \emph{program text}, it is chosen in order to highlight the dual nature of source code: that of a computational artefact to be formally processed and unambiguously understood, and that of a open-ended, multi-layered document, in the vein of Barthes' distinction between a text and a work\cite{barthes_bruissement_1984}.

\subsubsection{Beautiful code}

Under this definition of source code textually represented, we now turn to the existence of the aesthetics of such \emph{program texts}. To contextualize this existence, we first need to touch upon the history and practice of software development. As an economic activity, software development came from a bottom-up dynamic, a \emph{de facto} activity which was not expected in the early days of computing, where most of the work was divided between mathematics and engineering. Its earliest manifestation can be found in the physical rewiring process of mainframes in order to perform a specific computation, something more akin to firmware than to software. These rewiring tasks were done by mostly female assistants, under the direction of mostly male mathematicians\cite{chun_software_2005}, and considered a simple translation task which did not need any particular attention, or any particular skill. The recognition of software engineering as its own field came as its unique domain of expertise was required in larger engineering projects—for instance, the term \emph{software engineering} was coined in the late 1960s by Margaret Hamilton and her team as they were working on the Apollo 11 Lunar Module software\cite{mindell_digital_2011}. In the same decade, the first volume of \emph{The Art of Computer Programming}, by Donald Knuth, addresses directly both the existence of programming as an activity separate from both mathematics and engineering, as well as an activity with an "artistic" dimension\cite{knuth_art_1997}. The first volume opens on the following paragraph:

\begin{quote}
    The process of preparing programs for a digital computer is especially attractive, not only because it can be economically and scientifically rewarding, but also because it can be an aesthetic experience much like composing poetry or music. This book is the first volume of a multi-volume set of books that has been designed to train the reader in the various skills that go into a programmer's craft.\cite{knuth_art_1997}
\end{quote}

Considered one of the most canonical textbooks in the field, \emph{The Art of Computer Programming} lays out two important aspects of programming: that it can be an aesthetic experience and that it is the result of a craft, rather than of a highly-formalized systematic process. Some of the aeshetic references related to source code are related to its writing and reading being a craft-like activity\cite{dijkstra_craftsman_1982}.

Craftsmanship as such is an essentially fleeting phenomenon, a practice rather than a theory, in the vein of Michel De Certeau's \textit{tactics}, bottom-up actions designed and implemented by the users of a situation, product or technology as opposed to \textit{strategies}\cite{certeau_invention_1990}, in which ways of doing are prescribed in a top-down fashion. It is hard to formalize, and the development of expertise in the field happens through practice as much as through formal education\cite{sennett_craftsman_2009}. The domain of craft is also one in which function and beauty exist in an intricate, embodied relationship, based on subjective qualitative standards rather than strictly external measurements, with the former rarely being explicitly stated\cite{pye_nature_2008}.

Approaching programming (the activity of writing and reading code) as a craft\cite{levy_programmation_1992} connects to the multiple testimonies of encountering beautiful code, some of which have made their ways into edited volumes or monographs\cite{oram_beautiful_2007,chandra_geek_2014,gabriel_patterns_1998}. Additionally, informal exchanges among programmers on forums, mailing lists, blog posts and code repositories\footnote{Insert references about the annex here} often mention beautiful code, either as a central discussion point or simply in passing. These testimonies, from textbooks to online posts, constitute the first part of our corpus, as sources in which programmers comment on the aesthetic dimension of their practice. The second part of the corpus is composed of selected program texts, which we will examine in order to identify and formalize which aspects of the textual manifestation of software can elicit an aesthetic experience.

So the existence of something akin to art, something beautiful and pleasurable emerging from the reading and writing of source code has been acknowledged since the 1960s, in the early days of programming as a self-contained discipline. However, the formalization of an aesthetics of source code first requires a formalization of the concept of \emph{aesthetics}.

There is a long history of aesthetic philosphical inquiries in the Western tradition, from beauty as the imitation of nature\footnote{Plato}, moral purification\footnote{Aristotle, Poetics; Kant, Critique of the Power of Judgment}, cognitive perfection\footnote{Leibniz, Ars Combinatoria}, sensible representations with emotional repercussions\footnote{Baumgarten, Aesthetics}. The common point of these definitions is that of \emph{sensual manifestation}, that is the set of visible forms which can enable an \emph{aesthetic experience}, a cognitive state of pleasure relying on, amongst others, an object, a sense of unity and of discovery\cite{beardsley_aesthetic_1970}.

The definition of aesthetics that we will use in this thesis starts from this requirement of sense perception, and then builds upon it using two theoretical frameworks: Nelson Goodman's theory of symbols\cite{goodman_languages_1976} and Gérard Genette's distinction between fiction and diction\cite{genette_fiction_1993}. The former provides us with an analysis of formal systems in aesthetic manifestations and their role in a cognitive process, while the second offers a broadened perspective on what qualifies as textual arts, or literature.

Goodman's view on aesthetics is an essentially communicative one: we use art to communicate. This communication process happens through various symbol systems (e.g. pictural systems, linguistic systems, musical systems, choreographic systems), the nature and organization of which can elicit an aesthetic experience. His conception of such an aesthetic experience isn't one of self-referential composition, or of purely emotional pleasure, but a cognitive one, one which belongs to the field of epistemology\cite{goodman_languages_1976}. The symbol systems involved in the aesthetic judgment bear different kinds of relations to the worlds they refer to—such as denoting, representing, ressembling, exemplifying— and their purpose is to communicate a truth about these worlds\cite{nelson_goodman_ways_1978}. In his view, the arts and the sciences are, in the end, two sides of the same coin. They aim at providing conceptual clarity through formal, systematic means, and the arts can and should be approached with the same rigor as the sciences. Programming, with its self-proclaimed craft status, stands equally across the line divind arts and sciences.

His use of the term \emph{languages} implies a broader set of linguistic systems than that of the strictly verbal one. This approach will support our initial conception of programming languages as verbal systems, but will allow us not to remain constrained by strictly traditional verbal aesthetics such as verse, rhyme or alliteration. To what extent is programming a linguistic activity is going to be one of the main inquiries of this thesis, and Goodman's extended, yet rigorous definition leaves us room to explore the semantic and syntactic dimension of source code as one of those languages of art. Programming languages as symbol systems will be explored further in Chapter X.

With this analytical framework allowing us to analyze the matter at hand—program texts as composed by a symbol system with a epistemic purpose—we turn to a more literary perspective on aesthetics. Genette's approach to literature, \emph{the art of language}, results in the establishment of two dichotomies: fiction/diction, and constitutivity/conditionality. In his eponymous work\cite{genette_fiction_1993}, he extends previous conceptions of literature and poetics, from Aristotle to Jakobson, in order to broaden the scope of what can be considered literature, by broadening the conditions under which a text is given a literary status. As such, he establishes the existence of conditional literature alongside constitutive literature: the former gains its status of a literary text from the individual, subjective aesthetic judgment bestowed upon it, while the latter relies on pre-exisiting structures, themes and genres. This approach paves the way for an extending of the domain of literature\cite{gefen_extension_2019}, and a more subtle understanding of the aesthetic manifestation in textual works.

Genette makes the distinction between fiction, with the focus being the potentiality of a text's object, its imaginative qualities and themes, and diction, with an emphasis on the formal characteristics of the text. Since code holds two existences, one as executed, and one as written, I propose to map Genette's concept of fiction on to source code as a purely functional text—i.e. what the source code ultimately does. Because source code always holds software as a potential within its markings, waiting to be actualized through execution, one has to imagine what this code actually does. Written source code, then, could either be judged primarily on its fiction or on its diction. Since we focus on the written form of source code, and not on the type of its purpose, an attention to diction will be the entry point of this thesis.

A first approach to source code could be \emph{constitutive}, in Genette's terms: a given program text could be considered aesthetically pleasing because the software it generates abides by some definitions of being aesthetically pleasing\footnote{For instnace, Venustas, Firmitas, Utilitas; See Fishwisck, P. (éd), \emph{Aesthetic Computing}}, or because the software itself is considered a piece of art, shown in exhibitions and sold in galleries. However, our empirical approach to source code aesthetics, by examining various program texts directly, and our inquiry into the possibility of multiple aesthetic registers co-existing within source code as a symbol system, asks us to forgo this constitutive definition of an aesthetic work as normative categories which do not yet exist within software development. Our focus on sense perception within aesthetics starts then from a conditional approach, in which programmers emit an aesthetic judgment on a program text, with an emphasis first on what the source code \emph{is}, and only secondly on what it \emph{does}\footnote{As we've seen with Goodman, there is nonetheless a tight connection between those to states.}.

Diction, then, focuses on the formal characteristics of the text. The point here is not to assume an autotelic mode of existence for source, but rather to acknowledge that there is a certain difference between the content of software and the form of its source: good software can be written poorly, and poor software can be written beautifully. This thesis chooses to focus on the formal aspects of code such as not to restrict ourselves to any specific kind, or genre, of program texts, leaving open the possibility for these categories to emerge after our analysis.

So, following Genette's re-asking of the Goodman's question of \emph{When is art?} rather than the historical \emph{What is art?}, we can now proceed with our understanding of aesthetics as a set of physical manifestations which can be grasped by the senses, whether "the movement of a light, the brush a fabric, the splash of a color"\cite{ranciere_aisthesis_2013}, which aim at enabling a cognitive, communicative purpose, and which are not exclusively constituted by pre-existing categories.

These relations between source code and aesthetics have been addressed by academic studies through different, separate dynamics.

\subsubsection{Literature review}


A literature review on this topic must address the dualistic nature of studies on source code. Reminiscent of C.P. Snow's distinction of two cultures, research can be clearly divided between the fields of computer science and engineering on one side, and that of the humanities on the other. This overview will provide us with a better sense of which aspects of code and aesthetics have been explored until now, and will invite us to address the remaining gaps.

Most technical literature, starting from \emph{The Art of Computer Programming}, acknowledges the role that aesthetics have to play in the writing and reading of program texts. Along with the positions of Knuth and Djikstra regarding the importance of paying attention to all aspects of programming practice, beyond strictly mathematical and engineering requirements, Kerninghan and Plauer publish in 1978 their \emph{Elements of Programming Style}\cite{kernighan_elements_1978}, focusing on how code snippets with a given intent could be rewritten in order to keep the same intent but gain in quality—that is, in readability and understandability. For instance, the following program:

\begin{lstlisting}]
    if(i == 0) c = '0'
    if(i == 1) c = '1'
    if(i == 2) c = '2'
    if(i == 3) c = '3'
    if(i == 4) c = '4'
    if(i == 5) c = '5'
    if(i == 6) c = '6'
    if(i == 7) c = '7'
    if(i == 8) c = '8'
    if(i == 9) c = '9'
\end{lstlisting}

can be rewritten as:

\begin{lstlisting}
    if(i >= 0 && i < 10) c = '0' + i
\end{lstlisting}

which keeps the exact same functionality, but becomes much clearer. Why it becomes much clearer, though, is thought to be a given for the reader, and not explicited by the authors in terms ofc concepts such as cognitive surface, repleteness of a symbol system or representation of the idea at play (casting an integer to a character, rather than individually checking for each integer case). However, the authors do employ terms which will form the basic of an aesthetics of software development, such as clarity, simplicity, or expressiveness; still, there are no overarching principles deployed to systematize the approach, only examples of such principles.

While Kernighan and Plauer do not directly address the relationship of source code and aesthetics, this is something that Peter Molzberger undertakes five years later through an empirical, qualitative study aimed at highlighting the place aesthetics play in an expert programmer's practice\cite{molzberger_aesthetics_1983}. Molzberger's study touches upon ideas of over-arching structure, tension between clarity and personality, and levels of expertise in aesthetic judgment. This short paper highlights multiple phenomena which will be explored further in this thesis, without providing an answer as to \emph{why} this might be the case. For instance, a conception of code as literature does not explain this switch in scales and directions of reading, or a conception of code as mathematics does not explain the need for a personal touch when writing source code\cite{molzberger_aesthetics_1983}.

In the context of formal academic research, such as the IEEE or the Association for Computing Machinery (ACM), research then focuses on how to quantitatively assess a given quality of source code either through a social perspective on the process of writing\cite{norick_effects_2010}, a semantic perspective on the lexicon being used\cite{fakhoury_improving_2019,guerrouj_normalizing_2013}, an empirical study of programming style in the efficiency of software teams\cite{reed_sometimes_2010} or on the visual presentation of code in the comprehension process\cite{marcus_graphic_1982}. These focus on the connection of aesthetics with the performance of software development—beautiful code might be related to a good end-product.

In parallel, the development of software engineering as a profession has led to the publication of several books of specialized literature, taking a practical approach to writing good code, rather than a scientific one. Robert C. Martin's \emph{Clean Code}'s audience belongs to the field of business and trade, drawing on references from architecture, literature and craft in order to lay out the requirements of what he considers to be clean code. These specific mechanisms are highlighted in terms of how they will support a productive increase in the quality of software developed, and was followed by a number of additional publications on the same topic and with the same approach\cite{fowler_refactoring_1999,arns_code_2005,hunt_pragmatic_1999}. Here, these provide an interesting counterpoint to academic research on quality code by relying on different traditions to explain why the way code is written is important.

Technical and engineering literature, then, establish the existence of and need for aesthetics, presented as formal properties which then constitute \emph{quality code}. The methodology in these studies is either empirical, in the case of academic articles, looking at lines of code, or interviewing programmers in order to draw conclusions regarding this relationship between formal properties and quality, while earlier monographs and business literature draw on the experiences of their authors as a programmers to provide source code examples of specific principles, without extending on the rationale and coherence of these principles, let alone within a source code-specific aesthetic framework. A particularly salient example is Greg Oram's edited volume \emph{Beautiful Code}, in which high-level programmers are invited to pick a piece of code and explain why they like it, sometimes commenting it line by line\cite{oram_beautiful_2007}. This very concrete, empirical inquiry into what makes source code beautiful does no, however, include a strong enough conclusion as to what \emph{actually} makes code beautiful.

Another limitation of these is that they address a large group of software practicioners, but not the only group.

\begin{itemize}
    \item on the other side, humanities with high level, broad level (not too technical, not too empirical)
    \item but also focus on smaller niches: obfuscation, code poetry, IOCCC (opens up different registers)
    \item and then ammend with critical code studies and software studies (...???...)
    \item finish on the books that have the most details: aesthetics of code phd theses, expressive code
\end{itemize}

\vspace*{1\baselineskip}

\centerline{\rule{0.3334\linewidth}{.4pt}}

\vspace*{2\baselineskip}

\begin{itemize}
    \item \sout{start with a very basic description of what code/source code/software is}
    \item \sout{quick history of software development}
    \item \sout{demonstrate that program texts are a thing then that programmers know there is beautiful code.}
    \item \sout{connect the "textual manifestation" aspect with my definition of aesthetics.}
    \item then a literature review on how these issues of aesthetics+code are addressed
\end{itemize}

% I COULD INTERTWINE CONTEXT - DEF CODE - CONTEXT - DEF AESTHETIC - CONTEXT - DEF UNDERSTANDING

\subsubsection{The definitions}

\begin{itemize}
    \item \sout{Aesthetics}
    \item \sout{Source Code}
    \item \sout{Program Text}
\end{itemize}

\subsubsection{Boundaries}

that which i shall not touch (visual programming, bio programming, based on the fact that I'm starting from a literary point of view)

but once we have laid out all of this, then it becomes possible to highglight the gaps:
\begin{itemize}
    \item the assumption of the literarity of code
    \item the lack of theoretical framework explaining why some code is beautiful and why other isn't
    \item the lack of \emph{proof}, which is showing code
    \item the apparent assumption that aesthetics have nothing to do with source code
\end{itemize}

\subsection{Problem - 10p}

start by establishing, based on what was said previously, the \emph{niche} that i will occupy

\begin{itemize}
    \item the fetishization of code
    \item the multiplicity of registers
    \item the reason why it matters (connecting beautiful and useful)
\end{itemize}

then really establish the significance of this study: beauty and function, and conclude on my research questions

\subsection{Methodology - 10p}

\begin{itemize}
    \item reading code
    \item reading discourses
    \item reading aesthetic theory based from these discourses
    \item also the theoretical frameworks (maybe move goodman and genette to here)
\end{itemize}

\subsection{Roadmap - 6p}

list all chapters with a brief overview for each.

\subsection{Connecting back to the wider world - 2p}

and readership