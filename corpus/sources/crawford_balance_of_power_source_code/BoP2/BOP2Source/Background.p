Unit Background;INTERFACEUSES{$L-}{$U-}		{$LOAD MQOTP.dumpfile}			 Memtypes, QuickDraw, OSIntf, ToolIntf, PackIntf,	 {$LOAD BOPGlobals.dumpfile}		 {$U Globals.p}	Globals;	 {$LOAD}{$U+}{$E+}{$L+}{$ASM+}{$D-}{$R-}{$OV-}{$SETC DebugFlg:=FALSE}{$IFC DebugFlg}	{$D+}	{$R+}	{$OV+}{$ENDC}PROCEDURE DoBackGd;IMPLEMENTATION{**************************************************************************}PROCEDURE NewRevMap(Resource,Divisor,Archive,Violence: Integer; NewNdxFlag: Boolean);{main routine for revising the map under new circumstances}CONST	GStrng		= 'GNP ';	perStrng	= ' per ';	CStrng		= 'capita';	ClrMap = 0;	GNPC = 1;	MiltryS = 2;	ConsS = 3;	InvtS = 4;	Populn = 5;	MilPersn = 6;VAR	i,ii,j,x,y,SaveID,SaveVal:					Integer;	IColor,NoZeros,Mantissa:					Integer;	NumZeros,DenZeros,IDNumber:					Integer;	Arg,Count,DecPnt,Pwr10:					Integer;	Denomntr,Numeratr,Attempt:					LongInt;	Coeff,BigstVal:						LongInt;	TitleRect:							Rect;	OutStrng,TempStrng,TitStrng:					Str255;	IDArr,SortArr:						IntArr;	StrHandle:							StringHandle;	LZFlag,DPFlag,CommaFlg:					Boolean;	MyHandle:							Handle;BEGIN	IF NewNdxFlag THEN		BEGIN			SetRect(TitleRect,155,305,510,340);			FillRect(TitleRect,white);			PenSize(3,3); 			FrameRect(TitleRect); 			PenSize(1,1);		END;	IF Archive>0 THEN		BEGIN			StrHandle:=GetString(1099+Archive);			StuffHex(@SortArr,StrHandle^^);			ReleaseResource(pointer(StrHandle));			StrHandle:=GetString(1149+Archive);			StuffHex(@SortArr[63],StrHandle^^);			ReleaseResource(pointer(StrHandle));			Resource:=Archive+6;			IF (Archive>8) AND (Archive<15) THEN Divisor:=Violence ELSE Divisor:=8;		END	ELSE		BEGIN			CASE Resource OF				ClrMap: FOR i:=1 TO NoCntry DO SortArr[i]:=0;				GNPC: FOR i:=1 TO NoCntry DO SortArr[i]:=GNP[i];				MiltryS: FOR i:=1 TO NoCntry DO SortArr[i]:=MiltSpnd[i];				ConsS: FOR i:=1 TO NoCntry DO SortArr[i]:=ConsSpnd[i];				InvtS: FOR i:=1 TO NoCntry DO SortArr[i]:=InvtSpnd[i];				Populn: FOR i:=1 TO NoCntry DO SortArr[i]:=Popln[i];				MilPersn: FOR i:=1 TO NoCntry DO SortArr[i]:=MilMen[i];			END;	 {of CASE statement}			OutStrng:='';		END;	IF HitCntry>0 THEN Mantissa:=SortArr[HitCntry];	BigstVal:=0;	FOR i:=1 TO NoCntry DO		BEGIN			Numeratr:=ord4(SortArr[i])*100;			CASE Divisor OF				8: Denomntr:=100;				9: Denomntr:=ord4(Popln[i]);				10: Denomntr:=ord4(GNP[i]);			END;			Coeff:=(Numeratr div Denomntr)+1;			IF Coeff>BigstVal THEN BigstVal:=Coeff;		END;	Coeff:=3276700 div BigstVal;	FOR i:=1 TO NoCntry DO		BEGIN			Numeratr:=ord4(SortArr[i])*Coeff;			CASE Divisor OF				8: Denomntr:=Coeff;				9: Denomntr:=ord4(Popln[i]);				10: Denomntr:=ord4(GNP[i]);			END;			SortArr[i]:=Numeratr div Denomntr;		END;	IF HitCntry>0 THEN		BEGIN	{relative rankings}			IF NewNdxFlag THEN GetIndString(OutStrng,591,2);			FOR i:=1 TO NoCntry DO				BEGIN					IF i<>HitCntry THEN						BEGIN							IF SortArr[i]>SortArr[HitCntry] THEN IColor:=Idkgray ELSE Icolor:=Iltgray;							FillCntry(i,IColor);						END;				END;			ClearRect(158,322,507,337);			MoveTo(162,333); 			TextFont(0);			DrawString('('); DrawString(CntryNam[HitCntry]); DrawString(': ');			CASE Divisor OF				8: BEGIN Denomntr:=1; DenZeros:=0; TempStrng:=''; END;				9: BEGIN					 Denomntr:=ord4(Popln[HitCntry]); DenZeros:=5; TempStrng:='/person'; END;				10: BEGIN					 Denomntr:=ord4(GNP[HitCntry])*2; DenZeros:=8; TempStrng:='/GNP$'; END;			END;	{of CASE statement}			x:=1; 			NumZeros:=0;			CASE Resource OF				1: BEGIN x:=2; NumZeros:=8; END;				2: BEGIN x:=1; NumZeros:=7; END;				3: BEGIN x:=2; NumZeros:=8; END;				4: BEGIN x:=2; NumZeros:=8; END;				5: BEGIN x:=1; NumZeros:=5; END;				6: BEGIN x:=1; NumZeros:=3; END;				13: BEGIN x:=1; NumZeros:=-1; END;				14: BEGIN x:=1; NumZeros:=-1; END;				16: BEGIN x:=1; NumZeros:=2; END;				28,29: BEGIN x:=1; NumZeros:=-1; END;			END;	{of CASE statement}			Numeratr:=ord4(Mantissa)*x;			GetIndString(TitStrng,593,Resource);			NoZeros:=NumZeros-DenZeros;			IF Numeratr=0 THEN Numeratr:=1;			IF Denomntr=0 THEN Denomntr:=1;			WHILE Numeratr div Denomntr < 1000 DO				BEGIN					Numeratr:=Numeratr*10;					NoZeros:=NoZeros-1;				END;			WHILE Numeratr div Denomntr > 10000 DO				BEGIN					Numeratr:=Numeratr div 10;					NoZeros:=NoZeros+1;				END;			Mantissa:=Numeratr div Denomntr;{-----------------------write floating point value---------------------------}			LZFlag:=FALSE;			DPFlag:=FALSE;			CommaFlg:=TRUE;			DecPnt:=NoZeros+5;			IF DecPnt<1 THEN				BEGIN					DrawString('.');					FOR i:= 0 DOWNTO DecPnt DO DrawString('0');					DPFlag:=TRUE;				END;			Pwr10:=10000;			FOR Count:=4 DOWNTO 0 DO				BEGIN					IF NOT DPFlag THEN						BEGIN							IF DecPnt=0 THEN BEGIN DrawString('.'); DPFlag:=TRUE; END;						END;					Arg:=0;					WHILE Mantissa>=0 DO						BEGIN							Mantissa:=Mantissa-Pwr10;							Arg:=Arg+1;						END;					Mantissa:=Mantissa+Pwr10;					Arg:=Arg-1;					IF LZFlag OR (Arg<>0) THEN						BEGIN							IF (DecPnt>0) AND (DecPnt mod 3 = 0) AND LZFlag AND CommaFlg										THEN DrawString(',');							DrawChar(chr(Arg+48));							LZFlag:=TRUE;						END;					DecPnt:=DecPnt-1;					Pwr10:=Pwr10 div 10;				END;			WHILE DecPnt>0 DO				BEGIN					IF (DecPnt>0) AND (DecPnt mod 3 = 0) THEN DrawString(',');					DrawString('0');					DecPnt:=DecPnt-1;				END;{---------------------------end of write---------------------------------}			TitStrng:=Concat(TitStrng,TempStrng);			DrawString(' '); DrawString(TitStrng); DrawString(')');		END	 {of relative rankings}	ELSE		BEGIN {absolute rankings}	 {sort the array}			IF NewNdxFlag THEN GetIndString(OutStrng,591,1);			FOR i:=1 TO NoCntry DO IDArr[i]:=i;			FOR i:=2 TO NoCntry DO				BEGIN					j:=i;					WHILE SortArr[j] > SortArr[j-1] DO						BEGIN							SaveVal:=SortArr[j];							SortArr[j]:=SortArr[j-1];							SortArr[j-1]:=SaveVal;							SaveID:=IDArr[j];							IDArr[j]:=IDArr[j-1];							IDArr[j-1]:=SaveID;							IF j > 2 THEN j:=j-1;						END;				END;	{end of sort}			IColor:=Idkgray;			FOR i:=1 TO NoCntry DO				BEGIN					IF i > 15 THEN IColor:=Igray;					IF i > 31 THEN IColor:=Iltgray;					IF i > 47 THEN IColor:=Iwhite;					IF SortArr[i] = 0 THEN IColor:=Iwhite;					IF i<>HitCntry THEN FillCntry(IDARR[i],IColor);				END;		END;	{of ELSE condition and IF HitCntry statement}	IF NewNdxFlag THEN		BEGIN			GetIndString(TempStrng,591,3);			OutStrng:=Concat(OutStrng,' ',TempStrng);			GetIndString(TempStrng,601,Resource);			OutStrng:=Concat(OutStrng,' ',TempStrng);			CASE Divisor OF				9: OutStrng:=Concat(OutStrng,perStrng,CStrng);				10: OutStrng:=Concat(OutStrng,perStrng,GStrng);			END;			MoveTo(162,318);			DrawString(OutStrng);			ClearRect(326,220,428,298);			ClearRect(326,280,450,298);			TextFont(1); 			TextSize(9);			IF HitCntry>0 THEN				BEGIN					FOR i:=1 TO 2 DO						BEGIN							SetRect(TitleRect,326,200+20*i,338,215+20*i);							CASE i OF								1: BEGIN FillRect(TitleRect,ltgray); TitStrng:='Lower Value'; END;								2: BEGIN FillRect(TitleRect,dkgray); TitStrng:='Higher Value'; END;							END;							FrameRect(TitleRect);							MoveTo(342,213+20*i);							DrawString(TitStrng);						END;				END			ELSE				BEGIN					FOR i:=1 TO 4 DO	 {draw and label map key}						BEGIN							SetRect(TitleRect,326,200+20*i,338,215+20*i);							CASE i OF								1: FillRect(TitleRect,white);								2: FillRect(TitleRect,ltgray);								3: FillRect(TitleRect,gray);								4: FillRect(TitleRect,dkgray);							END;							FrameRect(TitleRect);							GetIndString(OutStrng,600,i);							MoveTo(342,213+20*i);							DrawString(OutStrng);						END;				END;		END; {of new index display}	TextFont(0); TextSize (12);	FlushEvents(everyEvent,0);END;{**************************************************************************}PROCEDURE DoBackGd;CONST	ExitMenu = 10;	RescMenu = 11;	ArkMenu = 12;	VioMenu = 13;	PolMenu = 14;	EcoMenu = 15;VAR i,theMenu,theItem,SaveHitC:					Integer; CurResrc,CurPerVal,CurArchv,CurVioln:	Integer; MenuVal:							LongInt; SaveMenu:							Handle; mousepoint:							Point; JunkFlag,ExitFlag,ChgFlag:					Boolean; GameMenu,ResrMenu,ArchMenu,ViolMenu,PoltMenu,EconMenu:			MenuHandle;BEGIN  SaveMap;	SaveHitC:=HitCntry;	SaveMenu:=GetMenuBar;	ClearMenuBar;	ClearRect(155,300,510,340);	GameMenu:=GetMenu(10); 	ResrMenu:=GetMenu(11); 	ArchMenu:=GetMenu(12);	ViolMenu:=GetMenu(13); 	PoltMenu:=GetMenu(14);	EconMenu:=GetMenu(15);	InsertMenu(GameMenu,0); 	InsertMenu(ResrMenu,0); 	InsertMenu(ArchMenu,0);	InsertMenu(ViolMenu,0); 	InsertMenu(PoltMenu,0);	InsertMenu(EconMenu,0);	CurResrc:=1; 	CurPerVal:=8; 	CurArchv:=0; 	CurVioln:=8;	CheckItem(ResrMenu,8,TRUE); 	CheckItem(ResrMenu,1,TRUE); 	CheckItem(ViolMenu,8,TRUE);	DrawMenuBar; 	NewRevMap(CurResrc,CurPerVal,CurArchv,CurVioln,TRUE);	ExitFlag:=FALSE;	REPEAT		JunkFlag:=GetNextEvent(everyEvent,myEvent);		IF myEvent.what=mouseDown THEN			BEGIN			 IF FindWindow(myEvent.where,MyWind)=inMenuBar THEN				 BEGIN					 MenuVal:=MenuSelect(myEvent.where);					 CheckItem(ResrMenu,CurResrc,FALSE); 					 CheckItem(ResrMenu,CurPerVal,FALSE);					 CheckItem(ViolMenu,CurVioln,FALSE);					 theMenu:=HiWord(MenuVal);						 theItem:=LoWord(MenuVal);					 ChgFlag:=FALSE;					 CASE theMenu OF						 ExitMenu: ExitFlag:=TRUE;						 RescMenu:							 BEGIN								 IF (theItem<7) AND (theItem>0) THEN										BEGIN CurResrc:=theItem; ChgFlag:=TRUE; CurArchv:=0; END;								 IF theItem>7 THEN									BEGIN CurPerVal:=theItem; ChgFlag:=TRUE; CurArchv:=0; END;							 END;						 ArkMenu:							 IF (theItem<>CurArchv) AND (theItem>0) THEN								BEGIN CurArchv:=theItem; ChgFlag:=TRUE; END;						 VioMenu:							 BEGIN								 IF (theItem=8) OR (theItem=9)									 THEN BEGIN CurVioln:=theItem; ChgFlag:=TRUE; END									 ELSE IF (theItem+8<>CurArchv) AND (theItem>0) THEN												 BEGIN CurArchv:=theItem+8; ChgFlag:=TRUE; END;							 END;						 PolMenu:							 IF (theItem+14<>CurArchv) AND (theItem>0) THEN								BEGIN CurArchv:=theItem+14; ChgFlag:=TRUE; END;						 EcoMenu:							 IF (theItem+16<>CurArchv) AND (theItem>0) THEN								BEGIN CurArchv:=theItem+16; ChgFlag:=TRUE; END;					 END;					 CheckItem(ResrMenu,CurResrc,TRUE); 					 CheckItem(ResrMenu,CurPerVal,TRUE);					 CheckItem(ViolMenu,CurVioln,TRUE);					 IF ChgFlag THEN NewRevMap(CurResrc,CurPerVal,CurArchv,CurVioln,TRUE);					 HiLiteMenu(0);				 END			 ELSE				 BEGIN					 GetMouse(MousePoint);					 IF HitCntry<>0 THEN						 BEGIN							 FillCntry(HitCntry,IWhite);							 ClearRect(220,20,340,44);							 OldHit:=HitCntry;							 JunkFlag:=TRUE;						 END						 ELSE JunkFlag:=FALSE;					 HitCntry:=0;					 FOR i:=1 TO NoCntry DO						 BEGIN;							 IF PtInRgn(MousePoint,CntryRgn[i]) THEN									BEGIN										FillCntry(i,IBlack);										MoveTo(220,40);										DrawString(CntryNam[i]);										MoveTo(1,320);										HitCntry:=i;										JunkFlag:=NOT JunkFlag;									END;						 END;					 NewRevMap(CurResrc,CurPerVal,CurArchv,CurVioln,JunkFlag);				 END; {of ELSE-condition}		 END;	UNTIL ExitFlag;	CheckItem(ResrMenu,CurResrc,FALSE); 	CheckItem(ResrMenu,CurPerVal,FALSE);	CheckItem(ViolMenu,CurVioln,FALSE);	ClearRect(155,305,510,340);	DrawMenuBar;	SetMenuBar(SaveMenu);	DrawMenuBar;	DisposHandle(SaveMenu);	HitCntry:=SaveHitC;	{IF SaveHitC=0 THEN BEGIN HitCntry:=0; ClearRect(220,20,340,44); END;}	ReDrawMap;END;{**************************************************************************}END.