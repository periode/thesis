# philosophy of computer science

## william j. rapaport

### university of buffalo, new york, 2004-2020 (draft)

---

an extensive overview of philosophical questions in computer science, particularly concerning ontology (what is a computer) and teleology (does a computer need a purpose), as well as syntax and semantics

---

#### 1 - what is CS

CS is unique from maths as it deals with two things that are not (immediately?) related to math:

- notions of complexity
- dynamic notion of the state of a process

CS is the science of how machines can carry out *intellectual processes* (McCarthy, 1963)

CS is the science of process (*programs* are static texts which turn into *processes*, dynamic entities) and, even further, the science of *procedural epistemology* (Abelson, 1996)

CS is the engineering of abstract objects (following Brook's Turing Lecture)

but CS cannot be one (science, conceptual, what) without the other (engineering, practical, how) (and this is where the art happens?) Because, as Knuth said "if we don't fully understand something, it is an art to deal with it".

> Thoughts without content are empty, intuitions without concepts are blind... The understanding can intuit nothing, the senses can think nothing. Only through their union can knowledge arise (Kant, 1781, p.93)

#### 3 - what is a program?

see refs list in [schedule](../../schedule_2021_1.md)

a program is a *cognitive artefact*, which can be understood on three different levels, according to Moor:

- the physical level (transistors)
- the design level (specifications, effective)
- the intent level (the goal and desire)

read 19.4.3 for Lakoff

software as a pattern of syntactical form (see Suber, 1988)

#### 7 -  implementation (pp.638-669)

rapaport 1999, implementation is semantic interpretation

putnam, representation and reality, 1988 (pp.121-125)

Implementation as:

- individuation (from homo sapiens to delia derbyshire)
- instantiation (from turing machine to macbook)
- exemplification (from red to a specific acrylic)
- reduction (from complex weather model to weather forecast)

**-> these all relate to goodman**

given two domains (SYN and SEM), there is a *mapping* between the two. semantic understanding is:

- "understanding a system in terms of another system that we already know"
- "a material implementation" (i.e. situated)
- required to have an "ontology", a "model theory"

and, actually, the specificity of turing machines is that they can be understood entirely syntactically. there can be instances of *indigenous semantics*, which are essentially subroutines.

software is a model, a medium of thought, an environment (Mahoney, 2011)

Lamport, 2015, says that "abstraction is an art" -> to be developed

being computer-understandable means that it is computer-decodable

in order to understand a computer program, we need to give it meaning, that's what always happens: "distinguishing from noise is something that literature does" (Suber, 1988, p.97)

the question "what does a Turin machine do?" has `n+1` answers. 1 syntactic, and n semantic (however many interpretations)