# notes - fall 2020

## introduction

who is going to be impacted by this? how does it create discussion/connection?

- literary theorists, for broadening scope and designers (as other functional artists)
- practicioners, to deepen the understanding of the potential beauty of the work, and its use
- for a more minute criticism to judge the quality of something (a book or a program)

## to read

[metaphors and the main problems of hermeneutics](https://aaaaarg.fail/upload/paul-ricoeur-metaphor-and-the-main-problem-of-hermeneutics.pdf)

[the metaphorical process as cognition, imagination and feeling](https://aaaaarg.fail/upload/paul-ricoeur-the-metaphorical-process-as-cognition-imagination-and-feeling.pdf)

[on knowldege in architecture and science](http://anzasca.net/wp-content/uploads/2014/08/ANZASCA-1998-Downton-Knowledge.pdf)

[patterns, software and philosophy](http://legacy.earlham.edu/~peters/writing/software.htm)

[software abstract artifact](https://www.academia.edu/1277741/Software_is_an_abstract_artifact) and https://link.springer.com/article/10.1007/s13347-012-0098-z

[elegance in programming language design](https://web.eecs.utk.edu/~bmaclenn/papers/Elegance.html)

[systems elegance](https://sci-hub.mksa.top/10.1109/JSYST.2018.2875152)

[ontologies of computer programs](https://web.archive.org/web/20150707093557/http://home.mis.u-picardie.fr/~site-ic/site/IMG/pdf/ICSOFT2007_final.pdf)

[programming paradigms - van roy](http://www.cs.albany.edu/~sdc/CSI500/Downloads/ProgrammingParadigmsVanRoyChapter.pdf)

[linguistics and computational semantics - cantwell-smith](https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.654.5768)

[what is software? - peter suber](http://legacy.earlham.edu/~peters/writing/software.htm)

[computational artefacts - peter suber](https://www.academia.edu/7875726/COMPUTATIONAL_ARTEFACTS)

[programming languages as technical artefacs](https://link.springer.com/article/10.1007/s13347-012-0098-z)

[insightuful code](https://www.hillelwayne.com/post/cleverness/)

[the programmer's brain (preview)](https://www.manning.com/books/the-programmers-brain) -> However, your brain does a lot more while you are reading the BASIC program. You are mentally trying to execute the code, to understand what is happening. That process is called **tracing**—the mental compiling and executing of code

[software design decoded](https://www.amazon.com/Software-Design-Decoded-Experts-Think/dp/0262035189)

Elegance: Through a single lens, it communicates the problem it solves and the machinery of its solution.

Implementation as: **THIS GOES WITH GOODMAN**

- individuation (from homo sapiens to delia derbyshire)
- instantiation (from turing machine to macbook)
- exemplification (from red to a specific acrylic)
- reduction (from complex weather model to weather forecast)

https://vimeo.com/47364930 -> concise code is code as litterature, because he says one of the issues is that there are just too many lines of code that one can wrap its head around. so there's a need for shrinking down content

ARCH:

alexander vs. eisenman

alexander = softdev, habitable vs. eisenman = hack, subversion

design thinking book: The concept of good in architecture is one which says, among other things, that all architecture must engage its audience. It must foster understanding and be intelligible. This is clearly not the only concept necessarily at work, but it is one that would have broad adherence, across positions.

beauty in math: https://en.wikipedia.org/wiki/A_Mathematician%27s_Apology

simplicity: Syntactic simplicity, or elegance, measures the number and conciseness of the theory's basic principles. Ontological simplicity, or parsimony, measures the number of kinds of entities postulated by the theory. code is syntactic simplicity because wrngles together complex concepts (e.g. perl, one liners), or code is ontological simplicity, because all is within computation (e.g. lisp)

## email from nick

Pierre,

> You have done well to begin exploring contemporary conceptual metaphor theory (Lakoff, Johnson, Turner, etc.) and its implications for what we call "metaphors" in for instance UI. In fact using a term like "desktop" or saying "I dragged the file to the desktop" is not, as you know at this point, a metaphor according to Lakoff. It is an expression related to the underlying conceptual or cognitive metaphor which might be something like THE GRAPHICAL USER INTERFACE IS A DESK ... that is not satisfying yet,because "interface" is itself a metaphorical expression ... so perhaps THE COMPUTER IS AN OFFICE?

> I suggest you work to make your discussion of user-facing and programmer-facing metaphors even more clear and complete, for instance explaining the underlying conceptual metaphors that are surfaced by terms such as "cloud," "cloud instance," or "recipe." For instance the immateriality of the Internet and computing is what is highlighted by the metaphorical expression "store your data in the cloud," but I'll turn to you to ask two things: What actually is the underlying metaphor (along the lines of THE COMPUTER IS AN OFFICE)? How is that metaphor structured? Similarly, it seems that creating instances of things is an industrial metaphor in which material and identicality are foregrounded. What would you call the underlying conceptual metaphor there? How is it structured? Once you give the underlying metaphors names, you can explain how these are two dichotomous and highly opposed metaphors that come into an odd conflict in "cloud instance."

These are very good points, and I can image how this could be connected further to the idea that COMPUTING IS WORK; but is this still a metaphor, or the cultural backdrop on which the subsequent metaphors (desk, folder, bin, dragging, pasting) take place? At this point, then, it seems that we're moving more towards a definition of computing, rather than a communication/comprehension through metaphorical means? I wonder to what extent we could replace it by COMPUTING IS PLAY, COMPUTING IS THOUGHT, etc. My personal intuition is that it would indeed be closer to work than to these other activities, with its implications of functionality, effectiveness, process and collaboration. However, I'm still not sure exactly what is meant by "structures of a metaphor". Is it the features I've mentioned above (functionality, effectiveness, something often made in a group for the service of another group?), or something else?

Computing could be work, but computation is definitely closer to thought (cf. algorithms vs. their implementation), reflected in the ethereal properties of the "cloud" vs. the concrete manifestations of an "object". I tend to think that the combination of work and thought (reunited in practices like craftsmanship, architecture, scientific work) with specific aesthetic manifestations, then, is *a* work in which those implications are made clear and are "optimized/acute/heightened".

> With that done, you can move to applying the contemporary theory (or theories) of metaphor to two other very important metaphors: SOFTWARE DEVELOPMENT IS ARCHITECTURE and PROGRAMMING LANGUAGES ARE LANGUAGES. By the way, your existing discussion of architecture and programming languages is very good. I think it is ready to be combined with your understanding of metaphor, once that is taken slightly further.

Indeed, I was seeing languages and architecture both as a part of a broader a realm of knowledge representation and knowledge communication, and metaphors can be a tool to highlight the overlapping parts of the Venn diagram of computing, constituted in part by software engineering and programming languages (along with... field of scientific research? art practice?). This does lead me to another question: to what extent does one need to reconcile all of these different ways to communicate concepts and essences of computing? Should there be one single way to reconcile computing with computation (i.e. concrete and abstract)? Or is this way (which I consider being source code) just an overlap amongst others, and multiplicity something that should be embraced rather than solved? Meaning that *in some respects*, programming is architecture and, *in some respects* programming is a language, and so on. So far, I do see that aesthetics is something that is indeed trans-disciplinary (trans-metaphorical, so to speak), so perhaps it does provide a specific/privileged vantage point from which to observe computing.

> You have identified one-liners and demos as productive areas of discussion but are just getting started there.

> With regard to one-liners, you should of course talk more about how they circulate -- in the signature lines that people use in email, in Perl golf competitions, etc. You picked a "clear" one-liner in awk to discuss and there are utility one-liners; there is even a book of these. But there are many others, too! With regard to the demoscene, you may find that sizecoded in particular such as A Mind is Born are the ones that connect best to one-liners. But you will need to be explicit if are focusing, in both cases, on size-limited "hacks."

> Of course you should cite Linus Åkesson's work fully. You certainly need to provide the context for how this demo was shown -- in the 4kb Oldskool compo at Revision 2017, in which I happen to have also had an entry, although the one I did with DIYDSP was more of a joke. The result of executing the 256-byte program is looping video output that does take longer than a minute to loop, by the way.

Yes, my exploration of hacks and one-liners so far is still cursory (as is my citation of the works in that section), so any pointers and further references are appreciated! Would you say that the "hack" as a form/field/practice of programming is too broad? Or that it could be narrowed in its most significant parts by one-liners? In this case, yes, it does seem that the social component of the one-liner are important, drawing on sharing and usefulness to "increase their quality". Another question I have, is then related to their publicity—what role would you say source code has to play in the appreciation of demos? Is it in a purely functional manner, insofar as the result is the exclusive focus (no need to maintain, review, modularize, etc.), or does it play some sort of certificate in testifying of the feasibility of the demo, in a way that is complementary to the output?

> Congratulations on this good work, and I hope you continue to make progress!

## reading and writing

there could be different beauties in writing and in reading (case of Mike's APL) - easier to read vs. easier to type

## aesthetic analysis

luigi pareyson: aesthetics and interpretation [https://www.fabula.org/actualites/luigi-pareyson-esthetique-theorie-de-la-formativite_21236.php]

## found

> My personal style guide is to copy Erlang: double quotes for text, single quotes for programmatic strings (atoms/symbols). The single quote is slightly more convenient to type on a qwerty keyboard, but text regularly contains single quotes (apostrophes). It also provides a semantic visual shortcut.

I like the concept of **semantic visual shortcut**, also **semantic compression** (developed [here](https://caseymuratori.com/blog_0015))

https://dl.acm.org/doi/abs/10.1145/1869542.1869627
https://www.semanticscholar.org/paper/The-Elements-of-Pattern-Style-Sane/664c6bd6f494d5121999071703e595175ebf7aa1?p2df
https://dl.acm.org/doi/abs/10.1145/78607.78611 - typography is proven to be helpful

this could be an interesting theory about the reading process: [https://www.fabula.org/actualites/luigi-pareyson-esthetique-theorie-de-la-formativite_21236.php]

this is not so much about code aligning with standards of literature, but maybe aligning to the standards of both epistemology and architecture, *architectural knowledge*

## programming languages

> when we talk about esolangs, we are designing a perspective for someone to think through. -daniel temkin [src](https://www.artistsandhackers.org/Critical-Code)

> There's a lot of attention to **COMPRESSION**, using the underlying programming language in a way that's easy to penetrate - richard gabriel [src](https://www.dreamsongs.com/PoetryOfProgramming.html)

conceptual art aims at communicating concepts, ideas. experimental art don't know what they aim at but are motivated by an aesthetic criteria. (richard gabriel, keynote science is not enough)

the question of operational meaning vs. denotational meaning should be explored. what means what to the computer? (and what is the role of the stack in this whole thing)

procedural rhetoric is just a very high level of programming semantics. processes with meaning assigned to it. <- this further extends the gradient.

a class within a class [link](https://blog.royalsloth.eu/posts/the-complexity-that-lives-in-the-gui/) is a visual/spatio-mental pattern which means "complexity", "unmaintainability", "unsustainability"

bad patterns make possible the kind of actions which result in bad patterns?

----

Abstraction in programming is the process of identifying common patterns that have systematic variations; an abstraction represents the common pattern and provides a means for specifying which variation to use. An abstraction facilitates separation of concerns: The implementor of an abstraction can ignore the exact uses or instances of the abstraction, and the user of the abstraction can forget the details of the implementation of the abstraction, so long as the implementation fulfills its intention or specification. (Balzer et al. 1989)

----

**Compression** is the characteristic of a piece of text that the meaning of any part of it is “larger” than that particular piece has by itself. This characteristic is created by a rich context, with each part of the text drawing on that context—each word draws part of its meaning from its surroundings.
**Piecemeal growth** is the process of design and implementation in which software is embellished, modified, reduced, enlarged, and improved through a process of repair rather than of replacement

## meeting with advisors

questions:

- would you like to see the corpus? how should i display/save it?

- categories of people are relevant? should i look into academic as well? i'm afraid there might not be so much information/sources

- are metaphors contributing to the research project? should i stick to the functional part of aesthetics.

- the difference between syntactical and semantic metaphors?

the intent overall is to see to what extent there is an overlap between each of those communities of practice

next steps:

- do the same with code poetry for this semester
- also look at hackers
- what about mathematic/academic beauty?
- perfect the aspect of readability (luigi pareyson? umberto eco/the open work?)
  - psychology of programming

---

## chat w/ alexandre

- question de lecture/lectorat?
- - pareillement à ce qu'a dit Nick, il faut se pencher sur la compréhension machine vs. compréhension humaine (aka, il a été établi que la lecture est plus qu'un procédé d'encodage, décodage)
- - et c'est peut-être justement cette double lecture (machine/humain) qui fait que le code est beau
- ~~place de la métaphore?~~
- ~~question du corpus? comment le mettre en page?~~
- relation avec la littérature?
- - RESULTAT: rechercher d'avantage les approches cognitives de l'esthétique/littérature, notamment avec [francoise lavocat](https://www.wiko-berlin.de/en/fellows/academic-year/2014/lavocat-francoise/), [terrence cave](https://global.oup.com/academic/product/thinking-with-literature-9780198749417?cc=de&lang=en&) et [jean-marie schaeffer](https://www.nebraskapress.unl.edu/university-of-nebraska-press/9780803217584/)
- - mais aussi considérer la poésie/littérature comme programmatique (oulipo, etc.), en ce que "si le code est beau, il est beau de la même manière que la poésie".
- et puis **faire attention aux mots** (keywords, etc.), en ce que ces mots-là ont un pouvoir/une contrainte

## chat w/ nick

- look into operational semantics
- programming language research (what are the semantics of computer code? does refactored code have the same semantics as the original code?)
- how are semantics different for a human and a computer?
  
- semantics in experiential types of framework
- metaphors: mapping between a source domain and a target domain
- *More than Cool Reason: A Field Guide to Poetic Metaphor* (poets start from the conventional metaphor, towards the less conventional)

- reading: there is a myth of the linearity of reading
- how are authors reading their manuscript?
- how is related to craftsmanship? to architectural reading? an architect doesn't look at the whole plan when they read it, only the parts they need to change

### whole email

> Your four categories could be refined a bit. I think data scientists working for businesses are very much like the "academics" you identify, in that they don't ship their software to others and their outcomes are external research and insight. A minor issue, but it leads to thinking about the distinction between custom software development for corporate clients (only one piece of software is made) and massively distributed games, apps, operating systems, etc. that run on a variety of platforms and need to be maintained in that context. What a "software engineer" does in these contexts is fairly different, and even if the category holds, I would expect different style guides (for instance) to be used in both cases.

Definitely. These are not at all strictly-defined categories (for now), but rather a heuristic to get past the assumption of "there is only one kind of code". So rather than distinguishing professions/social groups, I could make a distinction between *purposes* of code-writing, which would fit better the argument of contextual meaning/contextual aesthetics that I'm pushing forward. This is how I see these four categories:

- developer/engineer -> practical purpose (must be efficient, maintainable, re-writable, clean, explicit, etc.)
- academic -> conceptual purpose (must hint at some thing greater than itself, is a metonymy for a broader concept, is itself a heuristic)
- artist -> poetic purpose (hints at a particular worldview, sustains mutliple interpretations, aims at being expressive rather than descriptive, stands closest to what a literary metaphor could be in code)
- hacker -> demonstration of skills (in which the process matters as much, if not more than the result—cf. phreaking—, prefers machine-understandability rather than human-understandability, tbc.)

> I wonder if source code can ever explain "why" it does anything outside of its own systematic workings. This perhaps comes to the issue of the meaning code has to people vs. the meaning it has to the computer -- a good topic for verbal discussion.

I would need to think about this more, and look into programming language research/operational semantics before engaging that conversation. However one thread of an answer would be Ed Finn's concept of "effective procedure", a procedure which is deemed worthwhile because it is valid both in computer terms and human terms (he takes the example of the netflix recommendation algorithm). In addition, I recently read [this paper](https://www.journals.uchicago.edu/doi/abs/10.1086/7092250) which advocates that Boole was able to develop his system of formal logic because he decided not to care about the *why* or the *how*: boolean logic only focuses on the validity of any procedure (how) and then leaves the interpretation to the humans. In this case, machine understanding and human understanding are absolutely separate. Perhaps another point of overlap between those two is that of data structures? They might represent a more direct (because they're more simple?) mapping to human mental models than what algorithms are for human mental processes.

> I think there is something higher-level than a specific programming language and lower-level than the abstract algorithm which is important to your discussion, and which you brush up against without directly confronting. That's what is called paradigm or (in a conflict with your terminology) idiom: functional, imperative, object-oriented, etc. We can call Ruby Lisp-like or say that Python's lambda is Lisp-like, but really Lisp itself is lambda-calculus-like, as are the lambda operators in these two languages. Choosing a recursive or iterative solution, using more functional or more imperative frameworks, is facilitated by many languages. This means that what is "good style" in ML depends not only on the specifics of ML, but whether you think functional or imperative programming is better, since ML supports both.

This is a very good point, and it bridges the aesthetics (form) and the poetics (content) of a program. This seems to be a good example of Kenneth Burke's idea of terministic screens: the initial words of a text set the context and the frame (i.e. the screen) for the reader to appreciate "correctly" the text. Indeed seeing (deducing?) that a program is object-oriented or functional should have consequences on how one can judge and appreciate its aesthetic features. However, I'm struggling to see to what extent it can be said that certain paradigms have "aesthetics". What I mean here is that aesthetics are manifested through the implementation of a concept. So perhaps, going one level up, paradigms have aesthetics in how they represent the broader (and common) field of computation/lambda calculus/turing completeness?

> The connection to architecture is a great one. As I was reading the beginning of the paragraph, I was wondering if you were going there, and you were. Can you continue this and map your emerging understanding of code aesthetics into architectural aesthetics? Are the intentionally obfuscated productions of hackers similar in any way to sometimes uninhabitable but structural follies (see https://urldefense.proofpoint.com/v2/url?u=https-3A__en.wikipedia.org_wiki_Folly-29-3F&d=DwIDaQ&c=slrrB7dE8n7gBJbeO0g-IQ&r=PzETIgMD0q9M9MuN-Qfb-8mokR3XuAfMcQJfIzs3Lys&m=NWnwPwQw3df5Qif9i4gZntsF5Wd7PucZ9dvI6UO9zcE&s=M5hUoJLmyfuK-BGayUtxsFeWlFC3xvaZd_TWrjdXkKs&e=

I was particularly interested by a keynote that Christopher Alexander gave at the ACM OOPSIG a couple of decades ago, in which he presented his work on patterns as "patterns which support living", and am now wondering to what extent beautiful code could be made up of "patterns which support thinking" (obviously, thinking implies "good and easy" thinking here, as I'm assuming Alexander means "good and easy life").

Some of the other thoughts that I have a regard the relationship between architect and craftsman (even though the dawn of the architect foresees the demise of the craftsman?). Do physical architects only relate to software architects (designing the overall concept rather than figuring out the building blocks).

In terms of style, I can actually see some kind of correlation (similarly to alexander's patterns above). Style can be seen in both as a form of social order, not in Foucault's sense, but rather that a sylistic imperative in software connotes group cohesion, the same way that stylistic choices in architecture connote group cohesion as well.

Finally, in terms of mapping the groups I've identified of code practitioners, here's a parallel that I can think of.
Artists: building as statement, software as a statement (e.g. brandlhuber vs. I/O/D)
Academics: sketches, concepts, ideas over realizations
Hacker: I can't seem to make a connection here, because hackers operate as underdogs, architects operate as overdogs, so to speak. i don't know enough, but i would imagine things like louvre abu dhabi's dome / mies van der rohe / starchitects who push boundaries of the possible? I would need to read up more on hackers and their practices before giving a further answer, though.

> Details: Some claims are understated, some may need substantiation. "The vast majority of code written today has been done by software engineers" doesn't seem like a controversial claim, but how exactly do you know? Lots of code has been written by students, researchers, hobbyists. When you describe code practitioners, you say "These categories include" ... but you mean "These categories are ..." And a very minor item: Beautiful Code, because it is an edited collection, can be called a book but is not a monograph.

Yes, these are all very good points. If the metric is the number of lines of codes, then we can safely assume that software developers are indeed the main contributors to code, if only just by taking Microsoft and Google products into account (I would also put open-source developers in that category, as they do ship "commercial" products). Source: https://docs.google.com/spreadsheets/d/1s9u0uprmuJvwR2fkRqxJ4W5Wfomimmk9pwGTK4Dn_UI/edit#gid=5
