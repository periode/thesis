
	<!DOCTYPE html>
	<html>
		<head>
			<meta charset="utf-8"/>
			<title>works in public</title>
			<link rel="stylesheet" href="/style.css"/>
		</head>
		<body>
			<div class="way">
				<a href="/index.html">cover</a>
			</div>
			<div class="holding tight">
				<h1 id="computational-artefacts">computational artefacts</h1>

<h2 id="raymond-turner">raymond turner</h2>

<hr />

<blockquote>
  <p>computer scientists construct things.</p>
</blockquote>

<p>technical artefacts have <em>functional</em> properties (purpose) and <em>structural</em> ones (physical makeup which allow for the completion of the functional purpose). and something like <code>A:=7x34</code> involves both physical and abstract machines.</p>

<p>Moor (1978): [[James Moor, Three Myths of Computer Science, 1978.pdf]]</p>

<blockquote>
  <p>Computer programs can be understood on the synmbolic level, as well as on the physical level.</p>
</blockquote>

<p>add the above to [[outline/outline#introduction]]</p>

<p><strong>both the symbolic and the physical are programmable in their own right</strong></p>

<h3 id="the-languages-of-computer-science">the languages of computer science</h3>

<p>at the highest level, architectural description languages involve</p>

<ul>
  <li>components (data stores, with input port and output port)</li>
  <li>connectors (pipes, procedure calls, event broadcasts)</li>
  <li>systems (configurations of components and connectors)</li>
</ul>

<p>at the other hand are hardware description languages (e.g. VHDL)</p>

<h3 id="semantics">semantics</h3>

<blockquote>
  <p>Any discussion on the foundations of computing runs into severe problems right at the start. The difficulty is that although we all use words such as name!, value!, program!, expression! or command! which we think we understand, it often turns out on closer investigation that in point of fact we all mean different things by these words, so that communication is at best precarious. (stratchey, 2000)</p>
</blockquote>

<p>so in order to use those languages, we need some account of their <em>intended meaning</em>, which some argue must be mathematical in nature because:
- it’s not ambiguous
- they facilitate formal exploration without the cost of implementation
- is a resort when the computational artefact (program, architecture) must be reasoned about on an abstract level (which it some point always ends up being a necessity)
- allows for proof of <em>correctness</em></p>

<p>Notions such as <em>threading</em> and <em>synchronization</em> are ambiguous! We need better conceptual understanding for a more exact formulation</p>

<p>basically programming languages are the child of concrete one one side (hardware can do anything) and abstract on the other (mathematics are highly specific)</p>

<h3 id="implementation">implementation</h3>

<blockquote>
  <p>A paradigm computational example is furnished by a compiler for a programming language, where the compiler is the artefact and together the syntactic and semantic definitions of the language constitute the functional specification.The medium of implementation will include the programming language in which the compiler is written</p>
</blockquote>

<p>a relation between three things: a definition, a medium of implementation and the artefact (Artefact A is an implemtation in medium M of the definition F)</p>

<blockquote>
  <p>The programmer constructs the program from the medium of the Java programming language.</p>
</blockquote>

<blockquote>
  <p>Instead of properties such as <em>made from carbon fiber</em>, we have properties such as <em>constructed from arrays in the Pascal programming language, implemented in Java</em></p>
</blockquote>

<h3 id="semantics-and-implementation">semantics and implementation</h3>

<p>programs have a different <em>semantic significance</em> than theorems, because theorems lack such a significance: lines and sequences in a proof aren’t intended to run on the machine.</p>

<p>programs are always stuck between the abstract machine and the physical machine</p>

<h3 id="agency">agency</h3>

<p>agency determines what the function is (i can use the computer as a doorstop): it is the difference between specification (intent-free) and semantic interpretation (intent-rich); one can dictate the other (and vice versa!)</p>

<p>this intentional model is an extension of the mental-model approach (aka programmers don’t care about theory, they just do and tinker). there are no norms and this is hell for a logician.</p>

			</div>
		</body>
	</html>
