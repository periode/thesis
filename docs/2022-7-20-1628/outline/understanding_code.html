
	<!DOCTYPE html>
	<html>
		<head>
			<meta charset="utf-8"/>
			<title>works in public</title>
			<link rel="stylesheet" href="/style.css"/>
		</head>
		<body>
			<div class="way">
				<a href="/index.html">cover</a>
			</div>
			<div class="holding tight">
				<h1 id="understanding-code">understanding code</h1>

<p><a href="./outline.md">outline</a></p>

<blockquote>
  <p>Coding is […] the technique of providing a dynamic background to controle the automatic evolution of meaning. (von neumann and goldstine)</p>
</blockquote>

<p>I highlight the issue of <em>understanding</em> between humans and machines through the medium of source code, as an ambivalent notion which necessitates a symbolic interface. This concept of <em>understanding</em> is also understood in the light of the different <em>fields</em> of programming practice (professional, amateur (hobbyist+hacker), educational, scientific/academic)</p>

<p><strong>define understanding</strong> (perspectives: reader/writer)</p>

<h2 id="general-overview-of-understanding-theory">general overview of understanding theory</h2>

<ul>
  <li>also philip agre (his book is more about AI and mental models, but he makes a point about having a different definition of understanding: that is, situated understanding). meaning that there is at least one theory of the mind that matches a theory/model of computation</li>
</ul>

<blockquote>
  <p>The narrow understanding of “working” as “conforms to spec”.</p>
</blockquote>

<blockquote>
  <p>Since everything is defined mathematically, it does not matter what words we use to describe the system; we could use words like “plan”, “learn”, and “understand”; or we could use words like “foo”, “bar”, and “baz”. In fact, programmers frequently employ nonsense terms like these when testing or demonstrating the logical behavior of a procedure.</p>
</blockquote>

<ul>
  <li>
    <p>simondon with his definition of technology as being a connection between magic and rational?</p>
  </li>
  <li>
    <p>feigenbaum and thought (historical, this seems to be the first anthology published on the topic)</p>
  </li>
</ul>

<p><strong>UNDERSTANDING AS MENTAL MODEL AFFECTED BY LANGUAGE</strong> [[abelson_sussuman_abelson_sicp]]</p>

<p>dual-positioning of source code text
1. against text (against literary)
2. against text (against productive software)</p>

<p>[[fedorenko_language_of_programming_cognitive_perspective]], about the cognitive implications of programming languages: does it change something in our brain if we learn more PLs?</p>

<p>[[fishwick_aesthetic_programming]] an answer to this question of the cognitive impacts of PLs, by using aesthetic as a link (<em>un liant</em>)</p>

<h2 id="the-problem-of-understanding-in-humans-and-humans">the problem of understanding in humans and humans</h2>

<p>this section redefines the concept of understanding, not as human to human, and not as human to machine, but as human to machine to human, and highlights some of the hurdles that appear in terms of collectivity vs. subjectivity. it makes the claim that contrary to writing literature, in which writing is potentially public and reading private, writing source code is a private act (as illustrated by passages like weizenbaum, computer boys) and reading it is highly public. because of a change in concept, i would argue that the change in <em>manifestation</em> of concept is also necessary.</p>

<p>[[mckenzie_cutting_code]]
[[tomov_role_of_aesthetics_in_software]]
[[vee_coding_literacy]]
[[vee_procedural_literacy]]</p>

<h3 id="embodiment-and-tacit-knowledge">Embodiment and tacit knowledge</h3>

<p>also note the place and role of tools (IDEs, teletypes, fast compiling, etc.)</p>

<p>\subsection{Tacit knowledge}</p>

<p>%or at least the role of knowledge, mind as matter:https://dl.acm.org/doi/10.1007/s11023-007-9060-8</p>

<h2 id="the-problem-of-understanding-in-human-and-machines">the problem of understanding in human and machines</h2>

<p>this section investigates the main challenge that source code tends to address as a human-machine communication tool</p>

<p>temporality (fast) and spatiality (jumps)</p>

<p>[[cantell_smith_introduction]] - computing as <em>meaning mechanically realized</em> &lt;- this whole introduction is a good reference on the tension between the linguistic and the mechanical</p>

<p>another philosophical approach highlighting the tension in software is [[irmak_software_abstract_artifact]]</p>

<p>[[detienne_software_design_cognitive_aspects]], psychology of programmers, beacons</p>

<p><a href="https://dl.acm.org/doi/10.1145/3387904.3389279">eye-tracking study of programmers of different levels readingn source code</a></p>

<h3 id="the-problem-of-implementation">the problem of implementation</h3>

<blockquote>
  <p>The most influential conception of computational principles comes from David Marr (1982), who prescribed a definite format for computational theories. For Marr, each theory had three tiers: a computational theory of some problem, a specification of the algorithm by means of which the brain solves this problem, and the implementation of this algorithm in neural machinery. (agre)</p>
</blockquote>

<h3 id="the-metaphors-of-code">the metaphors of code</h3>

<p>this section focuses on the many ways people designate code and digital systems</p>

<p>berry, code as:
- engine
- image
- communication medium
- text [[cummings_coding_with_power_rhetoric_coding]]</p>

<p>limits to a literary approach: [[hayles_print_flat_code_deep]], and confirmation via a psychological study [[ivanova_comprehension_computer_code]]</p>

<p><a href="../readings/notes/critical_code_studies.md">Critical code studies</a>, and rhetorical code studies</p>

<h3 id="the-computer-as-a-technical-apparatus">the computer as a technical apparatus</h3>

<p>this section talks about computation, symbolic logic, math and turing and lambda functions and all that beautiful stuff.</p>

<h3 id="the-computer-as-cognitive-apparatus">the computer as cognitive apparatus</h3>

<p>[[rapaport_philosophy_of_computer_science]]
[[suber_what_is_software]]
[[weinberg_psychology_of_programming]]</p>

<p>this section talks about the computer as a cognitive tool, as a way to think (rokeby, wolfram), along the lines of algorithmic thinking, coding literacy. this will highlight the necessity of translating concepts from one frame of mind to another (formal vs. informal)</p>

<p>“expert programmers know how to choose the level of abstraction appropriate to the task” (sicp)</p>

			</div>
		</body>
	</html>
