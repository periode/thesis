
	<!DOCTYPE html>
	<html>
		<head>
			<meta charset="utf-8"/>
			<title>works in public</title>
			<link rel="stylesheet" href="style.css"/>
		</head>
		<body>
			<style>
				body {
					background-color: white;
					font-family: sans-serif, serif;
				}

				.holding{
					margin: auto;
				}

				.tight{
					width: 70%;
				}

				.way {
					position: absolute;
					top: 10px;
					left: 10px;
				}
			</style>
			<div class="way">
				<a href="/index.html">cover</a>
			</div>
			<div class="holding tight">
				<h1 id="the-study-of-programming-languages">the study of programming languages</h1>

<h2 id="ryan-stansifer">ryan stansifer</h2>

<hr />

<p>pat scanned it. thanks pat.</p>

<hr />

<blockquote>
  <p>Simplicity enters in four guises: uniformity (rules are few and simple), generality (a small number of general functions provide as special cases a host of more specialized functions), familiarity (familiar symbols and usages are adopted whenever possible), and brevity (economy of ex­pression is sought). p. 20</p>
</blockquote>

<p>thoughts:</p>

<ul>
  <li>the computer understands only bits, or understands only self-referential statements</li>
  <li>the point of shannon/turing is that it doesn’t need to understand anything</li>
  <li>in the end, it only understands on or off.</li>
  <li>it makes distinctions between entities and the name of entities (called the <em>use-mention problem</em>)</li>
  <li>the association of a name to an attribute is called <em>binding</em></li>
  <li>
    <ul>
      <li>one thing that the computer/compiler knows but not the programmer is the <strong>location</strong> of everything</li>
    </ul>
  </li>
</ul>

<p>computers understand <strong>structure</strong> and humans understand <strong>names</strong> one example of this separation is when you check for type equivalence: either you check for <em>structural</em> equivalence, or your check for <em>name</em> equivalence. because it’s easier to reason about, modern programming languages choose <em>name</em> equivalence. (p.118)</p>

<p>typoologies of programming languages:</p>

<ul>
  <li>imperative programming</li>
  <li>
    <ul>
      <li>moving data around in storage locations, dominating until the 80s</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>it’s all about assignments -&gt; place value into storage, most statements end up in that</li>
    </ul>
  </li>
</ul>

<p>pointer semantics:</p>

<ul>
  <li>identifier can point to a location (<em>environment</em>)</li>
  <li>a location can point to a value (<em>state</em>)</li>
</ul>

<p>a language without contingency, in which the context does not affect the meaning of expressions is said to be <em>referentially transparent</em> aka <strong>the meaning of a sentence must remain unchanged when a part of a sentence is replaced by an expression having the same meaning</strong> (frege, über sinn und bedeutung)</p>


			</div>
		</body>
	</html>
