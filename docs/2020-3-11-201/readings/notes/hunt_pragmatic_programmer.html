
	<!DOCTYPE html>
	<html>
		<head>
			<meta charset="utf-8"/>
			<title>works in public</title>
			<link rel="stylesheet" href="style.css"/>
		</head>
		<body>
			<style>
				body {
					background-color: white;
					font-family: sans-serif, serif;
				}

				.holding{
					margin: auto;
				}

				.tight{
					width: 70%;
				}

				.way {
					position: absolute;
					top: 10px;
					left: 10px;
				}
			</style>
			<div class="way">
				<a href="/thesis/index.html">cover</a>
			</div>
			<div class="holding tight">
				<h1 id="the-pragmatic-programmer">the pragmatic programmer</h1>
<p>## andrew hunt, david thomas
### addison-wesley, 1999</p>

<hr />
<p>summary</p>

<p>this is largely a book about the realities of being a programmer in a working-environment (mostly a business, profit-oriented one). still, it’s a well-rounded view of the life of software developers
, and a series of <em>heuristics</em> which aren’t quite worried with the aesthetics/details of it, but rather with <em>due process</em>.</p>

<h2 id="yet-it-also-seems-like-all-the-code-there-is-beautifully-working-code-some-of-the-variable-names-is-a-little-clunky-with-prefixes-it-is-indeed-good-pleasing-code-almost-beautiful-its-actually-quite-a-good-example-of-how-aesthetics-and-poetics-are-interdependent">yet it also seems like all the code there <em>is</em> beautifully working code. some of the variable names is a little clunky, with prefixes. it is indeed <em>good</em>, <em>pleasing</em> code, almost <em>beautiful</em>. it’s actually quite a good example of how aesthetics and poetics are interdependent.</h2>

<p>state that programming is a craft, and is about <em>doing</em>, not theories</p>

<p>programmer = listener (capture elusive requirements) + advisor + interpreter (express them so that the machine can do them justice) + dictator</p>

<p>this book is very much about the craft of programming (or so it claims)
- early adopter/fast adapter (experience)
- inquisitive (ask questions)
- critical thinker (cf. above)
- realistic
- jack of all trades</p>

<p>even in business/corporate development, even in large teams, there is room for individuality. <strong>they claim that engineering and craftsmanship can coexist</strong>, this is visible in how emotional they are when talking about tools (p. 96, chap. 3)</p>

<p><em>kaizen</em>: continuously making small improvements</p>

<p>yet another mention of the <em>broken windows</em>, coming from the fact that there is software that is just <em>good enough</em> (anti-craftsmanship?)</p>

<p>“don’t spoil a perfectly good program by overembellishment and over-refinement”</p>

<p>so it looks like the <strong>DRY</strong> acronym has been first presented in this book?</p>

<p><em>“no point in duplicating a comment in header and implementation files. put the comment on interface issues in the header file, and put the comment on details, nitty-gritty comment in the implementation files”</em></p>

<p>the trick is always about <em>localization</em>.</p>

<p><code>java</code>, <code>c++</code> allow for accessor functions (e.g. <code>getX(){ return x};</code>)</p>

<p><em>Yourdon and Constantine</em> call the value of <strong>cohesion</strong> (self-contained, independent, single-clear-purpose)</p>

<p><strong>no unknowns</strong></p>

<p><strong>no global data</strong></p>

<p>plain-text: “human-readable forms of data will outlive all other forms of data and the applications that created them” &gt; difference between <em>human-readable</em> and <em>human-understandable</em></p>

<p>the IDE is still important as a tool, and def has an impact on style and aesthetics (auto-formatting)</p>

<p>liskov principle: “subclasses must be usable through the base class interface without the need for the user to know the difference”</p>

<p><strong>poetics</strong>: you can use <code>semantic invariants</code> to express inviolate requirements, a kind of “philosophical contract” » kind of like <code>idempotency</code></p>

<p>the example on page 173 could be solved by a <code>finally</code></p>

<hr />
<p><strong>the aesthetics of code is that everything is essential without ever being dependent on everything else —on nothing that it doesn’t need to know about</strong>
—</p>

<p><em>de</em>coupling is separating as much as possible</p>

<p>beautiful code is both <em>soft</em> (accomodates changes) and <em>hard</em> (does only one definite thing). being something while at the same time having the <em>potentiality</em> of being something else.</p>

<p><strong>one example of why software is hard: temporal coupling. we don’t usually read in a TMEPORAL fashion</strong> so beautiful code is made to help us overcome hurdles such as these</p>

<p>when you’re coding, there are actually unexpected decisions that spring up unexpected all the time</p>

			</div>
		</body>
	</html>
