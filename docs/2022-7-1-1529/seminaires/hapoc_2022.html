
	<!DOCTYPE html>
	<html>
		<head>
			<meta charset="utf-8"/>
			<title>works in public</title>
			<link rel="stylesheet" href="/style.css"/>
		</head>
		<body>
			<div class="way">
				<a href="/index.html">cover</a>
			</div>
			<div class="holding tight">
				<h1 id="hapoc-2022---what-is-a-computer-program">hapoc 2022 - what is a computer program?</h1>

<h2 id="warren-sack---miniatures-demos-and-artworks-three-kinds-of-computer-program-their-uses-and-abuses">warren sack - Miniatures, Demos and Artworks: Three Kinds of Computer Program, Their Uses and Abuses</h2>

<p>created for teaching, selling, sparking imagination, e.g. minix, mother of all demos, spacewar!</p>

<p>unlike a prototype, they are not a first version of a more elaborate thing, they are rather philosophical statements inscribed as computer programs</p>

<p>“to write a system in miniature is to reorganize the same ideas” e.g. tailspin as a miniprogram ended up being used as the core of Sims 3</p>

<p>ref: inside computer understandings: five programs in miniature</p>

<p>sack did a javascript “translation” (rather than “port”), called narrative: spinner.</p>

<p>literate programming has a next step in the juoyter notebook environment</p>

<blockquote>
  <p>demos are created as arguments […] they’re built to see what is possible to do.</p>
</blockquote>

<p>chap. 6 of the book <strong>software arts</strong> deals with rhetoric (an audience member said that there is also a non-verbal part to the rhetoric)</p>

<p>a work can succeed aesthetically but fail functionally (he argues that beautiful art is one that is devoid of purpose, but after duchamp, there is a reunion of the functional and non-functional in art)</p>

<p>sol lewitt says <em>ideas are a machine to make art</em>, le corbusier says <em>a house is a machine for living</em></p>

<p>miniature: pedagogical
demo: persuasive
artwork: pleasurable</p>

<p>yeah, and actually the demo would also live in other traditions: craftspeople have demos, finance have alpha funds -&gt; in order to inspire trust in your product</p>

<h2 id="shoshana-simons--programming-practice-as-a-microcosmos-of-human-labor-and-knowledge-relations">shoshana simons- Programming practice as a microcosmos of human labor and knowledge relations</h2>

<p>programming practice: (e.g. understanding the runtime, the semantics)</p>

<p>ethics perspective with the technical aspect at the center</p>

<p>the practices of programming that are seemingly technical are actually essentially ethical
programmers transpose structures of practices into other domains</p>

<p>when you do runtime analysis, for instance, you abstract away the “planetary network of labor and energy” into discreete steps, just as apples at the grocery store invisibilize their network through their single price tag</p>

<p>technical practice is hegemonic (it has a unique power in disciplining the body), and a microcosmic training ground</p>

<p>which kinds of ethics?
- ethics as values, in the data, or in the algorithm
- ethics as consequences, uses and impacts</p>

<h3 id="critical-journaling-in-teaching-programming">critical journaling in teaching programming</h3>

<ul>
  <li>
    <p>having students consistently reflect on thair practices (how are you applying what you’ve learned technically to the class? e.g. how does your interaction with food delivery change as you learn about functional abstraction?)</p>
  </li>
  <li>critique to teach responsibly</li>
  <li>critique to enable change over time, but not forget history</li>
  <li>critique to represent other approaches</li>
</ul>

<p>if programming embeds a certain capitalist order, can it also transform that order? is there anything essentially defining in a programming practice that “destines” it to being in a particular way?</p>

<p>-&gt; programming and capitalism are actually co-productive</p>

<h2 id="lucas-bang---program-size">Lucas Bang - program size</h2>

<p>simon penny -&gt; making sense
robin hill -&gt; expamples of phenomenology in computing
simon agre -&gt; computation and human experience</p>

<blockquote>
  <p>the quantity of meaning compressed into small space by algebraic signs, is another circumstance that facilitates the resasoning we are accustomed to carry on by their aid
charles babbage</p>
</blockquote>

<p>so, interestingly (blum size theorems), if you have a language that guarantees termination, the program size in such a language ends up being much larger than one written in a language that does not guarantee termination</p>

<p>“if you want to optimize your code, you have to write more code”</p>

<p>ref: subrecursive programming systems: complexity and succintness</p>

<p>the difference between theorems and programs is that theorems <strong>must</strong> be surveyable, while programs are ok if they’re not surveyable (most programs are actually non-surveyable since they’re abstracting all the time)</p>

<p>phenomenology:
- zuhanden/reayd-at-hand is about the “smoothly operating processes/relationships, which carry less cognitive load”
- vorhanden/present-at-hand is non-cooperating processes</p>

<h3 id="common-knowledge-in-programm-properties">common knowledge in programm properties</h3>

<p>gerald holzmann: nasa’s 10 rules for safety-critical code</p>

<p>ref: wadler: propositions as types
ref: soare, computability and recursion</p>

<p>a phenomenology of program size is needed</p>

<p>what is most important? the totality (program termination) or the size? he says size, but not why</p>

<h2 id="andre-dickson---the-ohenomena-of-conceptual-integrity">andre dickson - the ohenomena of conceptual integrity</h2>

<p>conceptual integrity: coherence (fred brooks), consistency (dave parnas)
disturbances: theory and death (naur)</p>

<p>modes of programs:
- programs as equipment
- programs as performance</p>

<p>conceptual integrity <strong>is not</strong> correctness, it <strong>is not</strong> correctness (e.g. changing market demands), <strong>is not</strong> about fit (e.g. it is possible to construct coherent interfaces that are quite awkward, such as MS-DOS), <strong>is not</strong> simplicity (dave parnas)</p>

<p>they keep mentionning phenomenology, but maybe they just mean formal, sensual representation</p>

<p>phenomenological progams:
- how one <strong>reads</strong> programs
- how one <strong>writes</strong> programs</p>

<p>gilbert ryle’s theory is <em>explicit</em>, while peter naur’s theory is implicit</p>

<p>seeing theory as equipment is based on a referent, equipment is in its sense usable for something. having a theory is the tool that allows us to be ready to think with it</p>

<p>conceptual integrity as equipmentality: when we see how clean the theory is, it becomes a tool to work with</p>

<p>better to have a reflection of one set of design ideas, rather than a bunch of unconnected ideas</p>

<p>can integrity be understood as resilience? open question</p>

<h2 id="daniel-kuby---towards-a-linguistic-conception-of-programming">daniel kuby - towards a linguistic conception of programming</h2>

<p>programming languages as linguistic frameworks</p>

<p>the question is: what are programming languages?</p>

<ol>
  <li>the <strong>machine-centered</strong> account of PL: they are formal notations for writing algorithms in machine-readable forms (they are not languages in the sense natural languages are) aka they are only languages in the metaphorical sense. the speaker disagrees</li>
</ol>

<p>the language as metaphor view: PL are not an <strong>object</strong> of investigation, they do not develop “naturally”, they are not acquired as first languages, they do not serve human-to-human communication</p>

<p>the point is to think of PL from a Natural Language NL perspective. (in a wider semiotic view, though, like software studies, it already is a language)</p>

<p>ref: marina umaschi bers at tufts has a cognitive study on this, similar to evelina fedorenko (the language of programming)
ref: janet sigmund: studying programmming in the neuroage: a crazy idea?</p>

<ol>
  <li>the <strong>linguistic account</strong></li>
</ol>

<p>the invention of higher PL is not developed to be better understood by machines, but to be better understood by humans</p>

<p>PL gave enormous cognitive advantadge, as they exploint our linguistic abilities, which has impications in the design of PL as a form of linguistic engineering</p>

<p>so the philosophy of tech was always focused on artefacts, but one could move towards the study of symbols, discourses, and phil of PL is the perfect moment to do so</p>

<p>PL do lack many features of full-fledged NL, but stand in some relationship with NL. yet, they are complete with respect to their ‘situational use’</p>

<p>both wittegenstein’s primary languages and frege’s begriffschrift can be called <em>restricted languages</em>, which develop in a community of speakers, sharing specialized knowledge and/or specialized activities (in linguistics, these can be called fachsprachen, controlled languages, sublanguages)</p>

<p>so the machine-centered account is too limited, the linguistic account recognizies the languagehood of programming, which happens through <strong>restriction processes</strong></p>

<h3 id="alice-martin-nicolas-nalpon---why-semantics-are-not-only-about-expressiveness">alice martin nicolas nalpon - why semantics are not only about expressiveness</h3>

<p>how PL represent a knowledge about a system is semantic representation</p>

<p>jean krivine - collège de france (2019) about knowledge representation</p>

<p>mathematical frameworks can be expressive, but still diverge in terms of semantic representation</p>

<p>and then he makes the example of taking a process p1 activated by p2 itself activated by a click. when you represent this with a bigraph on one side and lambda on the other side, there are differing results <strong>depending on whether you’re doing reactive programming, or non-reactive (function reducation)</strong></p>

<p>if you’re doing reactive, bigraph is 2 step, and lambda is 4 steps. if you’re doing non-reactive, you need 4 steps for bigraph, and 1 step for lambda (meaning semantics need to be distorted sometimes)</p>

<p>but is it even possible to find <strong>one</strong> framework for <strong>two types</strong> of instructions (currently a debate in reactive programming communities)</p>

<p>quantitatively, some representational systems do result in more steps depending on the task /!\</p>

<p>i’m not sure what is the relation between expressiveness and knowledge representations</p>

<p>and even when you move from diagramming from source code, you’re actually changing the epistemic criteria (code has different implications than diagramming), one should then find a “ground truth” that happens across</p>

<p>ref: temporal semantics of reactive systems</p>

<h3 id="robin-hill---hello-world-an-interrogation">robin hill - hello world? an interrogation</h3>

<p>why is hello world useful? it’s neither required nor sufficient</p>

<ol>
  <li>it’s arbitrary</li>
  <li>tells us sth about the environment</li>
  <li>tells us sth about the programming</li>
</ol>

<p>re: 3. it allows you to learn how to use the objects, the paradigms of sequentiality, literalness, sanity check</p>

<blockquote>
  <p>the usefulness of the term ‘,ateriality’ is thjat it identifies those constituent features of a technology that are readily available to all users (leonardi, materiality, socio-materiality)</p>
</blockquote>

<p>hello world is useful insofar as it is teaching not the algorithm, but the tool use: the tools are program code rather than hammers and engines. hello world focuses on the interface, the programming environment, its materiality. what kind of materiality is that? what are the other levels of expertise?</p>

<h1 id="day-2-linkhttpsprogrammehypothesesorgspring-workshop-iii-what-is-a-computer-program-final-conference">day 2 <a href="https://programme.hypotheses.org/spring-workshop-iii-what-is-a-computer-program-final-conference">link</a></h1>

<h2 id="baptiste-mls---classifying-programs">baptiste mélès - classifying programs</h2>

<p>tension between the unicity of the notion of program vs. diversity of existing programs</p>

<p>comparative analysis: few and isolated classifications / heterogeneous goals / minor subject matter but they are useful in their abstractions</p>

<p>brooks: flexibility / architecture
lehman: more scientific / technical</p>

<p>classifications have to deal with current state but also have to deal with anticipating future programs</p>

<p>one approach can be through <strong>signs</strong> (human reading, machine reading, both)</p>

<ul>
  <li><strong>autotelic</strong>: server, video games</li>
  <li><strong>heterotelic</strong> : producing files, text, video</li>
</ul>

<p>kinds of machines (physical machines, abstract machines)</p>

<p>interesting question: today people don’t speak of programs, they speak of apps. what is the difference?</p>

<p>machine program: a layout of assigns aimed at determining the beahviour of a machine in an environment</p>

<p>turns out that compilers can change the meaning of programs, which defeats the dream of having logic supremacy when it comes to designing programs</p>

<p>logic as motherland, implementations as colonies</p>

<h2 id="tomas---notation-there-is-no-escape">tomas - notation: there is no escape</h2>

<p>we need notational pluralism for meaningful programs!</p>

<h2 id="marteen-bullynck---machines---hide-and-seek">marteen bullynck - machines - hide and seek</h2>

<p>human &lt;–&gt; program interface &lt;–&gt; machine</p>

<p>the point of programming languages has been to try to decouple themselves from a machine</p>

<p>but sometimes the machine strikes back (moore’s law coming to an end, for instance)</p>

<p>virtual machines: don’t exist, but can see them
tranparent machines: exist, but can’t see them</p>

<p>so the argument is that it is important to consider the machine (consider new architectures, ASIC, GPGPU, etc.), and it allows us to shed a new light on how software is written</p>

<p>they also use a lot of energy (e.g. obv blockchain)</p>

<h2 id="what-is-a-system">what is a system?</h2>

<p>a system is a stabilised heterogeneous situation. its parts, we usually call members. in the case of computing, computing = computers + all the files + all the users</p>

<p>in an open state, in hacker culture, everyone has to take care of everything, implicit knowledge is bound to people</p>

<blockquote>
  <p>in programming, there are also systems like type-in systems that are beautiful because they are closed. because they have a self-repair through extensive naming/tagging of what is what. this strict structure helps with the maintenance</p>
</blockquote>

<p>explication of unity (systemd, all these different parts of a linux distribution come together) vs. explication of multiplicity, vs. implication of multiplicity</p>

<p>does complexity close the system? by making it too obscure, etc.?</p>

<h2 id="programmer-attention">programmer attention</h2>

<p>ranges from undecidability to np completeness to space complexity, to time complexity, to correctness</p>

<p>computing is the interaction of the human with the human, the computer, and the model</p>

<h2 id="alberto-naibo-and-julian-rohruber---abstract-programs--postponing-concrete-knowledge">alberto naibo and julian rohruber - Abstract programs – postponing concrete knowledge</h2>

<p>a program is <strong>reified future</strong> (and as such, it might be magic, with ref from: alfred gell, the technology of enchantment and the enchantment of technology)</p>

<p>an ideal program is one which <em>1</em> should work under all circumstances and <em>2</em> should work according to its purpose</p>

<p>but under “all circumstances” means everything, and sadly there is no specification of “everything” because by definition, a specification is special</p>

<p>abstraction is the process of forgetting (neglecting, rpressing, hiding) something concrete; ignoring aspects, selecting only some (color, type, index)</p>

<p>def: concrete objects cause the <strong>convergence</strong> of determinations, e.g. everyday objects unify touch and sight, an entry in a database unifies memory state and data access</p>

<ul>
  <li><strong>concrete objects</strong> cause a convergence of multiple determinations</li>
  <li><strong>abstract objects</strong> cause a divergence of multiple determinations</li>
  <li><strong>abstraction</strong> means tuning a medium for abstract objects</li>
</ul>

<p>concreteness implies immediate recognizability, abstractness requires indirect access, abstraction means organizing indirectness</p>

<p>so, in a sense, abstraction does also have some aspects of concreteness, since it <strong>reduces</strong></p>

<h2 id="time-in-computer">time in computer</h2>

<p>the physical time of machines syncs up with the psychophysical world of human beings, needing a reciprocity of perspectives</p>

<h2 id="meaning-of-programs">meaning of programs</h2>

<ul>
  <li>newell and simon: programs predict human intelligent behaviour through differential equations</li>
  <li>thagard: building a theory is actually about building a machinery able to give an account of the object phenomenon</li>
  <li>johnson-laird: concepts must be viewed as “models”, i.e. tools to decide on a situation and equipped with procedures</li>
  <li>naur: about building a working model of a real-life situation and of the role of the software that enables it</li>
</ul>

<p>fetzner: there are five layers of models at play:</p>

<ol>
  <li>specification</li>
  <li>algorithm</li>
  <li>high-level programming language</li>
  <li>assembly</li>
  <li>machine code</li>
  <li>computational system (i.e. machine)</li>
</ol>

<p>propositional theory of meaning: associating expressions of the language to entities (propositions). this is how this stuff gets connected to one another. otherwise, in PL, there’s also <em>denotational</em> semantics (associating instructions of math functions) or <em>operational</em> semantics (associating programs to actions/automata)</p>

<h2 id="indeterminacy">indeterminacy</h2>

<p><code>c
int x = 0;
bool go_on = true;
while (go_on) {
  x = x + 1;
  []
  go_on = false;
}
</code></p>

<p>by djikstra</p>

<p>then, floyd (1967): a non-deterministic program is not governed by efficient causes (cause preceding effect), but by final causes (goals lead to choosing causes for effects).</p>

<blockquote>
  <p>We may say that there algorithms are non-deterministic, not in the sense  of being random, but in the sense of having free will.</p>
</blockquote>

			</div>
		</body>
	</html>
