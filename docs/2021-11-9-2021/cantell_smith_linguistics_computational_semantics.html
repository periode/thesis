
	<!DOCTYPE html>
	<html>
		<head>
			<meta charset="utf-8"/>
			<title>works in public</title>
			<link rel="stylesheet" href="/style.css"/>
		</head>
		<body>
			<div class="way">
				<a href="/index.html">cover</a>
			</div>
			<div class="holding tight">
				<h1 id="linguistic-and-computational-semantics">linguistic and computational semantics</h1>

<h2 id="brian-cantwell-smith">brian cantwell-smith</h2>

<hr />

<p>if computational artefacts are fundamentally linguistic (apparently a widely held view), what is the proper relationship betweenm the so called computational semantics and more standard linguistics?</p>

<p>this seems to have been disproved by recent neuropsychology experiments, and therefore the paper might only be interesting as the linguistic base of source code (a base that is no longer the only one, there is also architecture)</p>

<hr />

<blockquote>
  <p>because the very concept of computation rests on notions of interpretation, the semantics of natural languages and the semantics of computational formalisms are in the deepest sense the same subject.</p>
</blockquote>

<p>he has a system to understand computational semantics, and attempts to apply it to (computationally-oriented) natural semantics</p>

<p>there should be both <strong>declarative</strong> and <strong>procedural</strong> expressions</p>

<p>computers are devices that we understand by deploying our linguistic faculties, meaning we take the ingredients of computation to be <em>symbolic</em> (and not literal)</p>

<p>the computer’s <em>raisn d’être</em> is dual: their mechanical objects and their semantic interpretability.</p>

<p>he based this on the fact that linguistic domain permeates the CS jargon (symbol manipualation, langue, intepreter, value, variable, expression, etc.)</p>

<p>one thing to keep in mind is that, in CS, semantics are always <strong>operational</strong> semantics, wihle natural semantics are <strong>denotational</strong> or <strong>referential</strong>.</p>

<p>we move from the syntactic domain to the semantic domain through an <em>interpretative function</em> (whether is domain is syntactic or semantic is a matter of point of view)</p>

<p>(1) internal representations between symbols (what he calls procedural consequence) vs. (2) external representations towards the world (what he calls declarative imports). the <strong>formality condition</strong> is that a programming language can give a full account of (1) without referring to (2)</p>

<blockquote>
  <p>In particular, we demonstrated that the universally a:cepted LISP evaluation protocol is semantically Confused, in the following sense: sometimes it preserves • (i.e. ~(,I,(S)) = ~,(s)), and sometimes it embodies • (i.e., ,l,(s) = ,~,(s)). The traditional LISP notion of evaluation, in other words, conflates <em>simplification</em> and <em>reference</em> relationships, to its peril (in that report we propose some LISP dialects in which these two are kept strictly separate).</p>
</blockquote>

<blockquote>
  <p>In other words, in a computational process that deals with finance, say, the general data structures will likely designate individuals and money and relationships among them, but the terms in that pan of the process called a program will not designate these people and their money, but will instead designa:~’ the data ztructures that designate people and money (plus of course relationships and functions over those data structures).</p>
</blockquote>

<p>the above quote is the computational investigation equivalent of <em>sinn und bedeutung</em>, such that there are similar issues in natural and programming languages</p>

<p>he also has fairly nice examples using MacLisp</p>

<blockquote>
  <p>procedural semantics and declarative semantics are two pieces of a total story; they are not alternatives</p>
</blockquote>

			</div>
		</body>
	</html>
