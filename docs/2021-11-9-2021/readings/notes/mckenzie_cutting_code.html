
	<!DOCTYPE html>
	<html>
		<head>
			<meta charset="utf-8"/>
			<title>works in public</title>
			<link rel="stylesheet" href="/style.css"/>
		</head>
		<body>
			<div class="way">
				<a href="/index.html">cover</a>
			</div>
			<div class="holding tight">
				<h1 id="cutting-code-on-software-and-sociality">cutting code: on software and sociality</h1>
<p>## adrian mckenzie</p>

<ul>
  <li>sociological, STS</li>
</ul>

<h3 id="chapter-1">chapter 1</h3>

<p>software as social object/material and process/practice, involving:</p>

<ul>
  <li>mutability</li>
  <li>contingency</li>
  <li>necessity</li>
</ul>

<blockquote>
  <p>software undergoes phase transitions.</p>
</blockquote>

<p><em>technical practices and contexts of software interlace with cultural practices and contexts</em></p>

<p>formalism: software is just relation and operations, and the beauty of context-free grammars is that software works regardless of its purpose</p>

<p>an ontology is like a formal specification of a program, describing concepts and relationships, but anthropology and sociology always need “situated practices”</p>

<p>attribution of agency (who/what does what to whom/what) is a precondition of any social relation whatsoever. software has <em>secondary</em> agency, in that it extends the agency of the programmer/hacker/corporation.</p>

<p>code involes:
1. index (it indicates (or hides) something)
2. originators (producers)
3. recipients (humans/machines)
4. prototypes (simulations -i find this category a bit narrow, all a computer does is simulate)</p>

<p>but none of these are clearly delimited between one and the other</p>

<h3 id="chap-2">chap 2</h3>

<p>the big tensions is on <strong>code between operation and expression</strong> (maybe the operation of an expression)</p>

<blockquote>
  <p>Kittler diagnoses code as comething peoiple read and write yet cannot comprehend because it has been encrusted with a layered architecture that sequesters code in accessible interior spaces.</p>
</blockquote>

<p><strong>temporal inaccessibility</strong>: the software is too fast to understand, it’s impossible to experience it as expression and operation at the same time.</p>

<p>he says that code poetry is kitsch art, the computing equivalent of dabbling in paint by numbers -&gt; i think there is much more to that, that it is possible to write code-specific poems, rather than as refractions of human languages. it’s just an introduction to the topic. good poetry (software art) is one which acknowledges its own execution.</p>

<p>how are software artists different from code poets? <strong>the former don’t pay attention to form, just to effect</strong> (is form and effect always separate?)</p>

<p><em>Code may in a general sense be opaque and legible only to specialists, much like a cave painting’s sign system, but it has been inscribed, programmed, written.  It is conditioned and concretely historical.  Whether or not non-human agents have had a ‘hand’ in its formulation, code remains not only a constructing force but also that which is constructed.</em></p>

<p>Highly recursive. extreme programming treats “the program” as both the object and model of work.</p>

<p><strong>every programming language is already an ontology</strong></p>

<blockquote>
  <p>Well-known code constructs such as loops, conditionnal tests, and data structures (arrays, queues, stacks, dictionaries) in popular programming languages <strong>afford this concentration or intensification of movements</strong> (p.57)</p>
</blockquote>

<h3 id="chap-3">chap 3</h3>

<blockquote>
  <p>the orderings of social fields associated with software hinge on formatl properties of algorithms that often assume an immutable, general aura.</p>
</blockquote>

<p>-&gt; algorithms <em>naturalize</em> a certain order, they organize informatic time, which results in abstraction. (and yet, these abstractions are still related to a concrete framework in real-life).</p>

<table>
  <thead>
    <tr>
      <th>SPACE</th>
      <th>TIME</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>DATA STRUCTURE</td>
      <td>ITINERARY</td>
    </tr>
  </tbody>
</table>

<h3 id="chap-4---linux-kernel">chap 4 - linux kernel</h3>

<p>p. 87: why is this piece of hardware code in the linux kernel considered ugly? because of the magic number, because it <em>imitates</em> (literal display) rather than <em>represents</em> (extracts an essence that is not exclusively dependent on a specific place and time). there’s a tension between hardware and software.</p>

<p>RadioFreeLinux as an example of the hybridity of circulation modes.</p>

<h3 id="chap-5---jvm">chap 5 - jvm</h3>

<p>the virtual machine is the “ideal machine”. it’s mostly a discussion of the concept of virtual, which is less hyped today.</p>

<p>the VM influences the circulation of software, and its writeability</p>

<p>btw, Java is a lexical pastiche of C++ in order to maintain familiarity of developers with the language. but the Java APIs become a mess of their own -&gt; code reading extends beyond the screen and into the docs</p>

<h3 id="chap-6">chap 6</h3>

<p>code as collective imagining is a response to software is losing its locality</p>

<h3 id="chap-7">chap 7</h3>

<p>because it deals with information, people think that software deals with abstraction.</p>

<p>the more code you write, the mode complex and messy (while you’d expect the opposite, in terms of adding more and more abstraction).</p>

<p><em>extreme programming</em> asserts the position of programmers as originators of software (as a local practice)</p>

<h3 id="conclusion">conclusion</h3>

<p>the status of code is distributed along agency, materiality and sociality</p>

<p>(sidenote: aesthetics relate to opacity)</p>

			</div>
		</body>
	</html>
