
	<!DOCTYPE html>
	<html>
		<head>
			<meta charset="utf-8"/>
			<title>works in public</title>
			<link rel="stylesheet" href="/style.css"/>
		</head>
		<body>
			<div class="way">
				<a href="/index.html">cover</a>
			</div>
			<div class="holding tight">
				<h1 id="programming-languages">programming languages</h1>

<p>in this part, the set of aesthetic features, composed from both empirical observations and theoretical constructions, is re-examined in the light of the linguistic environments as provided by programming languages. after having elaborated a concept of clarity, I will see <em>if</em> and <em>how</em> programming languages modulate this concept. programming languages will be investigated both as semantic systems, but also as socio-economic systems. by seeing how discourses on clarity vary between programming languages communities, it will be possible to identify such a structural influence and integrate it within our concept of clarity.</p>

<p><a href="../readings/notes/iverson_notation_as_tool_for_thought.md">iverson notation tool for thought</a>
<a href="../readings/notes/cantell_smith_linguistics_computational_semantics.md">cantwell smith computational linguistics</a></p>

<h2 id="the-programming-language-object">the (programming) language object</h2>

<p><a href="../readings/notes/scott_programming_language_pragmatics.md">scott_programming_language_pragmatics</a>
<a href="../readings/notes/sethi_programming_languages_constructs_concepts.md">sethi_programming_languages_constructs_concepts</a></p>

<p>this section explores the conceptual definition of a programming language (from a CS and philosophy standpoint), but also the role of language in aesthetics (comparison french vs. german, thomas mann avec ses verbes a la fin)</p>

<p>the question of operational meaning vs. denotational meaning should be explored. what means what to the computer?</p>

<p>[crozat_theorie_operationelle_ecriture_numerique]] -&gt; a bit too high-level, bu](../readings/notes/crozat_theorie_operationelle_ecriture_numerique]] -&gt; a bit too high-level, bu.md)nice concepts about digital writing/layerings of digital writing (binary-theoretical / technical-applicable/semiotical-rhetorical)</p>

<p>the fact that it’s abstract as hell can also be seen as a cultural influence/related to chomsly <a href="../readings/notes/elated to chomsly [golumbia_cultural_logic_computation.md">golumbia_cultural_logic_computation</a></p>

<p><a href="../readings/notes/milner_semantic_ideas_programming_languages.md">milner_semantic_ideas_programming_languages</a>
<a href="../readings/notes/stansifer_study_of_programming_languages.md">stansifer_study_of_programming_languages</a>
<a href="../readings/notes/homem_topics_in_programming_languages.md">homem_topics_in_programming_languages</a>
<a href="../readings/notes/sustrik_linguistics_programming_languages.md">sustrik_linguistics_programming_languages</a>
<a href="../readings/notes/turner_programming_languages_technical_artefacts.md">turner_programming_languages_technical_artefacts</a></p>

<blockquote>
  <p>State introduces an abstract notion of time in programs. In functional programs, there is no notion of time… Functions do not change. In the real world, things are different. There are few real-world entities that have the timeless behaviour of functions. Organisms grows and learn. When the same stimulus is given to an organism at different times, the reaction will usually be different. How can we model this inside a program? We need to model an entity with a unique identity (its name) whose behaviour changes during the execution of the program. To do this, we add an abstract notion of time to the program. This abstract time is simply a <em>sequence of values in time</em> that has a <em>single name</em>. We call this sequence a named state.</p>
</blockquote>

<h2 id="the-programming-language-ecosystems">the programming language ecosystems</h2>

<p>ref: masterminds of programming</p>

<p>each of these sections will highlight both the <em>paradigms</em> as well as the <em>syntactic</em> features of the main categories of programming languages. the point will be to highlight what they share, and how they differ, and that what they share is a very core concept. how that concept is implemented however differs, which is inherently an aesthetic decision (as we will see with Ruby or Go for instance). this categorical approach will also necessarily include a historical dimension, as well as a discussion of which programming communities gravitate around which languages</p>

<p>[vee_coding_literacy]], <a href="../readings/notes/vee_coding_literacy]], [coding_literacies_annette_vee.md">coding_literacies_annette_vee</a></p>

<ul>
  <li>notes</li>
  <li>
    <ul>
      <li>which aesthetic standards are set by the machine vs. which aesthetic standards are set by human social context?</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>place of the IDE: syntax highlighting, auto complete: material conditions to make materiality disappear</li>
    </ul>
  </li>
</ul>

<p><a href="../readings/notes/http://www.cs.albany.edu/~sdc/CSI500/Downloads/ProgrammingParadigmsVanRoyChapter.pdf">programming paradigms - van roy</a>, along with a helpful <a href="../readings/notes/https://blog.acolyer.org/2019/01/25/programming-paradigms-for-dummies-what-every-programmer-should-know/">summary</a>. most importants seem to be concepts of <em>named state</em>, <em>records</em> (structs, arrays), <em>closure</em>, <em>independence (concurrency)</em> (which supports shared-state or message passing).</p>

<blockquote>
  <p>Each paradigm has its own “soul” that can only be understood by actually using the paradigm. We recommend that you explore the paradigms by actually programming in them (van roy)</p>
</blockquote>

<ul>
  <li>functional programming</li>
  <li>declarative programming (at the beginning of it all)</li>
  <li>object oriented programming
    <ul>
      <li>paid close attention to developments in cognitive theory (piaget, papert, montessori)</li>
    </ul>
  </li>
  <li>esoteric programming
    <ul>
      <li>
        <blockquote>
          <p>when we talk about esolangs, we are designing a perspective for someone to think through. -daniel temkin <a href="../readings/notes/https://www.artistsandhackers.org/Critical-Code">src</a></p>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>

<h2 id="meaning-in-programming-languages">meaning in programming languages</h2>

<p>this section looks at how language-dependent the previously exhibited features of aesthetics might be affected by it. however, we’ll see that this isn’t so much a clear distinction as it is a gradient between fully language dependent (and the extreme: hardware dependent—hallo kittler).</p>

<p>procedural rhetoric is just a very high level of programming semantics. processes with meaning assigned to it. &lt;- this further extends the gradient.</p>

<p>[winograd_language_as_cognitive_process]]](../readings/notes/winograd_language_as_cognitive_process]].md)[winograd_flores_understanding_computers_and_cognition]]](../readings/notes/winograd_flores_understanding_computers_and_cognition]].md)<a href="../readings/notes/eijick_computational_semantics_functional_programming.md">eijick_computational_semantics_functional_programming</a></p>

<p>syntax vs. semantics?</p>

<blockquote>
  <p>There’s a lot of attention to <strong>COMPRESSION</strong>, using the underlying programming language in a way that’s easy to penetrate - richard gabriel <a href="../readings/notes/https://www.dreamsongs.com/PoetryOfProgramming.html">src</a></p>
</blockquote>

<h3 id="computer-beauty">computer beauty</h3>

<p>whether or not the computer understands is not an aesthetic problem, but an engineering problem. <strong>BUT</strong> there are beauties in engineering</p>

<p>however, one would argue that a beauty for the computer is <a href="../readings/notes/https://gameprogrammingpatterns.com/data-locality.html">data locality</a>, due to the very practical issue of data access (and subsequent caching)</p>

<h3 id="a-discussion-of-idiomatic">a discussion of “idiomatic”</h3>

<p><code>TODO</code> how does it relate to “understanding”?
programming idioms - <a href="../readings/notes/https://wiki.c2.com/?ProgrammingIdiom">c2</a> - <a href="../readings/notes/https://stackoverflow.com/questions/302459/what-is-a-programming-idiom">so</a></p>

<h3 id="language-dependent-features">language-dependent features</h3>

<p>language dependent features will be:</p>

<ul>
  <li>the degree of abstraction/dependency</li>
  <li>the naming of variables</li>
  <li>the socio-economic ecosystem</li>
  <li>conceptual distance</li>
</ul>

<h3 id="language-independent-features">language-independent features</h3>

<ul>
  <li>uniqueness</li>
  <li>white space and layout</li>
  <li>scope of actions (e.g. just one action at a time)</li>
  <li>double-coding and metaphors</li>
</ul>

<p>there could be different beauties in writing and in reading (case of Mike’s APL) - easier to read vs. easier to type</p>

<p>what is the aesthetic of a semantic system that is supposed to be understood by both humans and machines? <strong>if there is a collapse of both those systems, it hints at the fact that the human becomes machine</strong></p>

<h2 id="language-as-material">language as material</h2>

<p>from hardware to tokens</p>

<p>when i talk about materiality, i should also contextualize it with other materialities (build processes, hardware, etc)</p>

<p>markers of spatialization:
- <code>GOTO</code>
- the trace (stack trace, execution trace) (like ariadne’s thread)
- localness [allamanis_survey_for_big_code_naturalness_language#patterns]](../readings/notes/ localness [allamanis_survey_for_big_code_naturalness_language#patterns].md)
	- localness is syntactic, non-localness is semantics
- <a href="../readings/notes/https://en.wikipedia.org/wiki/Dangling_else">dangling else</a></p>

<p><a href="../readings/notes/simondon_mode_existence_objets_techniques.md">simondon_mode_existence_objets_techniques</a></p>

			</div>
		</body>
	</html>
