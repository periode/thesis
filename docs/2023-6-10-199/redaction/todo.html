
	<!DOCTYPE html>
	<html>
		<head>
			<meta charset="utf-8"/>
			<title>works in public</title>
			<link rel="stylesheet" href="/style.css"/>
		</head>
		<body>
			<div class="way">
				<a href="/index.html">cover</a>
			</div>
			<div class="holding tight">
				<h1 id="todo">todo</h1>

<p><strong>VERY IMPORTANT</strong>: I should state very very clearly what it is that I am doing. Also that a huge majority of the code is software engineer code, and that code poetry are just distinctly related.</p>

<p>recs from guido, neuropsychologists who might be interested:</p>

<ul>
  <li>stanislas dehaene</li>
  <li>christophe paillier</li>
</ul>

<p>séminaire adrien puignot: principe de la <em>sémiotique sociale</em>, i.e. la fabrique de sens globale.</p>

<p><em>architexte</em>: L’ensemble des catégories générales, ou transcendantes -types de discours, modes d’énonciation, genres littéraires, etc.- dont relève chaque texte singulier (genette). En gros, la méta-catégorie des catégories. Ce qui gouverne le texte. L’outil d’écriture n’est pas neutre, il impose des formes éditoriales et des formats d’écriture au scripteur. Il permet aussi la recomposition des “traces” de lecture (échange, co-construction, démantèlement)</p>

<p><em>infra-ordinaire</em>: infra-ordinaire en tant qu’observation attentive de « ce qui se passe chaque jour et revient chaque jour, le banal, le quotidien, l’évident, le commun, l’ordinaire, l’infra-ordinaire, le bruit de fond, l’habituel. l’attention portée aux détails du réel apparaît comme une constante qui finira par devenir une théorie rassemblant la pensée et la pratique littéraires de l’auteur</p>

<ul>
  <li>deal with inline quotes properly (using the <code>dirtytalk</code> package)</li>
</ul>

<p>add this to examples, from the rust parser example i forked, as an example of how people assign quality to proper scale naming:</p>

<p><code>rust
// Level-change Operator (what a stupid name)
operator_level = { operator_exp | operator_subscript |
                   operator_exp ~ operator_subscript |
                   operator_subscript ~ operator_exp
}
</code></p>

<p>quote from peter neumann: “these techniques may have enormous value in providing nontrivial assurances that the system might actually do what is expected of it . “ - “There are many problems arising in complex systems that must be thoroughly comprehended, but that once understood can be structured in a way that conceptually simplifies the design”</p>

<p>Include the fact that aesthetics help compress, and by compressing, people can hold more things in short term memory</p>

<p>include somehow:</p>

<p>```text
struct</p>

<p>Brenda Baker undertook her Fortan-to-Ratfor converter against the advice of her department head–me. I thought it would likely produce an ad hoc reordering of the orginal, freed of statement numbers, but otherwise no more readable than a properly indented Fortran program. Brenda proved me wrong. She discovered that every Fortran program has a canonically structured form. Programmers preferred the canonicalized form to what they had originally written.
https://web.archive.org/web/20200315093052/https://minnie.tuhs.org/pipermail/tuhs/2020-March/020664.html
```</p>

<p><strong>ENHANCE CLARITY</strong></p>

<h2 id="chap-5---programming">chap 5 - programming</h2>

<ul>
  <li>[ ] proofread subsec between human and machines</li>
  <li>[ ] there is no example of iterating in 5.1.2</li>
  <li>[ ] all figures (especially fig. 51, 52) need to be very much explicited: “we need to be lead into why that is even an issue” / define reasonable examples for each / show different return types in fig. 51</li>
  <li>[ ] for the threads, first define what a <code>process</code> is so that we can understand what a <code>thread</code> is, also show the non-threaded version? explain how the sequential outcome is bouleversé?</li>
  <li>[ ] look into why we can’t return <code>[]int</code> in c</li>
  <li>[ ] in golang, the <code>_</code> identifiers are not about the error, but about ignoring things. show that it differs in JS or Python</li>
  <li>for fig. 62, step through a computer interpretation of the process, before giving a literary interpretation of the process.</li>
  <li>for the code poems, I need to be able to articulate their relevance when looking at different domains. they’re not just related to literature, but also architecture (follies, pavillions) or math (pure math), while other source code (linux kernel) might also be a sort of literature (legal code). but also make it explicit that i talk about the ones that can run, not the code poems that are not executable</li>
  <li>[ ] rather than having 5.3 as this total disconnect, maybe start by writing a monolith to avoid the pitfalls of structure. particularly because at this point i need to synthesize. rather work on <em>connections and disconnections</em> between the social and the functional?</li>
  <li>in the case of list comprehension in Python, it is both a technical and social environment</li>
</ul>

<h2 id="chap-4---understanding">chap 4 - understanding</h2>

<h3 id="meeting-with-nick-1414">meeting with nick 14.14</h3>

<p>overall, I should keep in mind that I do not have a technical audience, and I should rework/remove a lot of the examples, and add extensive discussions and rationale as to why those examples are there</p>

<p>I should also address the status of AI-generated code (include, not include? I consider it the same as compiler code).</p>

<p>For Languages of Art, two things about exemplification vs. implementation:</p>

<ul>
  <li>different implementations of a concept are necessary but not sufficient for aesthetic judgment. programs exemplify because different implementations exist</li>
  <li>an implementation does not necessarily exemplify: it needs (amongst other things?) CONTEXT.</li>
</ul>

<p>In architecture, highlight the fact that the <em>detail</em> is the point of interaction between the human and the structure.</p>

<ul>
  <li>p.218, clarify and enumerate what those 5 requirements of the language of art are.</li>
  <li>p.220, make it clear that <code>var auth_level</code> is actually two different tokens, one by the designer, one by the programmer</li>
  <li>listing 35, if i’m talking about OOP use a more oop language (java, python)</li>
  <li>p. 221 when i talk about source code showing properties of an object. objects only have properties through the fact that they are being modelled: source code is a model of the world in which objects have properties. from a philosophical perspective, objects do not always have properties, but the program’s concept of the world GIVES IT properties.</li>
  <li>p. 223: match the 5 criteria as they were mentioned in the first bullet point</li>
  <li>p.243: when discussing the god example: again, highlight the ontology of markup: inside and outside. There are differences between conceptual spatialization, layout spatialization (the most obvious that we see), and disk fragmentation. The cartesian view of space is different from the one listing 40 (space in 40 is different from a map).</li>
  <li>Listing 40: make it expliciti that it is presented in such a way that highlights the indented/contained nature of markup (indentation)</li>
  <li>Listing 41: no line numbers and most importantly, NOT CLEAR THAT THIS IS RELATED TO SPATIALITY. might be related to SSD/virtual memory/start addresses, but find a better example. maybe start with python, and indentation, related to semantics.</li>
  <li>p.248: mention what are the specific things in architecture: the main thing in architecture is about sight (develop this in the form/function section). ALSO SITE-SPECIFIC: materials+context. Architecture: building codes and requirements, that is not there in lit or math. architect is neither an engineer nor a fine artist.</li>
  <li>Figure 4.2: the plan and the program are different: this is a plan, and the program is different. the program is equivalent to the system requirements.</li>
  <li>Listing 42: hard to tell what this does, might not be worth keeping, or include an extensive discussion of separation of concerns.</li>
  <li>p.263: nick disagrees, don’t say that compression isn’t so much a problem in poetry, but rather a different kind of problem.</li>
  <li>Listing 44: again, the point of these examples as an illustration of refactoring is also not clear, should be commented a lot more</li>
  <li>p.280: graphical representation/diagram is not uniquely artistic, it is that it adds choices, and calls for attention. not just because its a circle does it mean its better, but rather because it’s a different way to represent the same thing, which I argue implies the possibility for a value judgment.</li>
  <li>Listing 45: maybe give a diagrammatic representation of the linked list? there’s an abstract concept, this text is a particular representation of it, and a diagram could be another. strip down the example to the very bare minimum, and include very robust and helpful discussion of that discussion. this is too obscure.</li>
  <li>listing 46: regex matcher:  regex is a formalism for processing text. convey that this is a complex problem, but that you can actually write a fairly simple program to implement it. In general, I should always discuss extensively the listings.</li>
  <li>Listing 47: still write about refactoring, but maybe with a shorter program. use the simplest case that makes my point. make that point with elaboration and extent discussion. BUT ALSO PREFACE IT WITH A PYTHON EXAMPLE. So have two listings in the end.</li>
  <li>allamanis, using ML for code generation and analysis, and mattt (as we may code) highlights the need for such a thing (quoting: What if, instead of lowering source code down for the purpose of execution, we raised source code for the purpose of understanding?)</li>
</ul>

<h3 id="meeting-with-nick-0704">meeting with nick 07.04</h3>

<ul>
  <li>do not keep the conclusion a secret, state what the theory is in the introduction, straight away, then provide evidence throughout in the conclusion (that aesthetics are multi-faceted, often involve knowledge and communication, either ot machine or to human)</li>
</ul>

<h2 id="chap-3---beauty">chap 3 - beauty</h2>

<ul>
  <li>include \citep{dexter_embodied_2011}</li>
  <li>[ ] put less code poems in this section, both nick and alexandre disagree, seem like it is a bit of a far-fetched example, because this is about the uselessness. <strong>my counter-argument</strong> is that while it seems that code poetry is useless in the sense that art is useless, not directed, not productive, etc. it is nonetheless functional from the point of the machine, in that it does complex operations. One can also draw an equivalent with Sol Lewitt, and his sentences on conceptual art, in which the “idea is a machine that makes the art”. It functions in the machine sense of the term, perhaps not on the human sense. Conversely, some algorithms function on the</li>
  <li>[ ] literature: acknowledge that narrativity and authorship aren’t so much a thing here.</li>
  <li>[ ] literature: include a section about poetry: <a href="https://jacket2.org/commentary/poetry-executable-code">https://jacket2.org/commentary/poetry-executable-code</a> / <a href="https://volltext.net/texte/cornelia-travnicek-code-poetry/">https://volltext.net/texte/cornelia-travnicek-code-poetry/</a></li>
  <li>[ ] add meles and UNIX</li>
  <li>[ ] literature: include that code is not literature: <a href="https://gigamonkeys.com/code-reading/">https://gigamonkeys.com/code-reading/</a></li>
  <li>[ ] mathematics: add a discussion of dijkstra’s shortest path algorithm?
the code for the irrational equations:</li>
</ul>

<p><code>tex
    % \begin{align}
    %     \sqrt{2}     &amp; = p / q        \\
    %     \sqrt{2} * q &amp; = p            \\
    %     p            &amp; = \sqrt{2} * q \\
    %     (\sqrt{2})^2 &amp; = (p/q)^2      \\
    %     2            &amp; = p^2 / q^2    \\
    %     p^2          &amp; = 2 * q^2
    % \end{align}
</code></p>

<h3 id="meeting-with-nick---28122022">meeting with nick - 28.12.2022</h3>

<ul>
  <li>for each of the aesthetic domains (lit, arch, eng, math), add source code examples to show what is similar, and what is different in source code vs. original domains -&gt; <strong>INTERTWINE!</strong></li>
  <li>my approach to metaphors should be more systematic: that is, I should look into how metaphors can represent a SYSTEM (for instance, <code>symlink</code> is a limitation when it comes to the files and folder metaphor)</li>
  <li>e.g. how does step in a debugger relate to code as terrain, or surface coverage for tests? e.g. how does build and architecture related to code as structure?</li>
  <li>ask “why does the metaphor work?” -&gt; how do they (a) combine (b) extend (c) question?</li>
  <li>look at all the metaphors that fit together (in the lit domain, the arch domain, etc.)</li>
  <li>metaphor of the <code>macro</code> (implies scale), of <code>scope</code>, of <code>global</code>, implies scale as well. <code>libraries</code> is also a metaphor that is literary.</li>
  <li>add knuth on dijkstra, simple program, complex proof (knuth, simple, 1990)</li>
  <li>
    <p>add wallen_form_1990 with his argument that mathematics rely on the fact that sight is our most developed sense</p>
  </li>
  <li>
    <p>fictionality: creates a model of the world. while i make the distinction between fiction and non-fiction, i should focus on why it is fiction that acts as a simulation (i.e. jerome pelletier, nelson goodman, marie laure ryan “textual actual worlds”) -&gt; essentially show that fiction might be as relevant as non-fiction in source code</p>
  </li>
  <li><strong>case studies</strong>
    <ul>
      <li>choose the case-studies in the way that is the most illustrative of my point. doesn’t have to be huge.</li>
      <li>i should definitely have a more comparative approach: multiple code-bases, with aesthetics which are tied to <strong>LANGUAGE</strong>, <strong>COMMUNITY</strong> and <strong>PROBLEM</strong> (question of the idiomatic). this is better than having one case study after another, completely discontinued.</li>
      <li>find similar problems in different programs, see how they deal with it</li>
      <li>find specific cases where the cognitive load is high</li>
      <li>again, <strong>DO IT IN PARALLEL</strong> as a comparative studies.</li>
    </ul>
  </li>
</ul>

<p><em>side note: are metaphors related to space because it’s hard for us to think in terms of time?</em></p>

<h2 id="chap-2---understanding">chap 2 - understanding</h2>

<ul>
  <li>[ ] include elgin’s paper: from knowledge to understanding, in order to buttress our definition of understanding.</li>
  <li>[ ] when mentionning détienne, also mention her framework: <em>elements</em> inside a <em>context</em> are being <em>perceived</em> and <em>knowledge</em> is extracted from it, to be turned into <em>meaning</em></li>
  <li>[ ] <strong>VERY IMPORTANT</strong>: include the methodology from <a href="https://arxiv.org/pdf/cs/0612004.pdf">detienne’s analysis of kintsch &amp; von dijk</a> (check <a href="https://link.springer.com/chapter/10.1007/978-1-4471-0111-6_2">this one</a> also)</li>
  <li>[ ] wirth: “the computer interprets, i wanted to understand” in beauty is our business, drawing raster lines</li>
  <li>[ ] make it clear that we’re focusing on two sorts of knowledge: formal, or contextual.</li>
  <li>[ ] in the hardware existence of software, talk about memory management</li>
  <li>[ ] in the discussion of what understanding means, at some point, provide the down to earth definition from: <a href="https://www.sciencedirect.com/science/article/abs/pii/S0020737383800315">Towards a theory of the comprehension of computer programs</a>, by Ruven Brooks</li>
  <li>[ ] <a href="https://www.sciencedirect.com/science/article/abs/pii/0010028581900128">this</a> is actually showing that, the more expert a programmer becomes, the less they resort to metaphors, and rather shift to the programming-specific concepts.</li>
  <li>[ ] add <a href="https://sci-hub.mksa.top/10.1016/s0020-7373(05)80090-2">the initial stages of program comprehension</a> on <strong>beacons</strong> (detienne).</li>
  <li>[ ] add <a href="https://www.sciencedirect.com/science/article/pii/095058499591491H">a conceptual model of cognitive complexity</a> (chunking, tracing)</li>
  <li>[ ] add a reference and discussion of Fedorenko (fedorenko_language_2019) in terms of cognitive mapping</li>
  <li>“Understanding the interdependencies among different requirements and among the different layers is both an important step for, on one hand, representing it formally, as well as, on the other hand, one of the goals to be grasped by the reader.”</li>
  <li>[ ] add to the programmer expertise <a href="https://books.google.de/books?hl=en&amp;lr=&amp;id=rMmxq8q0CGYC&amp;oi=fnd&amp;pg=PA8-IA6&amp;dq=L.M.+Berlin">https://books.google.de/books?hl=en&amp;lr=&amp;id=rMmxq8q0CGYC&amp;oi=fnd&amp;pg=PA8-IA6&amp;dq=L.M.+Berlin</a>,+%E2%80%9CBeyond+Program+Understanding,%E2%80%9D+A+Look+at+Programming+Expertise+in+Industry,+Empirical+Studies+of+Programmers,+Fifth+Workshop,+pp.+6-25,+1993.&amp;ots=gO-IgzpVOE&amp;sig=ozpfd-DluQ3k4IE7TBnCix0TT7I&amp;redir_esc=y#v=onepage&amp;q&amp;f=false <strong>also</strong> <a href="http://scholar.google.com/scholar?hl=en&amp;q=J.+Koenemann+and+S.P.+Robertson%2C+%E2%80%9CExpert+Problem+Solving+Strategies+for+Program+Comprehension%2C%E2%80%9D+Proc.+Conf.+Human+Factors+and+Computing+Systems%2C+pp.+125-130%2C+1991">http://scholar.google.com/scholar?hl=en&amp;q=J.+Koenemann+and+S.P.+Robertson%2C+%E2%80%9CExpert+Problem+Solving+Strategies+for+Program+Comprehension%2C%E2%80%9D+Proc.+Conf.+Human+Factors+and+Computing+Systems%2C+pp.+125-130%2C+1991</a>.</li>
  <li>[ ] at the end of the psychology section, mention the skills needed by a programmer (see below) and this will help us in the followig cognitive tools section to prove that tools indeed help with some of these.</li>
  <li>[ ] in terms of metaphors, make clear that programmer-facing metaphors are not more complex than user-facing metaphors, or that it’s a different kind of cognitive work, but rather that they are referring to a different kind of concept (streams, pipes, volatile memory, etc.)! For instance, mention how there are files/folders for users, and these are manipulated differently on GUI and CLI (CLI -&gt; bash script: “loops”, “labels”, “wildcards”). these show that the metaphors at work in programming are a combination of different concepts, drawing on different fields of knowledge.</li>
  <li>[ ] add to means of understanding and IDEs deciding how we write: <a href="https://thorstenball.com/blog/2020/02/04/how-much-do-we-bend-to-the-will-of-our-tools/">https://thorstenball.com/blog/2020/02/04/how-much-do-we-bend-to-the-will-of-our-tools/</a></li>
  <li>[ ] Peter G. Neumann. Psychosocial implications of computer software development and use: Zen and the art of computing.</li>
</ul>

<p>Also, Fuller’s taxonomy, derived from Bloom’s taxonomy. It is represented by two semi-independent dimensions, Producing and Interpreting. Each dimension defines hierarchical linear levels where a deeper level requires the competencies from the previous ones. Producing has three levels (None, Apply, and Create) and Interpreting has four (Remember, Understand,  Analyze, and Evaluate). \citep{fuller_developing_2007}</p>

<p>intrinsic characteristics of cs:</p>

<ul>
  <li>problem solving</li>
  <li>domain modelling</li>
  <li>knowledge representation</li>
  <li>efficiency in problem solving</li>
  <li>abstraction/modularity</li>
  <li>novelty/creativity</li>
</ul>

<h2 id="chap-1---ideals">chap 1 - ideals</h2>

<ul>
  <li>[ ] add marielle macé to a bit of conclusion on the styles of programmers (maybe once the part about simmel is extracted from the craft)</li>
  <li>[ ] add a reference to MOONBIT in the ideals or in the lit review</li>
  <li>[ ] include the hacker dictionary definition of elegance <a href="http://www.catb.org/~esr/jargon/html/E/elegant.html">http://www.catb.org/~esr/jargon/html/E/elegant.html</a></li>
  <li>[ ] add a quote from Ershov, 1972: “A professional aesthetic influences and is influenced by the ethical code of a profession, by the technical subject matter of the profession, and by the profession’s juridical status. […] The creative nature  of programming does not require special proof. Indeed, I may assert, programming goes a little further than most other progressions, and comes close to mathematics and creative writing.” and “We understand what we are able to program.”</li>
</ul>

<h2 id="introduction">introduction</h2>

<ul>
  <li>[ ] make the connection between abstract code beauty (the doxa) and the mathematical sublime of Kant</li>
  <li>[ ] a sentence or two on a fundamental connection between architecture and programming, related to how architecture must connect form and function as other arts are not required to do</li>
  <li>[ ] If you want to exhibit the difference between a (reasonably) high-level language, assembly, and machine code, you could contrive an example yourself by writing something very short in C and compiling it in gcc. The GNU Assembler, as, is what is used as part of the gcc toolchain, so if you were to write the corresponding assembly and confirm that it assembles to the same machine code … you have your example. And you might do it in a half-page of C, a similar amount of assembly, and 32 bytes of machine code.</li>
  <li>[ ] make a <strong>clear</strong> distinction between <code>source code</code> (the medium) and <code>program text</code> (the instance)</li>
  <li>[ ] refine our definition of aesthetics by adding the fact that <code>it enables an  evaluative appraisal of objects</code></li>
  <li>[ ] add this section to the introduction, making sure i frame aesthetic vs. beautiful vs. artistic</li>
</ul>

<blockquote>
  <p>There is also a broad definition of what aesthetic is, and is different from beautiful, which also elicits an emotional response, or gut feeling, and can be implied in definitions of what is artistic. so i don’t talk about beauty, but about code which exhbitis positive aesthetic properties—finding beautiful code in an art history sense has not been achieved.</p>
</blockquote>

<ul>
  <li>
    <p>[ ] add this in the literature review: <a href="https://lectoraatchangemanagement.files.wordpress.com/2020/01/beauty_in_code.pdf">https://lectoraatchangemanagement.files.wordpress.com/2020/01/beauty_in_code.pdf</a> specifically mentioning that there are two kinds of aesthetics (low-level, clear ones, and high-level, more diffuse, subjective, beautiful)</p>
  </li>
  <li>
    <p>[ ] add this to the software architecture section: books about open source architecture, edited by greg wilson</p>
  </li>
</ul>
<p><a href="https://aosabook.org/en/index.html">https://aosabook.org/en/index.html</a> -<a href="https://aosabook.org/en/zeromq.html">https://aosabook.org/en/zeromq.html</a></p>

<h2 id="structure-notes">structure notes</h2>

<ul>
  <li>[ ] And then spread out in the ideals to make each section less heavy</li>
</ul>

<h3 id="ide-notes">ide notes</h3>

<ul>
  <li><strong>overall</strong> computer-aided software engineering <a href="https://en.wikipedia.org/wiki/Computer-aided_software_engineering">https://en.wikipedia.org/wiki/Computer-aided_software_engineering</a> (history is interesting, started with <a href="https://www.applefritter.com/content/lisa-workshop-info">Lisa Workshop</a> for Apple, IBM was also important, and in the 90s there was a peak of software, <a href="https://archive.org/details/Macintosh_Programmers_Workshop_missing_735736/mode/2up">Programmer’s Workshop</a>)</li>
  <li><strong>good social typology</strong> <a href="https://academiccommons.columbia.edu/doi/10.7916/D81261G0">https://academiccommons.columbia.edu/doi/10.7916/D81261G0</a></li>
  <li><strong>_IDE work framed with activity theory</strong> <a href="https://link.springer.com/article/10.1023/A:1015299228170">https://link.springer.com/article/10.1023/A:1015299228170</a></li>
  <li><strong>important</strong>: <a href="https://www.sciencedirect.com/science/article/pii/S1071581905001102">meta study of IDEs</a>, and <a href="https://dl.acm.org/doi/abs/10.1145/358506.358512">typology</a></li>
  <li><strong>study of tool usage</strong> <a href="https://ieeexplore.ieee.org/abstract/document/4222616">https://ieeexplore.ieee.org/abstract/document/4222616</a></li>
  <li><a href="https://dl.acm.org/doi/abs/10.1145/2047196.2047215">https://dl.acm.org/doi/abs/10.1145/2047196.2047215</a> IDEs can help alleviate some of the complexities (connected, parallel computing), but there are still issues. (collaborative code also <a href="https://dl.acm.org/doi/abs/10.1145/1384271.1384315">here</a>)</li>
  <li><a href="https://ieeexplore.ieee.org/abstract/document/1463097">https://ieeexplore.ieee.org/abstract/document/1463097</a> history of eclipse, comparison with visual studio .NET “It is inexpensive to use and makes it much easier to integrate their tools with one another.” (more about eclipse here: <a href="https://ieeexplore.ieee.org/abstract/document/1657944">https://ieeexplore.ieee.org/abstract/document/1657944</a>, how it helps to integrate other tools <a href="https://ieeexplore.ieee.org/abstract/document/5386785">here</a> and how programmers use it <a href="https://dl.acm.org/doi/10.1109/MS.2006.105">here</a>)</li>
  <li>it looks like eclipse exists since at least 1985</li>
  <li>eclipse quick fix: <a href="https://dl.acm.org/doi/abs/10.1145/2398857.2384665">https://dl.acm.org/doi/abs/10.1145/2398857.2384665</a> mentions the complexities of checking complex changes</li>
  <li>things that are important for IDEs (<a href="https://arxiv.org/pdf/1404.6602.pdf">https://arxiv.org/pdf/1404.6602.pdf</a>):
    <ul>
      <li>continuous processing</li>
      <li>non-linear editing</li>
      <li>dependency analysis and caching</li>
    </ul>
  </li>
  <li><a href="https://dl.acm.org/doi/abs/10.1145/1806799.1806866">https://dl.acm.org/doi/abs/10.1145/1806799.1806866</a> concept of <strong>code bubbles</strong></li>
  <li>“These observations suggest a new model of program understanding grounded in theories of <em>information foraging</em>” <a href="https://dl.acm.org/doi/10.1109/TSE.2006.116">https://dl.acm.org/doi/10.1109/TSE.2006.116</a></li>
  <li>designing an IDE specifically with OOP in mind, or with <a href="https://ieeexplore.ieee.org/abstract/document/287018">signal processing</a></li>
  <li>demo of how this IDEs can help from the 90s <a href="https://dl.acm.org/doi/abs/10.1145/64140.65020">https://dl.acm.org/doi/abs/10.1145/64140.65020</a></li>
  <li>more history for the MESA programming environment: <a href="https://dl.acm.org/doi/abs/10.1145/17919.806843">https://dl.acm.org/doi/abs/10.1145/17919.806843</a></li>
  <li><strong>EMACS</strong> documentation: <a href="https://chrismennie.ca/EMACS-Conceptual-Architecture.pdf">https://chrismennie.ca/EMACS-Conceptual-Architecture.pdf</a></li>
</ul>

<h2 id="meeting-with-nick-4112022">meeting with nick 4.11.2022</h2>

<ul>
  <li>is it clear why i’m addressing definitions of understanding first, and then the actual object of understanding?</li>
  <li>is it more about understanding, or knowledge communication/knowledge reception?</li>
  <li>in general, i’m a bit unsure about how clear my approach to understanding is. i know it’s necessary to clarify what i mean, and the intent is to provide background for this “dual nature” of software.</li>
</ul>

<h2 id="meeting-with-nick">meeting with nick</h2>

<ul>
  <li>[ ] pare down!
    <ul>
      <li>[ ] in the listings, extend the caption to show the relevance of the snippet (e.g. for listing 8, neither is said about APL or about Game of Life: how should readers know this is relevant?)</li>
      <li>[ ] for stats comparing different software (windows2000, wp, kirby), use a chart to make the point much quicker</li>
      <li>[ ] justify the comparison between win2000 and kirby (differences in size, date of creation)</li>
      <li>[ ] also explain a bit more fast sqrt (greg walsh must have had a deep knowledge of ieee floating points standards)</li>
      <li>[ ] fig. 10: original is color coded, but also too hard to comprehend. <a href="https://demozoo.org/productions/305589/">magmarize</a> would be a better example</li>
      <li>[ ] move listing 10 to understanding computers</li>
      <li>[ ] one liner: monostiche</li>
      <li>[ ] since the chapter is too long, paraphrase code, rather than quote it</li>
      <li>[ ] listing #2, not style but voices</li>
      <li>[ ] black perl is still in old mode</li>
      <li>[ ] explain listing 13</li>
    </ul>
  </li>
  <li>[ ] table of listings: this is what the work is about (variety, meaningful, captioned; the caption is also for me cause it shows i am able to express concisely why the example is there)</li>
</ul>

<h2 id="general">general</h2>

<ul>
  <li>[ ] add all the refernces in the intro footnotes</li>
  <li>[ ] add <a href="../readings/notes/pressman_software_engineering_practicioners_approach.md">pressman - software engineering: a practicioner’s approach</a></li>
  <li>[x] rewrite my definition of aesthetics to include more the aesthetics of everyday life?
    <ul>
      <li>[x] drawing from mckenzie, rewrite his part to include the fact that he puts a lot of lines of code in his book, but that it’s still a mostly social/anthropological interpretation of said code</li>
      <li>[x] specify that the term <em>software engineering</em> appeared in 1968 at a conference [[wirth_history_software_engineering]]. but actually it’s fuzzy, some people say it was around 1967 <a href="https://www.princeton.edu/~hos/mike/articles/hcht.pdf">src</a></li>
    </ul>
  </li>
  <li>[x] ideals
    <ul>
      <li>[x] add the dope case study <a href="https://queue.acm.org/detail.cfm?id=1039535">https://queue.acm.org/detail.cfm?id=1039535</a> also this <a href="http://denninginstitute.com/pjd/GP/gp_summary_toplevel.html">http://denninginstitute.com/pjd/GP/gp_summary_toplevel.html</a></li>
      <li>[x] re read hacker examples part to check for spoilers</li>
      <li>[x] add research software engineers to data scientists <a href="https://www.nature.com/articles/d41586-022-01516-2">https://www.nature.com/articles/d41586-022-01516-2</a></li>
      <li>[x] tone down on methodology?</li>
      <li>[x] add stats about corpus after methodology.</li>
      <li>[x] add section on leslie vaillant in the elegance section <a href="https://dl.acm.org/doi/abs/10.1145/1953122.1953131">https://dl.acm.org/doi/abs/10.1145/1953122.1953131</a></li>
      <li>[x] add knuth details on elegance (see <a href="../readings/notes/fuller_software_elegance.md">notes</a>)</li>
      <li>[x] add section on robin hill on elegance <a href="https://cacm.acm.org/blogs/blog-cacm/208547-what-makes-a-program-elegant/fulltext">https://cacm.acm.org/blogs/blog-cacm/208547-what-makes-a-program-elegant/fulltext</a></li>
      <li>[x] include some further discussion of programming based on <a href="https://hapoc2021.sciencesconf.org/data/pages/_Toscano_Intentionalities_of_code_presentation.pdf">hapoc 21 presentation</a></li>
      <li>[ ] add a bit more meat to the section on scientific beauty</li>
      <li>[ ] deal with frames and page breaks on minted; <a href="https://tex.stackexchange.com/questions/433192/breaking-pages-in-minted-package">https://tex.stackexchange.com/questions/433192/breaking-pages-in-minted-package</a></li>
      <li>[x] add “hacking perl” and live code in the artists section <a href="https://www.perl.com/pub/2004/08/31/livecode.html/">https://www.perl.com/pub/2004/08/31/livecode.html/</a></li>
      <li>[x] everytime i quote SO, add the specifics of the survey details</li>
    </ul>
  </li>
</ul>

<p>~~look into the pdf “program text, style, laber” by brian lennon to address comments in microsoft windows source code~~</p>

<p>~~yullil - code art brutalism refers the <em>HACKMEM</em> document from 1972 MIT, related to architecture.~~</p>

<p>~~communautés épistémiques et communautés de pratique (Cohendet et al., 2001) -&gt; Cohendet, Patrick, Creplet, Frederic &amp; Dupouet, Olivier. « Organisational innovation, communities of practice and epistemic communities : the case of Linux ». In Economics with heterogeneous interacting agents~~</p>

			</div>
		</body>
	</html>
