## two - defining further the object of study

---------------

---------------
steps:
1. identify the approach (lit review)
2. identify the discourses and frameworks which qualify code as beautiful
3. extract and sum up the features (elegance, simplicity, editability)
4. how does it reconnect to the aesthetic?
5. see how they are differently implemented in different languages

---------------

the aesthetics of clarity in executable source code

Machine understanding / clarity / cleanliness / elegance / simplicity

**what are the aesthetic properties of source code and how do they vary based on languages?**

what is the difference between aesthetics and poetics? (micro vs. macro?) ---- **coming into being**

instead of finding the broader poetics, i will focus on the specific aesthetics: the creation, manifestation and appreciation of small scale formal, sensitive revelations.

poetics is activity, aesthetics is opportunity

the challenge of an aesthetic work is to figure its identity (drucker)
The activity has ontological dimensions—what is and makes a work an aesthetic work—and epistemological ones—how do we know or sense (to pose this phenomenologically) that we are in the presence of an aesthetic object or experience?
How, I asked myself, how does aesthetic work come to figure against the jealous ground of noise culture? And be perceived? Identified? Given place and value? (still drucker)

one of the key points is going to examine the role of *understanding*.
understanding as a means to:
- apprehend something: a situation (object, context, possibilities of actions, consequences of actions)
- refer to something else at a different time and place, while still being able to draw a parallel

is there a difference between human understanding and machine understanding? -> perhaps human understanding is unbounded by time and place, while machine understanding has to be clearly delimited.

on the opposite side, however, human understanding is fuzzy at best. it doesn't quite know exactly what it is dealing with (wittgenstein: all philosophical problems are formulation problems). in that sense, the machine is already extremely clear, but within a very constrained set (e.g. chess)

the machine understands chess insofar as it can play chess. it doesn't understand chess (so far) such that it could apply the patterns of chess to the patterns of some other rule domain. human understanding of chess exists without the chessboard.

how do we make those two understanding coexist, then? it goes through language: language is key in both narrow (math) and broad (poetry) definitions. the laying out of language (formulation and writing) then allows (to some extent) for those understandings. the broad conceptual maps (**poetics**) are actually language-independent. a plot twist is a plot twist in any language. However, the way you reveal the plot twist could actually vary from language to language.

aesthetics enable the understanding (goodman), while poetics provide a framework which *tilts*, or influences the approach of that understanding. it is not what is meant to be understood, but it is *the presented facet* of what is supposed to be understood. (e.g. qualitative vs. quantitative, or drama vs. comedy)
